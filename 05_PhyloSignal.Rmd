# Phylogenetic Signal in R

Phylogenetic signal is the pattern where close relatives have more similar trait values than more distant relatives (see Kamilar and Cooper 2013). The aims of this exercise are to learn how to use R to estimate phylogenetic signal using Pagel's $\lambda$ and Blomberg's *K*. 

We will be using the evolution of eye size in frogs as an example. The data and modified tree come from Thomas et al 2020 (CITE PROPERLY), and the original tree comes from Feng et al (2019; CITE PROPERLY). I've removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out Thomas et al 2020 (CITE PROPERLY)!

You will also need to install the following packages: 

* `ape`
* `geiger`
* `treeplyr`
* `caper`
* `tidyverse`

***
## Preparation

To begin we need to load the packages for this practical.

```{r, message = FALSE}
# Load the packages
library(ape)
library(geiger)
library(treeplyr)
library(caper)
library(tidyverse)
```

Next we need to prepare the tree and data for the analyses. In the `04-Preparation.Rmd` exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven't previously. 

It is important to do these things before beginning a phylogenetic comparative analysis, so let's run through that code again here.

```{r}
# Read in the data
frogdata <- read_csv("data/frog-eyes.csv")
# Check everything loaded corrected
glimpse(frogdata)
```

To load the tree we will use `read.nexus`.
```{r}
# Read in the tree
frogtree <- read.nexus("data/frog-tree.nex")
# Check it loaded correctly
str(frogtree)
```

Remember to check the tree is dichotomous, i.e. has no polytomies, and rooted. 

```{r}
# Check whether the tree is binary
# We want this to be TRUE
is.binary.tree(frogtree)
# Check whether the tree is rooted 
# We want this to be TRUE 
is.rooted(frogtree)
```

Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further.

```{r}
# Check whether the names match in the data and the tree
check <- name.check(phy = frogtree, data = frogdata, 
                    data.names = frogdata$tiplabel)
# Look at check
check
```
Here all the excluded species are excluded because they are genuinely missing, not because of any typos, so we can move on.

Next we combine the tree and data to exclude species that are not in both, using the `treeplyr` function `make.treedata`.

```{r}
# Combine and match the tree and data
frogstuff <- make.treedata(tree = frogtree,  data = frogdata, 
                              name_column = "tiplabel")

# Look at the tree
frogstuff$phy
# Look at the data
glimpse(frogstuff$dat)
```

Then we replace the removed species names column, and save the data as a dataframe for later analyses.

```{r}
# Make a new column called Binomial with the tip labels in it
frogstuff$dat$Species <- frogstuff$phy$tip.label
# Force mydata to be a data frame
mydata <- as.data.frame(frogstuff$dat)
```

Finally we save the tree:

```{r}
# Save tree as mytree
mytree <- frogstuff$phy
```

Note that is is possible to use the `make.treedata` object directly to run some analyses, but we have saved these separately here as many PCMs cannot work with this.

Now we're ready to run our analyses!

## Estimating phylogenetic signal for continuous variables
As is common in R, there are a number of ways to estimate Pagel's$\lambda$ and Blomberg's *K*. I've chosen to show you the way implemented in the package `phytools` because it allows you to use the same function for both.

Let's estimate $\lambda$ for log eye size.

The first thing we need to do is to create an object in R that only contains the variable required, and the species names (so we can match it up to the tree). 

We can use the function `pull` to extract just the eye size values, and we can log transform all these numbers using `log` if we want to work with log eye size values.

```{r}
# Create logGL containing just log eye size length values
logEye <- log(pull(mydata, eyesize))
# Look at it
logEye
```

Notice that this is currently just a long list of numbers. We can then name these values with the species names from `mydata` using the function `names`. Note that this requires the trait data is in the _same order_ as the tree tip labels, but luckily `make.treedata` does this automatically.

```{r}
# Give log Eye names = species names at the tips of the phylogeny
names(logEye) <- mydata$Species
# Look at it
logEye
```

Now we have a list of values with associated species names.

### Pagel's $lambda$

We can now estimate lambda using the function `phylosig`:
```{r}
lambdaEye <- phylosig(mytree, logEye, method = "lambda", test = TRUE)
```
`test = TRUE` specifies that we want to run a likelihood ratio test to determine if lambda is significantly different from 0.

To look at the output we just type in the name of the model; `lambdaEye` in this case
```{r}
lambdaEye
```
logL	
log-likelihood, for estimation with sampling error.

The $\lambda$ estimate for log eye size is 0.803. `logL` is the log-likelihood, `logL0` is 	the log-likelihood for lambda of 0, and `P` is the p value from a likelihood ratio test testing whether lambda is significantly different from 0 (no phylogenetic signal).

Here p < 0.001. We interpret this as $\lambda$ being significantly different from 0, i.e. there is significant phylogenetic signal in log eye size.

### Blomberg's *K* (Blomberg et al 2003)
To estimate Blombergâ€™s *K* we also use `phylosig` but with `method = K`.

```{r}
KEye <- phylosig(mytree, logEye, method = "K", test = TRUE, nsim = 1000)
```
Additionally we add the argument `nsim = 1000`. This is because we need to use a randomisation test to determine whether *K* is significantly different from 0. `phylosig` randomly assigns the trait values to the species and then calculates *K* as many times as we ask it to in `nsim` (number of simulations). Here we asked for 1000. After the random simulations are run, the observed value of K is then compared to the randomized values. The p value tells us how many times out of 1000, a randomised value of *K* is more extreme than the observed value. If this number is low, the p value is low (e.g. if 5 out of 1000 randomised values of *K* are more extreme than the observed value p = 5/1000 = 0.005). 

As above, to look at the output we just type in the name of the model; `KGL` in this case
```{r}
KEye
```
*K* for log eye size is 0.283. The p value tells us how many times out of 1000, a randomised value of *K* is more extreme than the observed value. If this number is low, the p value is low (e.g. if 5 out of 1000 randomised values of *K* are more extreme than the observed value p = 5/1000 = 0.005). Here p = 0.001, suggesting that only 1 randomised value of *K* was more extreme than the observed value. 

We interpret this as *K* being significantly different from 0, i.e. there is significant phylogenetic signal in log eye size.

## A few quick points to always consider
First, why do we look at two different measures of phylogenetic signal? We don't have to, you could choose one and stick to it. However, I guarantee if you choose one then a reviewer/your supervisor/boss will ask for the other, so why not do both and pop one in the appendix?

Second, remember that when fitting models to account for phylogenetic nonindependence, it is *not* phylogenetic signal in the individual variables that is important. It is phylogenetic signal in the __residuals__ of the model that matters. Evidence of phylogenetic signal in variable X (or variable Y) does not necessarily mean that there will be phylogenetic signal in the residuals of a model correlating variable X with variable Y. Conversely, lack of evidence of phylogenetic signal in variable X (or variable Y) does not necessarily mean that there will be no phylogenetic signal in the residuals of a model correlating variable X with variable Y.

Third, always carefully consider what variation in values of $lambda$ and *K* across traits and clades really means. It may not tell you as much about your system as you think it does.

## Practical exercises

In the data folder there is another tree (`consensusTree_10kTrees_Version2.nex`) and dataset (`primate-life-history-data.csv`) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold et al. 2010). 

What are lambda and K for log gestation length in Primates? 

Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in the previous exercise which should save you some time). Then use phylosig to estimate lambda and K for log gestation length.