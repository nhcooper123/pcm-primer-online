[["index.html", "Online materials for Primer on Phylogenetic Comparative Methods for the Biological Sciences Oxford Biology Primer series. Primers in Ecology and Evolutionary Biology. Preface Datasets and scripts How to use these materials Boxes Example datasets Citing R and R packages Acknowledgements", " Online materials for Primer on Phylogenetic Comparative Methods for the Biological Sciences Oxford Biology Primer series. Primers in Ecology and Evolutionary Biology. Natalie Cooper Preface The material in this online book is designed to support the Primer on Phylogenetic Comparative Methods for the Biological Sciences by Natalie Cooper and Rob P Freckleton. These materials were primarily written by me (Natalie), so don’t blame Rob for any errors! All practical exercises use R (R Core Team 2023), so some knowledge of R is required. I have provided the basics in the first chapter. The online book focuses on practical implementations of methods for the most part. For information on the theoretical underpinnings of the topics covered here please refer to the Primer. Datasets and scripts [UPDATE THIS WHEN FINISHED WITH OUP LINK] All datasets, trees, R scripts (as R Markdown/.Rmd files), and an R Project (.Rproj) file for each exercise are available for download as a ZIP from here. When you click this link it will take you to a website and the download should start automatically. Don’t forget to unzip** this before starting.** The data/trees and scripts are in the appropriate folder for each practical exercise. Note that there is a folder for each of the exercises in the workbook. How to use these materials It is possible to use these materials in a number of ways. Follow the online workbook in a web browser, copy-pasting code into an R script and then running it in the R console. Open the .Rmd (R Markdown) file for each exercise in RStudio and use it to run the code. This allows you to run chunks of code in the script and for the results to appear below the code. You need to open the .Rmd file in folder that contains the correct datasets for that exercise. To run the code, you just click the little green triangles to the far right of each code chunk (grey boxes with R code in them) to run the code as shown below. What a code chunk looks like in an RMarkdown file. The outputs, graphs and results will all appear in the .Rmd file underneath the code, as shown below. After you click the green triangle in the top left hand corner of the code chunk, the code runs and the outputs appear under the code chunk within the RMarkdown file. This is probably the best way to learn these methods. Note, however, that some of the formatting will look a bit weird. For example to get RMarkdown to output the Greek letter \\(\\lambda\\) (lambda) we type $\\lambda$. If you want to use these files I’d recommend also opening the online workbook in a web browser so if anything looks odd you can check what it is meant to look like! All the code and outputs are shown in the online workbook, so you can also use this as a reference and then use the code to complete the practical exercises at the end of each chapter, or to apply them to your own data. This might be a good solution if you’re using these materials to learn something specific and don’t need practice with R or PCMs. Boxes Throughout the book are boxes of text highlighting particularly important issues: Information boxes. These boxes highlight important details. These boxes may also show you how to solve problems that may not affect every user. Extra details boxes. These boxes contain detailed explanations of things for those who like to fully understand the complexities of what they are doing, for example technical details of the code that I have not explained in detail in the text. Caveats boxes. These boxes highlight important points that need to be considered when working through your own analyses. They reveal areas where it is important to be careful and think about what you are doing and why. The image is a Jurassic Park era velociraptor to remind you of the “Jurassic Park caveat”, i.e. that just because you can perform an analysis in R doesn’t mean that you should (thanks to Dr Ian Malcolm and Dr Michael Crichton)! Always consider the question at hand, your study group, and the quality of the data you are using before embarking on a new comparative analysis. Example datasets I’ve tried to keep my examples to a minimum so that you have chance to get familiar with the trees and data. As such there are just three main example datasets in this book. In each case I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to use these datasets for your own work you should download the data from the publications listed to get the complete datasets Apologies in advance to the non-vertebrate, non-animal fans out there. To make up for it I’ve added several plant and invertebrate examples to the practical exercises at the end of each chapter. If it helps just replace the word frog with fly, snake with sponge, and marsupial with grass. It won’t alter the R code. Frog eye size evolution Frog eyes are really variable. Two tree frogs with large eyes and a burrowing frog and an aquatic frog with tiny eyes. Image credits: hehaden/Flickr CC BY-NC 2.0; Brian Gratwicke/Flickr CC BY 2.0, Rushen/Flickr CC BY-SA 2.0, Sue Cro/Flickr CC BY-NC 2.0 Who doesn’t love frogs? Frogs are cool. One of the coolest things about them is that they have weird bulgy eyes…or do they? Some species have teeny tiny eyes, while others have massive eyes. In fact frogs have some of the biggest eyes relative to their body size across all vertebrates. K. N. Thomas et al. (2020) predicted that this variation might be due to where they live, their mating habits, the time of day they are active, and their body size. In our examples we’ll test some of these hypotheses using phylogenetic comparative methods. The data and modified tree for this example come from K. N. Thomas et al. (2020), and the original tree comes from Feng et al. (2017). If you want to see the full results check out K. N. Thomas et al. (2020)! And there’s a nice summary of the paper here. Natricine snake head shape evolution Snakes have different head shapes in different habitats. These are (clockwise starting in the top left) terrestrial/semiaquatic, aquatic, aquatic burrowing, and burrowing natricines. Image credits: see V. Deepak, Gower, and Cooper (2023) Snakes are also cool, especially natricines which are the group that contains both the delightful European grass snake (Natrix natrix) and the ubiquitous garter snakes (genus Thamnophis) of North America. Natricine snakes are found across the globe, and have a range of interesting ecologies and more morphological variation than you might expect, especially in their head shape. V. Deepak, Gower, and Cooper (2023) predicted that these variations in head shape would be more closely related to the ecomorph they belonged to (i.e. whether the snake was terrestrial, aquatic, burrowing or aquatic burrowing) than their evolutionary history. They expected that head shape might be an example of convergent evolution. In our examples we’ll test some of these hypotheses using phylogenetic comparative methods. The data for this example comes from V. Deepak, Gower, and Cooper (2023), and the tree comes from V. Deepak et al. (2021). If you want to see the full results check out V. Deepak, Gower, and Cooper (2023)! Diversification in dragonflies Dragonflies are amazing, this is Aeshna juncea. Image credits: Wikimedia CC BY-SA 3.0 You’ve probably guessed that yes, dragonflies are also cool. They’re incredible predators and extremely agile fliers. My favourite fact about dragonflies is that one species, the globe skimmer (Pantala flavescens) make an annual multi-generational migration of around 18,000km (!) with individual insects flying more than 6,000km (thanks to Dr Jessica Ware for that fact and this dataset!). Dragonflies today are generally found near water, with some preferring lotic habitats with fast flowing waters and others lentic habitats with slow moving waters. The clade has been around for over 300 million years, and currently has over 3000 species. But how quickly did they diversify? Do different clades have different rates of evolution? Do their habitat preferences influence their diversification rates? In our examples we’ll test some of these questions using phylogenetic comparative methods. The 522 species tree for this example comes from Letsch, Gottsberger, and Ware (2016b) and is available to download from Letsch, Gottsberger, and Ware (2016a). This paper looked across dragonflies to investigate whether species from lotic habitats with fast flowing waters diversify more rapidly than species from lentic habitats with slow moving waters. If you want to see the full results check out Letsch, Gottsberger, and Ware (2016b)! Citing R and R packages Lots of people work on R and R packages for free. They’re the reason that R is so great! The best way to thank them for this selfless work is to cite R, and any R packages that you use, whenever you write a report, article, thesis chapter or paper. This means that R developers can show their funders, bosses, supervisors and potential employers that people are using their work. The citation for R will usually look something like this All analyses used R version 4.2.0 (R Core Team 2022). Your version number might be different (4.2.0 is the current version at the time of writing this book). You only need to do this once, usually in the methods section. The full citation for the bibliography is usually something like: R Core Team (2023). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/. If you don’t remember this, or can’t work out what version of R you are using, the R folk have you covered. To get the citation you can use: citation() ## ## To cite R in publications use: ## ## R Core Team (2022). R: A language and environment for statistical computing. R ## Foundation for Statistical Computing, Vienna, Austria. URL ## https://www.R-project.org/. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {R: A Language and Environment for Statistical Computing}, ## author = {{R Core Team}}, ## organization = {R Foundation for Statistical Computing}, ## address = {Vienna, Austria}, ## year = {2022}, ## url = {https://www.R-project.org/}, ## } ## ## We have invested a lot of time and effort in creating R, please cite it when using ## it for data analysis. See also &#39;citation(&quot;pkgname&quot;)&#39; for citing R packages. To get the version of R you can use: R.Version()$version.string ## [1] &quot;R version 4.2.0 (2022-04-22)&quot; You can also look at more version information by running: R.Version() I’ve suppressed the output here as it will be different for every user. The version number is near the bottom of the output. You’ll also see one of the fun things about R here which is that each version has a nickname, all of which are the titles of Peanuts comics! For more info see this slackoverflow discussion. What about R packages? You should cite these at the relevant points in your methods section. For example, for caper(we’ll return to what this does later in the book) we might write We fitted phylogenetic generalised least squares (PGLS) models using the R package caper version 1.0.1 (Orme et al. 2018). To find out what the citation is for an R package we also use the function citation but this time specify the package citation(package = &quot;caper&quot;) ## ## To cite package &#39;caper&#39; in publications use: ## ## Orme D, Freckleton R, Thomas G, Petzoldt T, Fritz S, Isaac N, Pearse W (2018). ## _caper: Comparative Analyses of Phylogenetics and Evolution in R_. R package ## version 1.0.1, &lt;https://CRAN.R-project.org/package=caper&gt;. ## ## A BibTeX entry for LaTeX users is ## ## @Manual{, ## title = {caper: Comparative Analyses of Phylogenetics and Evolution in R}, ## author = {David Orme and Rob Freckleton and Gavin Thomas and Thomas Petzoldt and Susanne Fritz and Nick Isaac and Will Pearse}, ## year = {2018}, ## note = {R package version 1.0.1}, ## url = {https://CRAN.R-project.org/package=caper}, ## } ## ## ATTENTION: This citation information has been auto-generated from the package ## DESCRIPTION file and may need manual editing, see &#39;help(&quot;citation&quot;)&#39;. Usually package citations contain the version number, but if not you can get the version using packageVersion(&quot;caper&quot;) ## [1] &#39;1.0.1&#39; An additional benefit to citing R packages is that it helps people understand exactly what you did. It’s possible there are multiple ways to run a PGLS model, but if your report says you used caper, it’s easy for a reader to check how caper does it and to know exactly what you did. This helps people reproduce your analysis, and can also help you prove to anyone assessing your work that you know what you are doing! Acknowledgements Thanks to the many generations of postdocs and students who have taken courses with me and helped me to hone these materials. And to the many others out there teaching PCMs and writing tutorials that helped me learn these methods in the first place, especially Luke Harmon, Brian O’Meara, David Orme, Sam Price, Dan Rabosky, Liam Revell and Graham Slater. Also thanks to everyone for test running these materials. Particular thanks to the authors of the R packages used and cited in this book. None of this would be possible without them. Do not forget to cite the packages you use in your own work. And if you meet one of them in person, buy them a beer/cake/coffee to say thank you! Best of luck to you all, and happy PCM-ing! References "],["what-you-need-to-be-able-to-do-in-r-before-you-start.html", "Chapter 1 What you need to be able to do in R before you start 1.1 Installing R (and RStudio) 1.2 Downloading the data 1.3 R Projects 1.4 Using a script 1.5 Installing and loading extra packages in R 1.6 Loading and viewing your data in R 1.7 Errors and warnings 1.8 Summary", " Chapter 1 What you need to be able to do in R before you start These days most people have used R a bit, but it is possible you’re a bit rusty, or have no R experience. This isn’t a problem, I will try and summarise what you need to be able to do to get these exercises running below. I am not, however, going to write a full introductory guide to R here, so if you’ve never used R before or find it a bit of a struggle, I strongly recommend the book Getting Started With R or there are lots of great tutorials online. Throughout, R code will be in shaded boxes: library(ape) R output will be preceded by ## and important comments will be in quote blocks: Note that many things in R can be done in multiple ways. You should choose the methods you feel most comfortable with. Don’t panic if I do it differently! 1.1 Installing R (and RStudio) Install R from https://cran.r-project.org You can install RStudio (Desktop) from http://www.rstudio.com/products/rstudio/download/. I highly recommend using RStudio and I will assume you are using it throughout. RStudio is just a wrapper around R, so you still need to install R to use RStudio. If using a Mac, you should also install XQuartz: https://www.xquartz.org/ 1.2 Downloading the data This is zipped and the data/trees for each exercise are in the appropriate folder for each practical exercise. To work through the exercises you need to download all the files into a folder somewhere on your computer. Don’t forget to unzip this before starting. Note that there is a folder for each of the practical exercises in the book. [WHEN FINISHED CLARIFY THE LOCATION OF THE DATA] Some datasets are built into R and/or various R packages (see below), so you may see me access these just using code like this (cars is a dataset built into R): data(cars) Note that this won’t produce any output unless we then ask it to do something with the data, for example print the first six rows… head(cars) ## speed dist ## 1 4 2 ## 2 4 10 ## 3 7 4 ## 4 7 22 ## 5 8 16 ## 6 9 10 1.3 R Projects One feature of R that tends to trip up beginners is that to read data into R you need to tell R where to look for the data. In the past we might have solved this problem by setting the working directory, or writing the full path to a file into our code. This works fine, but if you later move the folder or the data, or send it to a collaborator/supervisor the code stops working. Luckily RStudio has a great solution to the problem: R Projects. If you’re working in an R Project, R will automatically look for data in the folder you’ve chosen to be the project folder! What’s a Project? A “Project” is just a folder that contains a sensible unit of work, for example your undergraduate or Masters thesis, a chapter of your PhD thesis, a paper, or a coursework project. Projects will likely contain several files, including data and R scripts. You may also want to store information related to the report/thesis chapter/coursework that you’re writing. To make an R Project for practical exercises in 05-PGLSinR, for example, go to the menu in RStudio and click File &gt; New Project. You should now see a dialogue box with three options: New Directory, Existing Directory, or Version Control (Directory just means a folder on your computer). Because we already have a folder choose the option Existing Directory. The dialogue box moves on so we can use the Browse button to locate the folder 05-PGLSinR. Finally, click the Create Project button. This will cause a few things to happen. First, RStudio may ask if you want to save any unsaved files if you were already doing something in RStudio. Save them if they are important! Second, RStudio will look like it restarted. And third, a new file will appear in the folder: the .Rproj file, with the same file name as your R Project. When you want to use that R Project in future just double click the .Rproj icon in the folder and it will open the R Project in RStudio for you. To save you some time we have made an .Rproj file for each chapter of this book. They should have been downloaded with the data. To use these just navigate to the appropriate chapter folder and double click the .Rproj icon to start. 1.4 Using a script We can use R straight from the Console (the bottom left hand window in a standard RStudio set up), but this is not ideal for various reasons. Firstly, if we want to run a series of separate commands, and perhaps run them again in the future, or alter one of the commands thus needing to re-run all the subsequent ones, then typing commands into the Console is a pain. Equally we might want to save our commands for future use. To do this we use a script. To get a new script in RStudio use the menus to go from File &gt; New File &gt; R Script. You should type (or copy and paste) your code into the script, edit it until you think it’ll work, and then either paste it into R’s console window, or you can highlight the bit of code you want to run and press ctrl or cmd and enter or R (different computers seem to do this differently). This will automatically send it to the console. Saving the script file lets you keep a record of the code you used, which can be a great time saver if you want to use it again, especially as you know this code will work! You can cut and paste code from these materials into your script. You don’t need to retype everything! If you want to add comments to the file (i.e., notes to remind yourself what the code is doing), put a hash/pound sign (#) in front of the comment. Comments are really important to you remember what you did and why. Always write comments, and generally write more than you think you will need. Future you will thank past you when you need to rerun these analyses in six months! # Comments are ignored by R but remind you what the code is doing. # You need a # at the start of each line of a comment. # Always make plenty of notes to help you remember what you did and why 1.5 Installing and loading extra packages in R You’ll notice at the start of each exercise I remind you of the packages you need to install and load. To run any specialised analysis in R, you need to download one or more additional packages on top of the basic R installation. You need to be connected to the internet to do this. To install the package ape: install.packages(&quot;ape&quot;) Pick the closest mirror to you if asked. Do not put this code into your script as you only need to do this once (until you need to update R), and it’s a waste of your time to do it each time you run your script. You can also install more than one package at a time: install.packages(c(&quot;ape&quot;, &quot;picante&quot;)) Alternatively, you can use the Packages tab in RStudio (in the bottom right hand window in a standard RStudio set up). If you click the Install button this will open a pop up where you can type in a list of the packages you want to install, and then just click Install. If you do this, you’ll see the appropriate install.packages code appear in your console. If everything worked you will see some (often a lot if you’re installing a big package like tidyverse or ggtree) text appearing in the console, and the occasional warning message but importantly no error messages. Don’t let this worry you. If you’re in doubt about whether a package has installed correctly, go to the next step (see Loading packages into R below) to check. If you see an error message (these will contain the prefaceError:, see section below on Errors and warnings for more details), then something, somewhere has gone wrong. Installation errors will generally say something about non-zero exit status of the package, which just tells you that it was not installed. You might need to scroll up a bit to find this. Some common issues that might arise when installing packages are: R asks if you would like to update other packages that the package you are installing needs to work. You might see the question Update all/some/none? [a/s/n]:. In that case type a and press enter, and R will update these packages too. R asks if you Do you want to install from sources the packages which need compilation? (Yes/no/cancel) or similar. In this case, type Yes or y or whatever the suggested option is for yes. However if this doesn’t work and the installation gives you an error, try installing again and this time choose the option for no. Some packages will need to be compiled from source. If you’re using a Mac you may also need to install clang from this page https://cran.r-project.org/bin/macosx/tools/ before this will work. This can be tricky on a Mac so you may need to use Google to find out how to fix things if this will nto work for you. An annoying error you may encounter (generally on a Mac), is that you keep seeing error messages when trying to install some packages, even after trying the solutions above. This might be because you’re installing via the RStudio default server for packages. To fix this, change your default by going to RStudio &gt; Preferences &gt; Packages. You should see a box with CRAN mirror above it. Change this from Global (CDN) RStudio to your closest mirror on the list and click Apply. This should fix the problem and only needs to be done once. Note that this issue may be fixed soon by RStudio, but has been an issue in the current version. If you see non-zero exit status and the name of a package you weren’t trying to install, it just means that this package is needed for the package you are trying to install to work. In these cases, try installing that package, then if that works try again with the package you wanted to install. If it still won’t work, it’s also worth trying to install packages both in RStudio, and just in the normal version of R you downloaded. For this there is no Packages tab so you need to use install.packages. If you get other kinds of errors don’t panic. Check you are connected to the internet. Read the error message carefully to see if it gives you any clues. If that fails, try pasting the error message into Google and seeing if anyone else has had the same error. 1.5.1 Loading packages into R You’ve installed the packages but they don’t automatically get loaded into your R session. Instead you need to tell R to load them every time you start a new R session and want to use functions from these packages. To load the package ape into your current R session: library(ape) You can think of install.packages like installing an app from the App Store on your smart phone - you only do this once - and library as being like pushing the app button on your phone - you do this every time you want to use the app (credit to Dylan Childs for this great analogy!). For many packages, you won’t see any message at all when you run library(package_name). That means the code has worked. Some packages will print a message explaining some feature of the package, or telling you that it is also loading some other package, or highlighting that the package was written for a newer version of R. As long as you don’t see an error message, everything is fine. If you run library(package_name) and you get the error message Error in library(package_name) : there is no package called ’package_name’package not found, this means you have not installed the package properly. Often just going back and trying to install it again will work. Or check out the list of possible solutions above. 1.5.2 ggtree, a special case for package installation Packages are generally installed from CRAN, the same place you downloaded R from. But some communities share their packages in different ways. ggtree is one such package. To install ggtree we need to use Bioconductor instead as follows: if (!requireNamespace(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;ggtree&quot;) You still need to load it using library as usual. Note that ggtree will produce a long message when you first load it telling you how to cite the package, and some functions it contains with the same names as functions in other packages (I’ve suppressed this here). library(ggtree) 1.6 Loading and viewing your data in R R can read files in lots of formats, but for simplicity we’ll use comma-delimited or .csv files in these exercises. Excel (and many other applications) can output files in this format (it’s an option in the Save As dialogue box under the File menu). As an example, here is how you would read in a comma-delimited text file called Primatedata.csv using the readr package: library(readr) primatedata &lt;- read_csv(&quot;Primatedata.csv&quot;) This is a good point to note that unless you tell R you want to do something, it won’t do it automatically. So here if you successfully entered the data, R won’t give you any indication that it worked. Instead you need to specifically ask R to look at the data. We can look at the data by typing: str(primatedata) Or if we are using the tidyverse packages library(tidyverse) glimpse(primatedata) I’ve suppressed the output here to keep the document smaller. Always look at your data before beginning any analysis to check it read in correctly. I will cover this in more detail in later sections. 1.7 Errors and warnings Errors are where the code fails to run and you see an error message prefaced in R by Error:. Often these mistakes are caused by typos, missing commas, or missing parentheses. R is very pedantic so this happens a lot! But they can also be caused by applying functions incorrectly or to the wrong kinds of data. Error messages are sometimes helpful, but often pretty baffling especially for beginners. If you get an error message don’t panic. Read the message and see if you can work out what the issue is. Check your code carefully for typos. Make sure you’re using the correct data and variable names etc. If you can’t work out what the error means, try Googling it (remove any words specific to your data from it first). Google may be able to tell you what the issue is. If that still doesn’t help, try asking colleagues or post a question online. The important thing about errors is that the code does not run. Warnings, on the other hand, appear when the code runs fine, but R wants to alert us to something, for example that the code might not be doing what you intended, or R has recognised that something you asked it to do is a bit risky. Do not ignore warning messages!. Always read the warning message and try to understand what it means. You may figure out that you can safely ignore the warning (I will try and note these situations in the exercises here). Otherwise you probably need to try and fix it. 1.7.1 Removing the + Some R functions are pretty long, meaning that they need to appear on more than one line in the Console. In a long function, you therefore see a + in front of all lines except the first one. This tells you that R is running the code together. Unfortunately, if you accidentally fail to finish a line of code (for example by not closing ” or parentheses), R will assume you haven’t finished and will add a + on the next line. If that wasn’t your intention, and you try to run another bit of code on the next line, then that next line of code won’t work leading to an error. Don’t worry, this happens all the time! If you’re getting error messages and can’t see why, just check that the Console is showing the prompt &gt; not the + at the start of your line of code. If you see the +, just hit the Escape key to get back to the prompt &gt; and then go back to your code. 1.8 Summary This covers the main introductory elements of R and means you should be able to run the code in the exercises. "],["data-wrangling-comparative-data-in-r.html", "Chapter 2 Data wrangling comparative data in R Before you start 2.1 Chameleon data 2.2 Summary 2.3 Practical exercise", " Chapter 2 Data wrangling comparative data in R In the Primer, we took some data on chameleons and manipulated/wrangled it so it was ready for analyses. In this exercise we will show you how we did this in R. We use functions from a collection of packages called the tidyverse - these are amazing for data manipulation etc. It’s beyond the scope of this Primer to cover these in detail, but we will show you what we did to get the tidied dataset in the book. Before you start Open the 02-DataWrangling.RProj file in the 02-DataWrangling folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data measurements - to convert inches to cm 2.1 Chameleon data Let’s imagine we have the following three sources of chameleon body length and life history data. SOURCE 1: Picard et al. 2020. Chamaeleo chamaeleon. 245 mm, 80 eggs, sexually dimorphic. Brookesia minima. 33 mm, 2 eggs, sexually dimorphic. Calumma parsonii. 650 mm, 50 eggs, sexually dimorphic. SOURCE 2: Janeway et al. 1995. Chamaeleo chamaeleon. Up to 250 cm, Up to 100 eggs. Brookesia minima. Up to 34 mm, 2 eggs. Calumma parsonii. Up to 695 mm, Up to 50 eggs. SOURCE 3: Kirk et al. 1966. Chamaeleo chamaeleon. Approximately 10 inches. Brookesia minima. Approximately 1 inch. Calumma parsonii. Approximately 24 inches. We would tend to record these data in a table (probably in Excel or another spreadsheet program). Here we have saved this file as chameleon-data-raw.csv We would also record the full reference for each source in a separate table. Recording the data like this makes it easy to enter in Excel, and also makes it easy for us to exclude certain types of data or sources should we decide we don’t trust them enough to include in our analyses. Note that this will not be the ideal format for using the data in R, so you will need to manipulate or wrangle the data first to make it tidy. In R, the tidyr and dplyr packages are useful for doing this. Or you could use something like Excel if you are less confident with R. Make sure to keep the raw data too in case you accidentally introduce any errors, and so that you can repeat the data collection and analyses if needed. Both dplyr and tidyr packages are part of the tidyverse so we can save some time by loading them both at the same time via library(tidyverse) # Load packages library(tidyverse) Next we need to read in the chameleon data from our folder. This is saved in the file chameleon-data-raw.csv so we can read it in using read_csv as usual. # Read in the data chameleon &lt;- read_csv(&quot;data/chameleon-data-raw.csv&quot;) ## Rows: 18 Columns: 8 ## ── Column specification ────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (6): Species, Measurement, Type, Units, Quality, Source ## dbl (1): Value ## lgl (1): Approx ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. When we read in data we get output that tells us how R has interpreted each column. Here it thinks Species is a character (i.e. words), whereas Value is col_double which means it’s a number with decimal places. These all look right to me, but if something looks off here (i.e. characters where you were expecting numbers) it’s worth checking your data to make sure you haven’t made any errors. To save having lots of non-needed output I often suppress these messages in this book, though they’ll pop up if you run the code yourself. # Take a look at it glimpse(chameleon) ## Rows: 18 ## Columns: 8 ## $ Species &lt;chr&gt; &quot;Chamaeleo chamaeleon&quot;, &quot;Chamaeleo chamaeleon&quot;, &quot;Chamaeleo chamaeleon&quot;, … ## $ Measurement &lt;chr&gt; &quot;length&quot;, &quot;clutch size&quot;, &quot;dimorphic&quot;, &quot;length&quot;, &quot;clutch size&quot;, &quot;dimorphi… ## $ Value &lt;dbl&gt; 245, 80, 1, 33, 2, 1, 650, 50, 1, 250, 100, 34, 2, 695, 50, 10, 1, 24 ## $ Type &lt;chr&gt; &quot;mean&quot;, &quot;mean&quot;, &quot;truefalse&quot;, &quot;mean&quot;, &quot;mean&quot;, &quot;truefalse&quot;, &quot;mean&quot;, &quot;mean&quot;… ## $ Units &lt;chr&gt; &quot;mm&quot;, &quot;eggs&quot;, NA, &quot;mm&quot;, &quot;eggs&quot;, NA, &quot;mm&quot;, &quot;eggs&quot;, NA, &quot;mm&quot;, &quot;eggs&quot;, &quot;mm&quot;… ## $ Quality &lt;chr&gt; &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, &quot;high&quot;, … ## $ Approx &lt;lgl&gt; FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FA… ## $ Source &lt;chr&gt; &quot;Picard et al 2020&quot;, &quot;Picard et al 2021&quot;, &quot;Picard et al 2022&quot;, &quot;Picard e… To wrangle this data, we would first convert the units to a standard unit for each measurement. Here we have length in mm and inches, so we would convert the inches into mm. The three altered rows are shown below. Note that converting from inches to mm gives us the false impression of precision, i.e. two values are now 25.4 and 609.6, rather than whole numbers making it look like these were measured accurately rather than approximated. It’s worth looking out for this in other data, especially curated databases where this kind of conversion is typical. We can do this easily using the function conv_unit in the package measurements. Let’s load the library here so we can do this. # Load packages library(measurements) Now let’s use conv_unit and some dplyr functions to convert all inches to mm. # Create a new dataset called chameleon2 chameleon2 &lt;- # Start with the chameleon data chameleon %&gt;% # Convert inches into mm within the Value column mutate(Value = ifelse(Units == &quot;inches&quot;, conv_unit(Value, &quot;inch&quot;, &quot;mm&quot;), Value)) %&gt;% # Remove Units and Source columns dplyr::select(-Units, -Source) Here mutate modifies the variable Value. The ifelse statement tells R that if Units is in inches, we should use conv_unit to convert from inch to mm, and place this value in the Value column. If Units is not in inches it just records the original value in Value. Finally, select is used to remove the Units and Source columns. These are important to keep in our raw data, but we don’t need them for our analyses, so it’s neater to remove them. The observant among you may have noticed I used dplyr::select not just select in the code above. This tells R to look in the package dplyr and use the select function from that package. There are several different packages with select functions, and I use another one later in this book. To ensure that R knows to use the dplyr version here I have used the ::. # Just show the last three entries to check what we have done looks correct tail(chameleon2, n = 3) ## # A tibble: 3 × 6 ## Species Measurement Value Type Quality Approx ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; ## 1 Chamaeleo chamaeleon length 254 mean medium TRUE ## 2 Brookesia minima length 25.4 mean medium TRUE ## 3 Calumma parsonii length 610. mean medium TRUE Next we might decide to exclude low quality records, and remove any approximations. We might need to do something more complicated if we only have one record for a species and it is an approximation. In this case we are going to keep the approximations, and use all the data. But you should choose what is sensible for your dataset. To make our data tidier and remove unnecessary columns we will use select again to remove the Data_Quality and Approximation columns. # Create a new dataset called chameleon3 chameleon3 &lt;- # Start with chameleon2 chameleon2 %&gt;% # Remove the Data Quality and Approximation columns dplyr::select(-Quality, -Approx) # Look at the data head(chameleon3) ## # A tibble: 6 × 4 ## Species Measurement Value Type ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Chamaeleo chamaeleon length 245 mean ## 2 Chamaeleo chamaeleon clutch size 80 mean ## 3 Chamaeleo chamaeleon dimorphic NA truefalse ## 4 Brookesia minima length 33 mean ## 5 Brookesia minima clutch size 2 mean ## 6 Brookesia minima dimorphic NA truefalse Finally, we want to summarise the data for each species, to get means/medians and possibly also minima and maxima. To summarise we use the function summarise (or summarize if you prefer the US spelling). But first we need to group the data into the groupings we want the summary data for. In this case we want to know the median values for each species, for each different measurement, and for each different type of measurement, i.e. averages, maximums, minimums etc. We can tell R to group data using group_by. To do all of this we use the following code: # Create a new dataset called chameleon4 chameleon4 &lt;- # Start with chameleon3 chameleon3 %&gt;% # Group the records together by Species, Measurement, and Data_Type group_by(Species, Measurement, Type) %&gt;% # Get the median and max for Value in each group constructed by Species, Measurement, and Data_Type. summarise(median = median(Value), max = max(Value)) # Look at the output head(chameleon4) ## # A tibble: 6 × 5 ## # Groups: Species, Measurement [4] ## Species Measurement Type median max ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Brookesia minima clutch size max 2 2 ## 2 Brookesia minima clutch size mean 2 2 ## 3 Brookesia minima dimorphic truefalse NA NA ## 4 Brookesia minima length max 34 34 ## 5 Brookesia minima length mean 29.2 33 ## 6 Calumma parsonii clutch size max 50 50 Note that we now have a median and maximum value, for each measurement and data type for each species. This is fine, but to run analyses in R we are going to want a different column for each of the measurement x data type combinations. To do this we can use the function pivot_wider, because the change will make the table wider… # Create a new dataset called chameleon5 chameleon5 &lt;- # Start with chameleon4 chameleon4 %&gt;% # Reshape the data so measurement X data types combinations are their own columns pivot_wider(names_from = c(Measurement, Type), values_from = c(median, max)) # Look at the output chameleon5 ## # A tibble: 3 × 11 ## # Groups: Species [3] ## Species media…¹ media…² media…³ media…⁴ media…⁵ max_c…⁶ max_c…⁷ max_d…⁸ max_l…⁹ max_l…˟ ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Brookesia m… 2 2 NA 34 29.2 2 2 NA 34 33 ## 2 Calumma par… 50 50 NA 695 630. 50 50 NA 695 650 ## 3 Chamaeleo c… 100 80 NA 250 250. 100 80 NA 250 254 ## # … with abbreviated variable names ¹​`median_clutch size_max`, ²​`median_clutch size_mean`, ## # ³​median_dimorphic_truefalse, ⁴​median_length_max, ⁵​median_length_mean, ## # ⁶​`max_clutch size_max`, ⁷​`max_clutch size_mean`, ⁸​max_dimorphic_truefalse, ## # ⁹​max_length_max, ˟​max_length_mean Finally, we probably don’t need all of these columns. The summary data you use and how you calculate it will vary depending on your inputs for example here we might want to extract: Median of mean length values. This will tell us about the overall mean value for length across all sources. Maximum of maximum length values. This will tell us about the overall maximum value for length across all sources. Median of mean clutch size values. This will tell us about the overall mean value for clutch size across all sources. Maximum of maximum clutch size values. This will tell us about the overall maximum value for clutch size across all sources. Median dimorphism score. This will tell use whether the species is predominantly considered to be dimorphic or not. We can select these columns only using select: # Create a new dataset called chameleon6 chameleon6 &lt;- # Start with chameleon5 chameleon5 %&gt;% # Select only the required columns dplyr::select(Species, median_length = median_length_mean, max_length = max_length_max, median_clutchsize = `median_clutch size_mean`, max_clutchsize = `max_clutch size_max`, dimorphic = median_dimorphic_truefalse) # Look at the output chameleon6 ## # A tibble: 3 × 6 ## # Groups: Species [3] ## Species median_length max_length median_clutchsize max_clutchsize dimorphic ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Brookesia minima 29.2 34 2 2 NA ## 2 Calumma parsonii 630. 695 50 50 NA ## 3 Chamaeleo chamaeleon 250. 250 80 100 NA Finally if this were a real dataset, we might want to save this clean and tidy version so that we don’t have to run all of this code again every time we want to use it. We can do this using the function write_csv: write_csv(x = chameleon6, file = &quot;data/chameleon-data-for-analyses.csv&quot;) Note that, to demonstrate how the code works we’ve separated it into chunks above, but you could use %&gt;% to do all of these in one go if you wanted to: chameleon_final &lt;- # Start with chameleon chameleon %&gt;% # Convert inches into mm within the Value column mutate(Value = ifelse(Units == &quot;inches&quot;, conv_unit(Value, &quot;inch&quot;, &quot;mm&quot;), Value)) %&gt;% # Remove the Units, Source, Data Quality and Approximation columns dplyr::select(-Units, -Source, -Quality, -Approx) %&gt;% # Group the records together by Species, Measurement, and Data_Type group_by(Species, Measurement, Type) %&gt;% # Get the median and max for Value in each group constructed by Species, Measurement, and Data_Type. summarise(median = median(Value), max = max(Value)) %&gt;% # Reshape the data so measurement X data types combinations are their own columns pivot_wider(names_from = c(Measurement, Type), values_from = c(median, max)) %&gt;% # Select only the required columns dplyr::select(Species, median_length = median_length_mean, max_length = max_length_max, median_clutchsize = `median_clutch size_mean`, max_clutchsize = `max_clutch size_max`, dimorphic = median_dimorphic_truefalse) # Look at the output chameleon_final ## # A tibble: 3 × 6 ## # Groups: Species [3] ## Species median_length max_length median_clutchsize max_clutchsize dimorphic ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Brookesia minima 29.2 34 2 2 NA ## 2 Calumma parsonii 630. 695 50 50 NA ## 3 Chamaeleo chamaeleon 250. 250 80 100 NA # Write to file # I&#39;ve commented this out as we already made this above # write_csv(x = chameleon_final, file = &quot;data/chameleon-data-for-analyses.csv&quot;) 2.2 Summary This exercise should have introduced you to some basic skills for wrangling comparative data in R. 2.3 Practical exercise Using the frog-eyes-raw-data.csv dataset and R, create a new dataset that contains only the columns genus_species, Family, and two new columns containing the species mean values for rootmass and eyemean. We will talk more about this dataset in later exercises, but it comes from K. N. Thomas et al. (2020). References "],["understanding-plotting-and-manipulating-phylogenies-in-r.html", "Chapter 3 Understanding, plotting and manipulating phylogenies in R Before you start 3.1 What do phylogeny files look like? 3.2 How are phylogenies formatted in R? 3.3 Plotting phylogenies 3.4 Phylogeny manipulation 3.5 Summary 3.6 Practical exercise", " Chapter 3 Understanding, plotting and manipulating phylogenies in R Using phylogenies in R can feel daunting at first, even if you’re already familiar with R. Luckily, lots of nice R packages exist to help us work with them, and fairly new packages like ggtree mean we can now make beautiful phylogeny plots without needing to resort to other software. In this chapter I’ll introduce you to how R stores phylogenies, and then show you how to plot them and manipulate them before using them in your PCMs. Most of the examples come from the Primer. Before you start Open the 03-Phylogenies.RProj file in the 03-Phylogenies folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data ape - functions for reading, plotting and manipulating phylogenies ggtree - for plotting trees patchwork - to plot multi-panel plots ggimage - to add images to plots phytools - to add species to phylogenies 3.1 What do phylogeny files look like? There are many different formats that you might get a phylogeny in, but the most common formats of the tree files we read into R are Newick and NEXUS. Here we will just focus on these two. If you need to read in lots of different kinds of tree files check out the documentation for ggtree. 3.1.1 Newick trees Newick (or New Hampshire) format uses brackets/parentheses to group taxa together with their closest relatives. Tips are represented by their names, and these names can include any characters except blanks, colons, semicolons, parentheses, and square brackets. Because blanks are not allowed, we use underscores to replace them, meaning that in many phylogenies the tip names are formatted as Genus_species. Our basic tree from the Primer is shown below. The topology of this tree can be represented in Newick format as: (((robin,deer),spider),jellyfish); Note that Newick trees always end with a semicolon. Branch lengths can be added into a tree by adding a colon followed by the branch length after the node. This represents the length of the branch immediately following that node, so numbers after a tip label show how long the branches at the tips of the tree are, and others show how long the internal branches are. For our tree above this can be written as: (((robin:4.2,deer:4.2):3.1,spider:7.3):6.3,jellyfish:13.5); And that is basically all there is to Newick trees! In R these can be read in using read.tree from the APE package. They are usually stored in .tre or .phy files. 3.1.2 NEXUS trees NEXUS files are a little more complicated, but are also based on the Newick format. Many tree inference packages will output trees as NEXUS files, so they are very commonly used in R. You read them in using read.nexus from the APE package, and they are usually stored in .nex files. A NEXUS file for the tree above might look like the example below. First it uses the #NEXUS tag to tell the computer it is a NEXUS file, then the first block lists how many taxa there are (NTAX) and then what the names of the taxa are (TAXLABELS), i.e. the tip labels. Then the second block first gives each taxon a number, then the TREE block shows the tree in Newick format, exactly as we did above except using the numbers for the taxa rather than their names. The UNTITLED = [&amp;R] part just means we haven’t given the tree a name, and that the tree is rooted. #NEXUS BEGIN TAXA; DIMENSIONS NTAX = 4; TAXLABELS robin deer spider jellyfish ; END; BEGIN TREES; TRANSLATE 1 robin, 2 deer, 3 spider, 4 jellyfish ; TREE * UNTITLED = [&amp;R] (((1:4.2,2:4.2):3.1,3:7.3):6.3,4:13.5); END; NEXUS files can be much more complex and include the data used to infer the tree too, but we don’t need this for comparative analyses so read.nexus will just ignore it. Sometimes someone will email you a .tre or .nex file, or you’ll download one from the internet, but when you use read.tre or read.nexus it just keeps giving you an error. Before panicking, check what you did after you downloaded the tree file. Did you open it to take a look? On some computers, doing this makes the computer freak out because it doesn’t know what to do with .tre or .nex files, so it converts them into something it does understand like .txt or .docx. This then alters the tree file to the point that R can no longer read it. To solve the problem, just download the file again but this time don’t open it!. Just save it and then read it into R. If you need to look at one of these files outside of R, try “Open with” and pick a text editor like Notepad or TextEdit. This shouldn’t alter the file. 3.2 How are phylogenies formatted in R? You don’t need to know how phylogenies are represented in R to use them, but it helps to have a bit of an idea what is going on. To load a tree into R you need either the function read.tree or read.nexus from the package APE. read.tree can deal with a number of different types of data (including DNA) whereas read.nexus reads NEXUS files. Let’s practice with our basic tree from the Primer. We can read it in using read.tree. Remember to load the APE library first or this won’t work. # Load ape library(ape) # Read in the tree tree &lt;- read.tree(&quot;data/basic.tre&quot;) Note that whether we read the tree in using read.tree or read.nexus the resulting tree in R is the same. To understand what is going on we need a bit of computer programming jargon. Phylogenies are stored as objects of class phylo. What do I mean by this? Whenever we make a new “thing” in R and save it with a name we have created an object. So the code tree &lt;- read.tree(\"data/basic.tre\") above makes a new object called tree which will have the phylogeny stored in it. Each object in R belongs to a class, which is a sort of blueprint for how the object should behave. For example, objects of numeric class will behave differently to objects of character class - we can’t multiply two characters (i.e. words) together but we can multiply two numbers. There are many classes in R and each have different rules. The phylo class is one of these that we use for phylogenies. Let’s examine the tree by typing: # Look at the tree summary tree ## ## Phylogenetic tree with 4 tips and 3 internal nodes. ## ## Tip labels: ## robin, deer, spider, jellyfish ## ## Rooted; includes branch lengths. Notice that when we print out a phylo object like tree, it doesn’t just give us all of the information in the tree file. Instead it gives us a couple of bits of summary information. It tells us how many tips (4) and internal nodes (3) the tree has, then lists the tip labels. It also tells us the tree is rooted and contains branch lengths. If we want to look more closely at the components that make up a phylo object we need to look at the structure of tree using str. # Look at the summary of tree components str(tree) ## List of 4 ## $ edge : int [1:6, 1:2] 5 6 7 7 6 5 6 7 1 2 ... ## $ edge.length: num [1:6] 6.3 3.1 4.2 4.2 7.3 13.5 ## $ Nnode : int 3 ## $ tip.label : chr [1:4] &quot;robin&quot; &quot;deer&quot; &quot;spider&quot; &quot;jellyfish&quot; ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; This gives us a bit more information about what is going on. tree contains four variables: edge shows how the branches and tips are linked together (I’ll show you how this works below). edge.length gives the branch lengths. Nnode tells you how many internal nodes there are. tip.label is a list of the taxon names. If we want to see the whole of the phylo object we have to use a little trick. Everything we do to tree at the moment will work based on tree being a phylo object. If we want to see the whole thing, we need to tell R to ignore that, and present it as is. To do this we can use unclass to remove the class rules. # Look at the tree as is unclass(tree) ## $edge ## [,1] [,2] ## [1,] 5 6 ## [2,] 6 7 ## [3,] 7 1 ## [4,] 7 2 ## [5,] 6 3 ## [6,] 5 4 ## ## $edge.length ## [1] 6.3 3.1 4.2 4.2 7.3 13.5 ## ## $Nnode ## [1] 3 ## ## $tip.label ## [1] &quot;robin&quot; &quot;deer&quot; &quot;spider&quot; &quot;jellyfish&quot; ## ## attr(,&quot;order&quot;) ## [1] &quot;cladewise&quot; If we only wanted to see the full edge component we can use the $ to extract just that variable from tree: # Just look at the edge variable tree$edge ## [,1] [,2] ## [1,] 5 6 ## [2,] 6 7 ## [3,] 7 1 ## [4,] 7 2 ## [5,] 6 3 ## [6,] 5 4 What is going on here? The easiest way to understand is to look at the edge matrix and the tree with node numbers added to it (see below). For all trees, 1 is the number of the first tip taxon at the base of the phylogeny, 2 is the number of the second taxon and so on until you have each taxon numbered. The numbers then refer to nodes, working through the tree from the root forwards. So in the edge matrix above, 1, 2, 3 and 4 are the tips. Node 7 leads to tips 1 and 2. Node 6 leads to node 7, and tip 3. Node 5 leads to node 6 and tip 4. Node 5 is the root node. Notice that the edge.length variable is in the same order as edge. So the first row of edge shows a branch joining node 5 to node 6, and this has a branch length of 6.3 (the first entry in edge.length). And so on… tree$edge ## [,1] [,2] ## [1,] 5 6 ## [2,] 6 7 ## [3,] 7 1 ## [4,] 7 2 ## [5,] 6 3 ## [6,] 5 4 tree$edge.length ## [1] 6.3 3.1 4.2 4.2 7.3 13.5 As I said above, you don’t need to fully understand this, so don’t worry if this is confusing. But you will see at various points we do things like tree$tip.label to extract or change tip labels, and we might set branch lengths using tree$edge.length somewhere in our code. So now you understand where those bits of information come from. 3.3 Plotting phylogenies Regardless of what you’re using a phylogeny for, you’re likely to want to plot it at some point. Even if you don’t need a plot straight away, I highly advise plotting your phylogeny before you do anything else. It’s good practice to look at whatever data you read into R to check it, and plotting helps you check it looks correct. Most phylogeny plotting in R uses the package ape. Recently, however, a new package called ggtree has been introduced that builds on the popular ggplot2 method of plotting in R, and is much more flexible than ape. This leaves us in a bit of a quandary - which should you use? And which should I teach you?! I think there is a benefit in learning the basics of both approaches. In my own work, I use ape to plot trees I am working with to quickly check what is going on. I also use ape plotting indirectly in other packages like phytools - see later exercises. When I need to produce a pretty or complex tree I’ll often use ggtree instead. The exercises here will mirror this. The aim is not to give you a thorough introduction to all the things we can do with plotting phlyogenies in R, but more to give a taster of what is possible, and what we will need for the later exercises. 3.3.1 Basic phylogeny plotting with APE Our basic tree is a bit small, so let’s use some data that is built into R with a phlyogeny of bird orders. First load the data. This will read in a tree called bird.orders. # Load the data from R data(bird.orders) Now plot the tree. # Plot the tree plot(bird.orders) Note that the function we use to plot phylogenies in ape is just called plot, but R knows to plot a phylogeny not anything else. How does this work? plot is one of a set of clever functions in R that uses an ifelse statement to decide what kind of plot it should do. When you ask R to plot something, it first determines what class of object it is. It then chooses the correct version of plot for that class. In this case the function it is actually using to plot the phylogeny is plot.phylo. This is important if you want to look at the help file for plotting phylogenies, because you need to use ?plot.phylo not ?plot. # Access the help file for phylogeny plotting # This should open a help file in another window of RStudio ?plot.phylo You should see from the help file that there are lots of options for plotting trees. For example if we want to use a fan-shaped tree, with smaller tip labels, and no white space round the edges to make the tree fill the plotting area, we can use: # Plot the tree as a circular/fan phylogeny with small labels plot(bird.orders, cex = 0.6, type = &quot;fan&quot;, no.margin = TRUE) You can change the style of the tree (type), the color of the branches and tips (edge.color, tip.color), and the size of the tip labels (cex). Here’s an fun/hideous example! plot(bird.orders, edge.color = &quot;deeppink&quot;, tip.color = &quot;springgreen&quot;, no.margin = TRUE) We can also add information about the traits of species to trees. We will come back to this when we cover models of evolution, but as a quick demonstration, let’s imagine we want to display some data on our bird tree. For example, let’s code these bird orders based on how much I like them (this is clearly a total lie because I love them all equally, but for the sake of an example I’m willing to pretend!). # Make a factor which contains how much I like each order myfaves &lt;- factor(c(&quot;awesome&quot;, &quot;cool&quot;, &quot;ok&quot;, &quot;awesome&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;awesome&quot;, &quot;cool&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;cool&quot;, &quot;cool&quot;, &quot;awesome&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;cool&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;ok&quot;, &quot;cool&quot;, &quot;ok&quot;)) Now we can plot this on a phylogeny. First we decide which colours we’d like and make a list of these. To look at a list of inbuilt colours in R type in colors(). You can also use any hex colour coded as e.g. “#000000” instead of “white”. The first colour will be the first category alphabetically, the second will be the second category alphabetically, and so on. mycolours &lt;- c(&quot;gold&quot;, &quot;cornflowerblue&quot;, &quot;cyan4&quot;) Now plot the tree and add square labels to the tips showing the categories. We use label.offset = 1 to move the labels to the right a bit so the squares will fit. I’ve also added a legend. # Plot the tree plot(bird.orders, label.offset = 1, cex = 0.9, no.margin = TRUE) # Add the squares at the tip labels. tiplabels(pch = 22, bg = mycolours[as.numeric(myfaves)], cex = 1.2, adj = 1) # Add a legend legend(&quot;topleft&quot;, fill = mycolours, legend = c(&quot;Awesome&quot;, &quot;Cool&quot;, &quot;OK&quot;), bty = &quot;n&quot;) pch = 22 sets the tip labels to be unfilled squares, bg (background) defines the colours of the squares using the list of colours we provided, and sorting them based on what the value for that order was for myfaves. cex = 1.2 increases the point size, and adj = 1 moves the tip labels sideways a bit so they don’t obscure the ends of the branches. 3.3.2 Basic phylogeny plotting with ggtree I won’t go into a huge amount of detail about ggtree because the manual for ggtree is really comprehensive, and for the most part you won’t need to know how to do most of the things it can do. Instead I’ll give a basic introduction, and then show you how to make some of the plots used in Chapter 2 of the Primer. I will also provide the code used to build figures in the Primer where appropriate in later exercises. 3.3.2.1 A quick intro to ggplot2 ggtree extends the ggplot2 package to work with phylogenies. What’s ggplot2? The ggplot2 package was developed by Hadley Wickham to implement some of the ideas in a book called “The Grammar of Graphics” by Wilkinson (2005), hence the gg bit of the name. Many books and online tutorials cover ggplot2 in detail, so here I’ll just cover the basics you need to understand how ggtree works. See https://ggplot2-book.org/ for details. ggplot2 works on the basis of layers. You start off with a line of code that uses the function ggplot, then at the end of the line you add a +. On the next line you add a layer. This layer might tell R what kind of plot to make, what the axes should be, how to draw the legend etc. You keep adding layers until you get the plot that you want. Each layer can have six components, but we’ll just focus on the main three: The data. Every layer needs some data, in the form of a dataframe (or tibble). Each layer can be associated with a different dataset if appropriate. A geometric object, called a ‘geom’. geoms refer to the things we can see on a plot, such as points, lines or bars. A set of aesthetic mappings. These describe how variables in the data are associated with the aesthetic properties of the layer. This can include what to use as x and y axes, and the colour and size of the objects (e.g. points) on a plot. Each layer can be associated with its own unique aesthetic mappings. Aesthetic mappings are always defined inside the aes function. Different geoms will need different sets of aesthetic mappings, for example to draw a scatter plot you need to define the x and y axes, but for a histogram you only need the x axis. Each layer will also have layer specific parameters. These are the features of a layer, for example in geom_point, the geom that makes points on a graph, one layer specific parameter is colour = which defines the colour of the data points. Let’s quickly demonstrate this using some fake data - read in the code below to create a monster dataset. # Make some fake data monsterdata &lt;- data.frame(monster = c(&quot;vampire&quot;, &quot;golem&quot;, &quot;cookie-monster&quot;, &quot;manticore&quot;, &quot;wererat&quot;), type = c(&quot;dead&quot;, &quot;dead&quot;, &quot;alive&quot;, &quot;dead&quot;, &quot;alive&quot;), scariness = c(65, 50, 10, 75, 95)) To make a really basic plot… ggplot(data = monsterdata, aes(x = monster, y = scariness)) + geom_point(colour = &quot;deeppink&quot;, size = 4) + theme_bw() + ylim(0, 100) A couple of points to note: In ggplot2, theme is used to define the overall look of the plot. We can use the theme function modify everything individually, but there are some built in themes that do lots of things at once. theme_bw is one of my favourites as it gets rid of the horrible grey background that is a ggplot2 default, but keeps the nice background grid. I also used ylim to change the y axis limits to go from 0 to 100. Another thing I’m going to do below with ggtree is plot multiple plots on one plotting space. There are a couple of ways to do this, but the easiest is to use the package patchwork. First we need to assign our plots to an object using &lt;-. We do this as follows myplot1 &lt;- ggplot(data = monsterdata, aes(x = monster, y = scariness)) + geom_point(colour = &quot;deeppink&quot;, size = 4) + theme_bw() + ylim(0, 100) myplot2 &lt;- ggplot(data = monsterdata, aes(x = monster, y = scariness)) + geom_point(colour = &quot;gold1&quot;, size = 4, shape = &quot;triangle&quot;) + theme_bw() + ylim(0, 100) To look at the plots we would now have to type myplot1 or myplot2 into R, but I haven’t done this here because we already looked at the first plot above, and all I changed in the second plot was the colour and shape of the points. With patchwork, we can use + to plot things next to each other, or / to plot things on top of one another, and () to do more complex arrangements. See https://patchwork.data-imaginist.com/articles/patchwork.html for details. Here let’s just plot them next to each other… library(patchwork) myplot1 + myplot2 myplot1 / (myplot1 + myplot2) Below you’ll see I use the ggplot2 layer labs to add labels (i.e. A, B, C) to plots in multi-panel figures. We can also angle the x axis labels so they fit, add trend lines etc. But I’ll let you find out how to do that for yourselves! 3.3.3 Back to ggtree OK that should give you the basics of what to expect from ggplot2. Now let’s use ggtree… To plot a phylogeny using ggtree we always start with the ggtree function (not ggplot). We then add layers using the + like in ggplot2. Some layers are the same (e.g. xlim, ylim), others are unique to ggtree (e.g. geom_tiplab). ggtree also has an inbuilt theme for trees called theme_tree. To plot the basic phylogeny we’ve been practising with we use: library(ggtree) ggtree(tree) + # Add theme for trees theme_tree() + # Change x and y limits so the tip labels fit xlim(0, 22) + ylim(0, 5) + # Add tip labels as text, slightly offset from the tips and aligned geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) Note that you might need to fiddle around with the xlim and ylim a bit to make sure your phylogeny and the tip labels fit. If we don’t specify the limits, the tip labels often fall off the plotting window (see below), and the tree will push right up against the top and bottom of the page making it hard to add things like images to the tips. # Demonstration of what happens if you don&#39;t define the x and y limits ggtree(tree) + theme_tree() + geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) ggtree is clearly a bit more involved than just using plot.phylo with ape. If you’re happy with plotting in ape you don’t need to use ggtree. As I mentioned above, for day-to-day tree viewing and checking I just tend to use ape, so don’t worry if this is all incomprehensible. One thing, among many, that ggtree is great for is adding images to the tips rather than species names. To do this you need to collate the images you want to use first. You may want to draw your own, or I often download them from the excellent PhyloPic website (these are free to use but don’t forget to record who made the image so you can credit them in your papers/talks). To keep my folder tidy I keep images in a separate subfolder called, predictably, images. You need the package ggimage installed for this to work, which for me took some time and also required that I install ggplotify, magick, and gridGraphics. If this is a struggle, then just skip this example. # Plot with images at tips ggtree(tree) + theme_tree() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip label pictures geom_tiplab(aes(image = c(&quot;images/deer.png&quot;, &quot;images/robin.png&quot;, &quot;images/spider.png&quot;, &quot;images/jellyfish.png&quot;, rep(NA, 3))), geom = &quot;image&quot;, align = TRUE, offset = 0.5, linetype = NA, size = c(0.12, 0.15, 0.09, 0.15)) Note that to add either text or images to the tips we use the same layer function, geom_tiplab. If doing this with your own data you’ll likely need to fiddle with the sizes of the images to get them looking right. Some of you may be wondering what the rep(NA, 3) bit of the code above does. When we try to add images to the tips, the function also tries to add images to the internal nodes. We don’t want these to have images so we just ask ggtree to use NA, i.e. don’t add an image. rep(NA, 3) means replicate NA three times (for the three internal nodes). Again you’ll probably need to modify this number when you do this for your own data. As with plot.phylo we can plot phylogenies in different ways, see code below. Fan trees are called circular trees. Note the different values for offset and hjust (horizontal justification) I’ve used here to make the labels fit. Again you will need to fiddle with these numbers to get this to work for your data. # Standard tree p1 &lt;- ggtree(tree) + theme_tree() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) + labs(tag = &quot;A&quot;, size = 2) # Standard tree facing up p2 &lt;- ggtree(tree) + theme_tree() + coord_flip() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 2, hjust = 0.5, linetype = NA) + labs(tag = &quot;B&quot;, size = 2) # Slanted tree p3 &lt;- ggtree(tree, layout = &quot;slanted&quot;) + theme_tree() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) + labs(tag = &quot;C&quot;, size = 2) # Fan/circular tree p4 &lt;- ggtree(tree, layout = &quot;circular&quot;) + theme_tree() + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 5, hjust = 0.5, linetype = NA, size = 3) + labs(tag = &quot;D&quot;, size = 2) # Plot (p1 + p2) / (p3 + p4) What about highlighting clades? We can use geom_hilight to add coloured shading to all species from a defined node, and/or geom_cladelabel to label clades (A and B below) from a defined node. The offset in geom_cladelabel defines how far from the phylogeny tips the lines should be drawn. Again, you’ll need to play with this to get the best figure possible. # Plot with images at tips ggtree(tree) + theme_tree() + # Change limits so labels fit xlim(0, 22) + ylim(0, 5) + # Add tip label pictures geom_tiplab(aes(image = c(&quot;images/deer.png&quot;, &quot;images/robin.png&quot;, &quot;images/spider.png&quot;, &quot;images/jellyfish.png&quot;, rep(NA, 3))), geom = &quot;image&quot;, align = TRUE, offset = 0.5, linetype = NA, size = c(.12, .15, .09, .15)) + # Highlight clades geom_hilight(node = 6, fill = &quot;cornflowerblue&quot;, alpha = 0.4) + geom_hilight(node = 7, fill = &quot;springgreen&quot;, alpha = 0.4) + geom_cladelabel(node = 7 , label = &quot;A&quot;, offset = 4, fontsize = 5) + geom_cladelabel(node = 6 , label = &quot;B&quot;, offset = 6, fontsize = 5) You can also highlight non-monophyletic groups using groupOTU. Here’s a quick and silly example… # Define group feathers &lt;- list(no = c(&quot;deer&quot;,&quot;jellyfish&quot;, &quot;spider&quot;), yes = c(&quot;robin&quot;)) # Plot with images at tips p &lt;- ggtree(tree) + theme_tree() + # Change limits so labels fit xlim(0, 25) + ylim(0, 5) + # Add tip labels geom_tiplab(geom = &quot;text&quot;, align = TRUE, offset = 0.5, linetype = NA) # Add colours to branches and labels groupOTU(p, feathers, &#39;feathers&#39;) + aes(color = feathers) + scale_colour_manual(values = c(&quot;orange1&quot;,&quot;darkblue&quot;)) + theme(legend.position = &quot;top&quot;) There are many more things you can do with ggtree, all based on this idea of adding layers. See the manual for ggtree at http://yulab-smu.top/treedata-book/index.html for more details. 3.4 Phylogeny manipulation To run analyses in R we often need to manipulate our phylogeny in some way so that the analyses can work. I’ll mention these requirements where needed, but here are some common things we might need to change. I’ll use the bird.orders phylogeny again as it’s a manageable size. # Load the tree data(bird.orders) 3.4.1 Removing polytomies Most R functions require your tree to be dichotomous, i.e. to have no polytomies. To check whether your tree is dichotomous use is.binary. # Check whether the tree is binary # We want this to be TRUE is.binary(bird.orders) ## [1] TRUE If this is FALSE, use multi2di to make the tree dichotomous. This function works by randomly resolving polytomies with zero-length branches. This doesn’t change the tree overall, it’s just a clever trick to get the functions to work. # Make the tree into a binary tree bird.orders &lt;- multi2di(bird.orders) 3.4.2 Rooting your phylogeny Most R functions also require the tree to be rooted, i.e., to have one (or more) taxon designated as the outgroup. We can check whether the tree is rooted as follows. # Check whether the tree is rooted # We want this to be TRUE is.rooted(bird.orders) ## [1] TRUE Our tree is rooted but if you wanted to change the root, or root an unrooted tree use root. We can make a new tree and root it on something silly (e.g. Passeriformes) to demonstrate. Remember that your root should be the outgroup from the phylogenetic inference. Rooting a tree incorrectly can cause big issues with downstream analyses, so make sure you choose carefully. new.tree &lt;- root(bird.orders, outgroup = &quot;Passeriformes&quot;) plot(new.tree) 3.4.3 Manipulating the species in your phlyogeny When we do comparative analyses, we have data and a tree to deal with. It’s very common to have species in your data that are not in your tree and vice versa. In the next exercise I’m going to show you how to match up the species in your comparative data with the species in your phylogeny. But you may also want to make these changes for plotting purposes, so it is useful to know how to do them anyway. 3.4.3.1 Renaming species We can change the names of species using gsub which stands for generalised substitution. This can help with typos etc. or if you have minor taxonomic changes to make. Here, for fun let’s rename Passeriformes… bird.orders$tip.label &lt;- gsub(&quot;Passeriformes&quot;, &quot;birbs&quot;, bird.orders$tip.label) plot(bird.orders) 3.4.3.2 Removing species Removing species uses the function drop.tip. If we want to remove birbs from the tree above.. bird.orders &lt;- drop.tip(bird.orders, tip = &quot;birbs&quot;) plot(bird.orders) You can also remove multiple tips at once… bird.orders &lt;- drop.tip(bird.orders, tip = c(&quot;Struthioniformes&quot;, &quot;Tinamiformes&quot;)) plot(bird.orders) However, if you’re looking to do something more complex like removing entire groups it’s probably easier to use the functions in the next exercise. 3.4.3.3 Adding species Sometimes you’ll find your phylogeny is missing some species that you have in your dataset. In general the easiest thing is just to omit those species from your analysis, but it may be that they’re data points you really want to keep. In which case you can add species to the tree. Before you can add the species you need to find out where in the tree the species belongs. This will require looking in the literature to find the closest relative of the species that already exists in the tree. You also need to know how long the branch should be that will attach the new species to the tree. In some cases this will also be possible to locate in the literature. In other cases, for example if you’re adding a species as a sister species to another species within its genus, you can just choose an arbitrary short branch length, e.g. 0.1 or 1. The exact value depends on the branch lengths in the tree. We can then use R to add the species to the tree. To add a species in R, we first select the node that we want to add the tip to. For example, if we want to add Big Bird to our bird.orders tree as a sister to the Galliformes, we can identify the node to add Big Bird to using: # Identify the node node &lt;- which(bird.orders$tip.label == &quot;Galliformes&quot;) # Which node is it? node ## [1] 2 We then add the species to this node using the bind.tip function in phytools: library(phytools) bird.orders_plusbigbird &lt;- bind.tip(bird.orders, tip.label = &quot;Big_Bird&quot;, where = node, position = 4.5) plot(bird.orders_plusbigbird) You can see that Big Bird has been added to the Galliformes branch. In the bind.tip function, position is the length of the new branch. Here we used 4.5, but you could use other numbers if you needed the branch to be longer or shorter (i.e. if you knew the divergence between Galliformes and Big Bird was longer ago or more recent). Note that the value of position is limited by the length of the branch you are adding the new species to. If you see the error below it means you’ve given position a value which is longer that the existing branch, and you’ll need to make it a bit smaller. Error in bind.tree(tree, tip, where = where, position = pp) : ‘position’ is larger than the branch length 3.4.4 Writing phylogenies to file After manipulating a phylogeny, if you want to save the new tree you can use write.tree or write.nexus as preferred. You can then use this modified tree for you analyses or plots, meaning that you don’t have to do all the manipulation again every time you want to use it. If we want to save the Big Bird tree we can use: write.nexus(bird.orders_plusbigbird, file = &quot;bigbirdtree.nex&quot;) 3.5 Summary This exercise should have given you the skills to understand, plot and manipulate phylogenies in R. 3.6 Practical exercise Read in the frog-tree.nex phylogeny from the folder. This comes from Feng et al. (2017). Then do the following. Use R functions to determine: how many species are in the tree? is the tree fully resolved? is the tree rooted? Use plot.phylo to plot the tree. Can you change the size of the tip labels? Can you make a fan-shaped plot? Can you change the colour of the tips and branches? Save the tree to file as “mysuperdoopertree.nex” EXTRA. Use ggtree and the ggtree manual to produce a phylogeny plot of this tree that you could use in a publication OR make the most exotic looking tree you possibly can. Playing around with these packages is the best way to learn. If you make a particularly amazing or horrific tree, send me a screenshot on Twitter at nhcooper123! References "],["preparing-your-tree-and-data-for-pcms-in-r.html", "Chapter 4 Preparing your tree and data for PCMs in R Before you start 4.1 Preparation 4.2 Reading and checking your phylogeny in R 4.3 Reading the data into R 4.4 Matching your data to your phylogeny 4.5 Quick template code 4.6 Summary 4.7 Practical exercise", " Chapter 4 Preparing your tree and data for PCMs in R Before we do any analysis in R we will generally need to clean and tidy our data. Data cleaning involves looking for errors, for example we might need to remove duplicate columns, or correct typos in species names, or make sure column headers are all unique and easy enough for us to type in R. We also often need to tidy our data. For data to be tidy: Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. The R packages dplyr, tidyr are great for data cleaning and tidying. See https://r4ds.had.co.nz/tidy-data.html for more details on what tidy data is and how to do this in R. Of course you are welcome to do this in Excel or another package if you’re more comfortable with that. The important thing is that when you begin your analyses, your data are in a suitable format. Note that a detailed introduction to data manipulation in R is beyond the scope of this Primer, but if in doubt about your data, try and make it look as much like our example datasets as possible. If you can do that, these R analyses should work for you! :) In this exercise we will take an existing tree and some data and prepare them for a PCM analysis. Note that prior to this step, it is important that your data is in a tidy format, and has been thoroughly checked for errors. The exercise below only shows you how to deal with additional issues caused by using trees and then matching species data to those trees. We assume the tree and data themselves are fit for purpose. We will be using the evolution of eye size in frogs as an example. The data and modified tree come from K. N. Thomas et al. (2020), and the original tree comes from Feng et al. (2017). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out K. N. Thomas et al. (2020)! Before you start Open the 04-Preparation.RProj file in the 04-Preparation folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data ape - functions for reading, plotting and manipulating phylogenies geiger - to check species in the tree and data match phytools - for force.ultrametric 4.1 Preparation 4.1.1 Load the required packages To begin we need to load the packages we need. # Load packages library(ape) library(geiger) library(tidyverse) 4.2 Reading and checking your phylogeny in R We already learned how to do these things in 03-Phylogenies. If you haven’t looked at that exercise I suggest you check it out before doing the steps below. First let’s read in the tree and look at its structure: # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Look at the tree summary frogtree ## ## Phylogenetic tree with 214 tips and 213 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. It’s usually a good idea to quickly plot the tree too… # Plot the tree as a circular/fan phylogeny with small labels plot(frogtree, cex = 0.2, typ = &quot;fan&quot;, no.margin = TRUE) frogtree is a fully resolved tree with branch lengths. There are 214 species and 213 internal nodes. Note that the species names at the tips also have family names added to them… # Look at the first 5 tip labels frogtree$tip.label[1:5] ## [1] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; ## [3] &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ## [5] &quot;Barbourula_busuangensis_Bombinatoridae&quot; Most trees will have just the genus and species names, but some will have additional information like here, or numbering etc. This is not a problem as long as the names match those in your data (see below). Most R functions require your tree to be dichotomous, i.e. to have no polytomies. To check whether your tree is dichotomous use is.binary. # Check whether the tree is binary # We want this to be TRUE is.binary(frogtree) ## [1] TRUE If this was FALSE, we’d use multi2di to make the tree dichotomous, but here it is TRUE so we can leave it as it is. Most functions also require the tree to be rooted, i.e., to have one taxon designated as the outgroup. We can check whether the tree is rooted as follows. # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) ## [1] TRUE Our tree is rooted so it’s ready to go. Finally we might want to check that the tree is ultrametric. Most functions will assume this, and although we can see the tree looks ultrametric when we plotted it above, we should still check. # Check the tree is ultrametric is.ultrametric(frogtree) ## [1] TRUE If this is FALSE there are two options. If the tree really is non-ultrametric, for example if it contains fossil species, then we can’t use it in methods that require an ultrametric tree. However, there are cases (the dragonfly tree in Chapter 11 is one example) where the tree is non-ultrametric due to a rounding error. In the latter case we can use the phytools function force.ultrametric to fix this. When can a tree that looks ultrametric appear to be non-ultrametric? Most of the methods we use expect trees to be ultrametric, i.e. that all the tips line up, generally at the present day (time 0). Sometimes (see Chapter 11 the tree and it looks ultrametric, but when we check using is.ultrametric the answer returned is FALSE. What is going on? The tree is actually ultrametric, and will run in most analyses with R treating it as an ultrametric tree. The reason is.ultrametric tells us it is not ultrametric is related to rounding errors. When you save a tree file, it will save the branch lengths to a certain level of accuracy, but not always the full level of accuracy if your branch lengths have lots and lots of decimal places. When you read these trees back into R, a teeny tiny bit of the accuracy is lost which sometimes means that when R adds up the root-to-tip distances for each tip, they aren’t all exactly the same length, so therefore technically the tree is not ultrametric. For most implementations this tiny difference is not a big deal. A quick fix to this problem is to use the function force.ultrametric which essentially fudges the numbers to force the tree to be ultrametric. If your tree is genuinely non-ultrametric you should not use this function as it can introduce negative branch lengths which will break most functions you might want to use in R. 4.3 Reading the data into R The data are in a comma-delimited text file called frog-eyes.csv. Load these data as follows. # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) Check everything loaded correctly: # Look at the data glimpse(frogdata) ## Rows: 215 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… As you can see, the data contains 215 species, and the following 11 variables: Binomial - the species binomial name. Family - the family the species belongs to. Genus - the genus the species belongs to. tiplabel - the name used for the species in the phylogeny. Adult_habitat - habitat of adults. Categories are: Ground-dwelling, Subfossorial, Scansorial (i.e. tree-dwelling), Semiaquatic, Aquatic, or Fossorial (i.e. burrowers). Life_history - whether the larvae are free-living (Free-living larvae) or not (No free-living larvae). Sex_dichromatism - whether different sexes are different colours (Present) or not (Absent). SVL - snout vent length (in mm). This is a common way to measure body size in amphibians. mass - body mass (in g). rootmass - cube root of the body mass. eyesize - eye size (in mm) for the species. This is an everage across left and right eyes from three individuals per species. Note that in some comparative datasets (most of mine for instance) the species names column (here Binomial) also contains the names of the species in the tree so we would match up that column to the species names in the tree (see below). In this dataset and others, the authors have instead included the names of the tips of the tree as a separate column (here tiplabel). This is often done when the tips of the tree are not species names, but are instead some kind of code. This is common where the tree contains multiple tips for one species, or where the tip labels contain additional information (here they include family names). A final approach used by some authors is to have the species names as the row names of the dataset. Any approach is fine, but make sure you know which column contains the names that should match up with the tree. 4.4 Matching your data to your phylogeny Now we have the tree and the data in R, we need to match the two up if we want to perform any kind of PCM analyses. Below are some common issues you might encounter, and how to fix them. 4.4.1 Species names with spaces Species names in phylogenies are generally written as Genus_species (the gap between the genus name and species name is replaced by an underscore _). If the species names in the data are written as Genus species with a space, then you will have to replace the spaces with _ so that they match up with the species names in the tree. You can do this as follows using str_replace. We don’t need to do this in our frog data, but if we did we could use code like this: # Replace spaces with underscores in species names frogdata &lt;- frogdata %&gt;% mutate(Binomial = str_replace(string = Binomial, pattern = &quot; &quot;, replacement = &quot;_&quot;)) # Check it worked head(frogdata$Binomial) Beware trailing spaces! If you’re trying to match up species names and are having some trouble, check what happened when you replaced spaces with underscores (_). Sometimes we accidentally leave extra spaces when typing, and R will convert these to underscores too which can cause problems. For example, Genus_species can become Genus_species_ if you accidentally left a trailing space. Check all the names in your dataset after replacing the spaces to make sure this is not a problem. 4.4.2 Mismatches between species in your data and phylogeny Often you will have data for species which are not in your phylogeny and/or species in your phylogeny which are not in your data. Many functions in R can deal with this and will match the species for you, others will produce an error telling you the tree and data do not match (e.g. most ape functions). Even in functions that can cope with this, it’s useful to match up the species before your analyses. This can help you identify things like spelling mistakes or variations in the taxonomy of the tree and the data. If you have even slightly misspelled a species name in the tree or the data it will automatically be dropped from the analyses. It is therefore very important to check this before running an analysis, especially one with lots of taxa. We can use the geiger function name.check to find out which names do not match. Remember that the species names that match up with the tree from frogdata are in the variable called tiplabel. # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) The output of check has two parts, tree_not_data for species in the tree but not in the dataset, and data_not_tree for species in the dataset but not in the tree. You need to look at both of these in turn. # Look at species in the tree but not the data check$tree_not_data ## [1] &quot;Incilius_nebulifer_Bufonidae&quot; &quot;Leptobrachella_bidoupensis_Megophryidae&quot; ## [3] &quot;Microhyla_fissipes_Microhylidae&quot; &quot;Microhyla_marmorata_Microhylidae&quot; There are four species in the tree and not the data. We were expecting this here, so no worries. For your analyses you should always check this list carefully. If I were running this analysis for the first time I’d want to check that these species really weren’t in my data. Maybe they are misspelled in the data? If so correct this now. Maybe the species name has changed? If so change this now. It doesn’t really matter whether you make the change in the tree or the data, but make sure anything that should match up, does. I’d usually fix issues in the dataset in Excel or another spreadsheet program, unless it’s a blatant typo in the tree. Next check the species in the data but not the tree. # Look at species in the data but not the tree check$data_not_tree ## [1] &quot;Gastrophryne_carolinensis_Microhylidae&quot; &quot;Leptobrachella_dringi_Megophryidae&quot; ## [3] &quot;Megophrys_gerti_Megophryidae&quot; &quot;Microhyla_pulverata_Microhylidae&quot; ## [5] &quot;Oreobates_quixensis_Strabomantidae&quot; This gives us five species in the data but not in the tree. As above, make sure to correct any errors before moving to the next step. Make sure anything that should match up, does match up. Here we know that these species are missing from our data, so we don’t need to worry. 4.4.3 Matching the tree and the data Finally, once we know which species do not match up, we need to remove species missing from the data from the tree, and remove species missing from the tree from the data. We can remove species missing from the tree easily using drop.tip. You need to list the species which you do not want to select and then drop them from the tree instead of selecting the species you do want. mytree &lt;- drop.tip(frogtree, check$tree_not_data) To remove species from the data which are not in the tree you can use match and subset as follows: matches &lt;- match(frogdata$tiplabel, check$data_not_tree, nomatch = 0) mydata &lt;- subset(frogdata, matches == 0) == means equals. So this line of code selects species which do appear in the data_not_tree list of species, i.e. their value from matches is 0. Always check this has worked as expected by checking the data and the phylogeny. In the first instance you can just use str to make sure you have the expected number of species in each: str(mytree) ## List of 4 ## $ edge : int [1:418, 1:2] 211 212 213 214 215 216 217 218 219 220 ... ## $ edge.length: num [1:418] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 209 ## $ tip.label : chr [1:210] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; The matched phylogeny has 210 species in it (instead of the original 214 species in because the four that weren’t in the data have been removed). glimpse(mydata) ## Rows: 210 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… We now have 210 species in the dataset too, great! One final check to make is to check what type of dataset R thinks mydata is. We can do that using the function class class(mydata) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Interestingly mydata is a tbl_df, tbl and data.frame. This is a data type created by functions in the tidyverse called a tibble. Tibbles have all sorts of useful properties (and a cute name!) but they’re also a pain as many functions don’t recognise that they contain a data frame and will not work on tibbles. We can fix this very easily though, just force R to make mydata into a data frame as follows: # Convert to a data frame mydata &lt;- as.data.frame(mydata) # Check this is now a data frame class(mydata) ## [1] &quot;data.frame&quot; Finally, we might want to output these cleaned and tidied data and tree to our folder so rather than doing this every time we start an analysis, we can just use these tidy versions. To do this we can use: # Write the cleaned data to a new file write_csv(mydata, path = &quot;data/clean-frog-data.csv&quot;) # Write the cleaned tree to a new file write.nexus(mytree, file = &quot;data/clean-frog-tree.nex&quot;) Note, however, that you will have to repeat this preparation process if you add species or data to your tree or dataset at a later date. 4.4.4 NAs in your data When running analyses we can only use species that have a value for each of the variables in the model. In comparative analyses it’s common to have missing data, recorded as NA (not applicable) in our .csv files and in R. It can therefore be useful to subset your data so that you have a complete set of variables for certain analyses. For example let’s see how many “NAs” there are in each of our variables (don’t worry too much about this code if it seems confusing to you!): mydata %&gt;% dplyr::select(everything()) %&gt;% summarise_all(list(~ sum(is.na(.)))) ## Binomial Family Genus tiplabel Adult_habitat Life_history Sex_dichromatism SVL mass ## 1 0 0 0 0 0 22 36 0 0 ## rootmass eyesize ## 1 0 0 22 species don’t have a value for Life_history, and 36 species don’t have a value for Sex_dichromatism. Many PCMs will just ignore NA values, but if you needed to remove these you could subset them out as follows, leaving only the 163 species with complete data. # Subset out the species with NA values for some variables frog_noNA &lt;- filter(mydata, !is.na(Life_history) &amp; !is.na(Sex_dichromatism)) # Look at the data glimpse(frog_noNA) ## Rows: 163 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… 4.5 Quick template code To help you do this with your own data, I’ve condensed the above into one script below so you don’t forget any of the steps. # Load packages library(ape) library(geiger) library(tidyverse) # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Look at the tree summary str(frogtree) # Plot the tree as a circular/fan phylogeny with small labels plot(frogtree, cex = 0.2, typ = &quot;fan&quot;, no.margin = TRUE) # Check whether the tree is binary # We want this to be TRUE is.binary(frogtree) # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(frogtree) # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) # Look at the data glimpse(frogdata) # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) # Look at check check ### Correct any typos/taxonomic errors in the tree or data ### # Remove species missing from the data mytree &lt;- drop.tip(frogtree, check$tree_not_data) # Remove species missing from the tree matches &lt;- match(frogdata$tiplabel, check$data_not_tree, nomatch = 0) mydata &lt;- subset(frogdata, matches == 0) # Look at the tree summary str(mytree) # Look at the data glimpse(mydata) ## OPTIONAL # Make any required subsets of the tree/data ## OPTIONAL # Write the cleaned data to a new file write_csv(mydata, path = &quot;data/clean-frog-data.csv&quot;) # Write the cleaned tree to a new file write.nexus(mytree, file = &quot;data/clean-frog-tree.nex&quot;) 4.6 Summary You should now know how to prepare your tree and dataset for a PCM analysis in R. 4.7 Practical exercise In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data then prepare them for a PCM analysis. References "],["phylogenetic-signal-in-r.html", "Chapter 5 Phylogenetic Signal in R Before you start 5.1 Preparation 5.2 Estimating phylogenetic signal for continuous variables 5.3 Estimating phylogenetic signal for non-continuous variables 5.4 Summary 5.5 Practical exercises", " Chapter 5 Phylogenetic Signal in R Phylogenetic signal is the pattern where close relatives have more similar trait values than more distant relatives. The aims of this exercise are to learn how to use R to estimate phylogenetic signal using Pagel’s \\(\\lambda\\) Pagel (1999) and Blomberg’s K (Blomberg, Garland Jr, and Ives 2003). We will be using the evolution of eye size in frogs as an example. The data and modified tree come from K. N. Thomas et al. (2020), and the original tree comes from Feng et al. (2017). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out K. N. Thomas et al. (2020)! Before you start Open the 05-PhyloSignal.RProj file in the 05-PhyloSignal folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data ape - functions for reading, plotting and manipulating phylogenies geiger - to check species in the tree and data match phytools - to estimate \\(lambda\\) and K caper - to estimate D 5.1 Preparation To begin we need to load the packages for this practical. # Load the packages library(tidyverse) library(ape) library(geiger) library(phytools) library(caper) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) # Check everything loaded corrected glimpse(frogdata) ## Rows: 215 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… To load the tree we will use read.nexus. # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Check it loaded correctly str(frogtree) ## List of 4 ## $ edge : int [1:426, 1:2] 215 216 217 218 219 220 221 222 223 224 ... ## $ edge.length: num [1:426] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 213 ## $ tip.label : chr [1:214] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary(frogtree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(frogtree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) # Look at check check ## $tree_not_data ## [1] &quot;Incilius_nebulifer_Bufonidae&quot; &quot;Leptobrachella_bidoupensis_Megophryidae&quot; ## [3] &quot;Microhyla_fissipes_Microhylidae&quot; &quot;Microhyla_marmorata_Microhylidae&quot; ## ## $data_not_tree ## [1] &quot;Gastrophryne_carolinensis_Microhylidae&quot; &quot;Leptobrachella_dringi_Megophryidae&quot; ## [3] &quot;Megophrys_gerti_Megophryidae&quot; &quot;Microhyla_pulverata_Microhylidae&quot; ## [5] &quot;Oreobates_quixensis_Strabomantidae&quot; Here all the excluded species are excluded because they are genuinely missing, not because of any typos, so we can move on. Next we exclude species that are not in both the tree and the data, using the following code: # Remove species missing from the data mytree &lt;- drop.tip(frogtree, check$tree_not_data) # Remove species missing from the tree matches &lt;- match(frogdata$tiplabel, check$data_not_tree, nomatch = 0) mydata &lt;- subset(frogdata, matches == 0) Finally we check the tree and data have the same number of species: # Look at the tree summary str(mytree) ## List of 4 ## $ edge : int [1:418, 1:2] 211 212 213 214 215 216 217 218 219 220 ... ## $ edge.length: num [1:418] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 209 ## $ tip.label : chr [1:210] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Look at the data glimpse(mydata) ## Rows: 210 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… Don’t forget to ensure the data are a data frame: # Convert to a dataframe mydata &lt;- as.data.frame(mydata) # Check this is now a data frame class(mydata) ## [1] &quot;data.frame&quot; Now we’re ready to run our analyses! 5.2 Estimating phylogenetic signal for continuous variables As is common in R, there are a number of ways to estimate Pagel’s \\(\\lambda\\) and Blomberg’s K. I’ve chosen to show you the way implemented in the package phytools because it allows you to use the same function for both. Why do we look at two different measures of phylogenetic signal? We don’t have to, you could choose one and stick to it. However, I guarantee if you choose one then a reviewer/your supervisor/boss will ask for the other, so why not do both and pop one in the appendix? Let’s estimate \\(\\lambda\\) for log eye size. The first thing we need to do is to create an object in R that only contains the variable required, and the species names (so we can match it up to the tree). We can use the function pull to extract just the eye size values, and we can log transform all these numbers using log if we want to work with log eye size values. # Create logEye containing just log eye size length values logEye &lt;- log(pull(mydata, eyesize)) # Look at the first few rows head(logEye) ## [1] 1.163151 1.679430 1.851076 2.021548 1.415044 1.330605 Notice that this is currently just a long list of numbers. We can then name these values with the species names from mydata using the function names. Note that this requires the trait data is in the same order as the tree tip labels, but luckily make.treedata does this automatically. # Give log Eye names = species names at the tips of the phylogeny names(logEye) &lt;- mydata$tiplabel # Look at the first few rows head(logEye) ## Allophryne_ruthveni_Allophrynidae Eupsophus_roseus_Alsodidae ## 1.163151 1.679430 ## Alytes_obstetricans_Alytidae Discoglossus_pictus_Alytidae ## 1.851076 2.021548 ## Allobates_femoralis_Dendrobatidae Arthroleptis_poecilonotus_Arthroleptidae ## 1.415044 1.330605 Now we have a list of values with associated species names. 5.2.1 Pagel’s \\(\\lambda\\) We can now estimate \\(\\lambda\\) using the function phylosig: lambdaEye &lt;- phylosig(mytree, logEye, method = &quot;lambda&quot;, test = TRUE) test = TRUE specifies that we want to run a likelihood ratio test to determine if \\(\\lambda\\) is significantly different from 0. To look at the output we just type in the name of the model; lambdaEye in this case lambdaEye ## ## Phylogenetic signal lambda : 0.802864 ## logL(lambda) : -112.137 ## LR(lambda=0) : 62.803 ## P-value (based on LR test) : 2.28447e-15 The \\(\\lambda\\) estimate for log eye size is around 0.803. logL is the log-likelihood, LR(lambda=0) is the log-likelihood for \\(\\lambda\\) of 0, and P-value is the p value from a likelihood ratio test testing whether \\(\\lambda\\) is significantly different from 0 (no phylogenetic signal). Here P &lt; 0.001. We interpret this as \\(\\lambda\\) being significantly different from 0, i.e. there is significant phylogenetic signal in log eye size. 5.2.2 Blomberg’s K (Blomberg et al 2003) To estimate Blomberg’s K we also use phylosig but with method = K. KEye &lt;- phylosig(mytree, logEye, method = &quot;K&quot;, test = TRUE, nsim = 1000) Additionally we add the argument nsim = 1000. This is because we need to use a randomisation test to determine whether K is significantly different from 0. phylosig randomly assigns the trait values to the species and then calculates K as many times as we ask it to in nsim (number of simulations). Here we asked for 1000. After the random simulations are run, the observed value of K is then compared to the randomized values. The p value tells us how many times out of 1000, a randomised value of K is more extreme than the observed value. If this number is low, the p value is low (e.g. if 5 out of 1000 randomised values of K are more extreme than the observed value p = 5/1000 = 0.005). As above, to look at the output we just type in the name of the model; KEye in this case KEye ## ## Phylogenetic signal K : 0.283009 ## P-value (based on 1000 randomizations) : 0.001 K for log eye size is 0.283. The p value tells us how many times out of 1000, a randomised value of K is more extreme than the observed value. If this number is low, the p value is low (e.g. if 5 out of 1000 randomised values of K are more extreme than the observed value p = 5/1000 = 0.005). Here p = 0.001, suggesting that only 1 randomised value of K was more extreme than the observed value. We interpret this as K being significantly different from 0, i.e. there is significant phylogenetic signal in log eye size. Remember that when fitting models to account for phylogenetic non-independence, it is not phylogenetic signal in the individual variables that is important. It is phylogenetic signal in the residuals of the model that matters. Evidence of phylogenetic signal in variable X (or variable Y) does not necessarily mean that there will be phylogenetic signal in the residuals of a model correlating variable X with variable Y. Conversely, lack of evidence of phylogenetic signal in variable X (or variable Y) does not necessarily mean that there will be no phylogenetic signal in the residuals of a model correlating variable X with variable Y. 5.3 Estimating phylogenetic signal for non-continuous variables Not all variables are continuous, some are categorical, some are binary. For example in the frog data Adult_habitat, Life_history and Sex_dichromatism are categorical variables. We can also code Sex_dichromatism as a binary variable if we code Absent as 0 and Present as 1. glimpse(mydata) ## Rows: 210 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… Estimating phylogenetic signal in categorical variables is tricky. Let’s take Adult_habitat as an example. In this variable we have the following categories: mydata %&gt;% dplyr::select(Adult_habitat) %&gt;% distinct() ## Adult_habitat ## 1 Scansorial ## 2 Ground-dwelling ## 3 Subfossorial ## 4 Semiaquatic ## 5 Aquatic ## 6 Fossorial Remember with phylogenetic signal we are looking for the pattern where close relatives are more similar to one another than more distant relatives. For these categories, it would be sensible to say we had high phylogenetic signal if, for example, all toads are Semiaquatic, and all tree frogs are Scansorial (climbers). But what if some toads are Semiaquatic but others are Ground-dwelling? If we don’t know how species transition from state to state, it’s hard to know what we might expect to see as evolutionary distance between species increases. We might sensibly assume that species easily evolve from Semiaquatic to Aquatic, or from Subfossorial to Fossorial (burrowing), but what about changes from Aquatic to Fossorial? All of this makes phylogenetic signal for categorical variables a bit of a mess. There are a couple of, more or less satisfying, solutions… Do we actually need to know the phylogenetic signal for these variables? For the models we are interested in phylogenetic signal in the residuals, so maybe we don’t care about phylogenetic signal in the variables? Unless there is a real need, don’t bother! You could visualise what is going on instead by adding colours to the tips of the phylogeny to represent the different categories. This should give you an idea about whether categories cluster in different clades or not. We could code our categories numerically then use \\(\\lambda\\) and K as usual. This is only suitable if the categories are ordered, and if the difference between each pair of categories can be considered equal. For example, a variable that has low, medium and high values could be coded as low = 1, medium = 2, and high = 3. Again this is not ideal, but will give you an answer. I’d avoid this if possible. We could recode these as binary variables and use D (Fritz and Purvis 2010). For example, creating a new variable called Aquatic, and coding each species as 0 = not aquatic; 1 = aquatic. This is probably the best solution. 5.3.1 D We can estimate D using the function phylo.d in the caper package. First we’d need to set up a binary (0,1) variable. Let’s look at Sex_dichromatism as this only has two categories already (Absent and Present). mydata %&gt;% group_by(Sex_dichromatism) %&gt;% summarise(n()) ## # A tibble: 3 × 2 ## Sex_dichromatism `n()` ## &lt;chr&gt; &lt;int&gt; ## 1 Absent 150 ## 2 Present 24 ## 3 &lt;NA&gt; 36 There are 36 species without data for this variable. If we were doing something like PGLS (see next exercise), caper would be fine with this, but for phylo.d we can only work with data without NAs. To fix this, we can use filter to exclude the species with NAs, but we will also need to remove these species from the tree. Let’s first go back to mydata so we can exclude the species without Sex_dichromatism data, making frogdata2. # Filter out species with no Sex_dichromatism data mydata2 &lt;- mydata %&gt;% filter(!is.na(Sex_dichromatism)) Next we need to check the matching species in the tree and the new dataset and remove the missing species from the tree: # Check whether the names match in the data and the tree check2 &lt;- name.check(phy = mytree, data = mydata2, data.names = mydata2$tiplabel) # Remove species missing from the data mytree2 &lt;- drop.tip(mytree, check2$tree_not_data) Now we can go back to our workflow, but using mydata2 and mytree2. We also need the variable Sex_dichromatism to be either 0 or 1. We can do this fairly easily using mutate to create a new variable called sex_di_binary. mydata2 &lt;- mydata2 %&gt;% # Make a new variable called sex_di_binary # which is Sex_dichromatism expressed as numbers # i.e. Absent = 1 and Present = 2. # To make these 0 and 1 instead we just use -1 mutate(sex_di_binary = as.numeric(as.factor(Sex_dichromatism)) - 1) To use phylo.d we need the caper package. caper requires you to first combine the phylogeny and data into one object using the function comparative.data. Note that vcv = TRUE stores a variance covariance matrix of your tree (you will need this for the pgls function in the next exercise). na.omit = FALSE stops the function from removing species without data for all variables. warn.dropped = TRUE will tell you if any species are not in both the tree and the data and are therefore dropped from the comparative data object. We need to use as.data.frame before data2 as using the tidyverse functions above to change the sexual dimorphism scores has made it a combined data frame and tibble (a special kind of data frame for the tidyverse) but comparative.data only wants the data frame. frog &lt;- comparative.data(phy = mytree2, data = as.data.frame(mydata2), names.col = tiplabel, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE) This function will give a warning telling you that some species have been dropped. Always make sure you check the list of dropped species is what you expected, as it often reveals typos in your species names, or mismatches in taxonomies used etc. You can view the dropped species using: frog$dropped$unmatched.rows ## character(0) This shows nothing because we already fixed the data so that all the species in the data are in the tree. frog$dropped$tips ## character(0) This also shows nothing because we already fixed the tree so that all the species in the tree are in the data. One last bit of prep required is that D cannot be estimated where trees have zero length branches. In 04-Preparation you may recall that we dealt with polytomies by replacing them with zero length branches using the ape function mutli2di. To remove the zero length branches we are going to use the opposite function: di2multi. This deletes all zero length branches and collapses them back into polytomies. frog$phy &lt;- di2multi(frog$phy) Now we are ready to to estimate D. # Estimate D Dsexdi &lt;- phylo.d(data = frog, names.col = tiplabel, binvar = sex_di_binary, permut = 1000) # Look at the output Dsexdi ## ## Calculation of D statistic for the phylogenetic structure of a binary variable ## ## Data : as.data.frame(mydata2) ## Binary variable : sex_di_binary ## Counts of states: 0 = 150 ## 1 = 24 ## Phylogeny : mytree2 ## Number of permutations : 1000 ## ## Estimated D : 0.8556752 ## Probability of E(D) resulting from no (random) phylogenetic structure : 0.153 ## Probability of E(D) resulting from Brownian phylogenetic structure : 0.004 phylo.d estimates the D value, then tests the estimated D value for significant departure from random association and a Brownian evolution threshold model (see Primer and Fritz and Purvis (2010) for more details). Here D for Sex_dichromatism is 0.856. This is significantly different from the expectation under a Brownian threshold model (p = 0.004) but not significantly different from the trait being randomly assorted on the phylogeny (p = 0.153). So here we can say there is no significant phylogenetic signal in the trait. We can make a really quick plot to check we agree with that statement (never take the results of any analysis at face value). It doesn’t seem like sexual dichromatism (red text) is a trait that is particularly clustered within certain taxonomic groups, so seems that D is giving us a sensible answer. mycolours &lt;- c(&quot;black&quot;, &quot;red&quot;) plot(frog$phy, show.tip.label = TRUE, tip.color = mycolours[as.numeric(mydata2$sex_di_binary)+1], no.margin = TRUE, cex = 0.4) # Add a legend legend(&quot;bottomleft&quot;, fill = mycolours, legend = c(&quot;Absent&quot;, &quot;Present&quot;), bty = &quot;n&quot;) Always carefully consider what variation in values of \\(\\lambda\\) and K and D across traits and groups really means. It may not tell you as much about your system as you think it does. Phylogenetic signal is only a pattern, not a process! 5.4 Summary You should now be able to estimate the phylogenetic signal of your variables using R. 5.5 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in the previous exercise which should save you some time). Then answer the following questions. What is \\(\\lambda\\) for log gestation length? What is K for log gestation length? What is D for social status? References "],["phylogenetic-generalised-least-squares-pgls-in-r.html", "Chapter 6 Phylogenetic Generalised Least Squares (PGLS) in R Before you start 6.1 Preparation 6.2 Phylogenetic generalized least squares models (PGLS) 6.3 Common issues when running PGLS models in R 6.4 Summary 6.5 Practical exercises", " Chapter 6 Phylogenetic Generalised Least Squares (PGLS) in R The aims of this exercise are to learn how to use R to perform Phylogenetic Generalised Least Squares (PGLS) analyses. We will be using the evolution of eye size in frogs as an example. The data and modified tree come from K. N. Thomas et al. (2020), and the original tree comes from Feng et al. (2017). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out K. N. Thomas et al. (2020)! Before you start Open the 06-PGLS.RProj file in the 06-PGLS folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data ape - functions for reading, plotting and manipulating phylogenies geiger - to check species in the tree and data match caper - to fit PGLS models 6.1 Preparation To begin we need to load the packages for this practical. # Load the packages library(ape) library(geiger) library(caper) library(tidyverse) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) # Check everything loaded corrected glimpse(frogdata) ## Rows: 215 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… To load the tree we will use read.nexus. # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Check it loaded correctly str(frogtree) ## List of 4 ## $ edge : int [1:426, 1:2] 215 216 217 218 219 220 221 222 223 224 ... ## $ edge.length: num [1:426] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 213 ## $ tip.label : chr [1:214] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary(frogtree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(frogtree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) # Look at check check ## $tree_not_data ## [1] &quot;Incilius_nebulifer_Bufonidae&quot; &quot;Leptobrachella_bidoupensis_Megophryidae&quot; ## [3] &quot;Microhyla_fissipes_Microhylidae&quot; &quot;Microhyla_marmorata_Microhylidae&quot; ## ## $data_not_tree ## [1] &quot;Gastrophryne_carolinensis_Microhylidae&quot; &quot;Leptobrachella_dringi_Megophryidae&quot; ## [3] &quot;Megophrys_gerti_Megophryidae&quot; &quot;Microhyla_pulverata_Microhylidae&quot; ## [5] &quot;Oreobates_quixensis_Strabomantidae&quot; Here all the excluded species are excluded because they are genuinely missing, not because of any typos, so we can move on. Next we remove species that are not in the tree and data. # Remove species missing from the data mytree &lt;- drop.tip(frogtree, check$tree_not_data) # Remove species missing from the tree matches &lt;- match(frogdata$tiplabel, check$data_not_tree, nomatch = 0) mydata &lt;- subset(frogdata, matches == 0) Finally we save check the data and the tree, and convert the data to a data frame. # Look at the tree summary str(mytree) ## List of 4 ## $ edge : int [1:418, 1:2] 211 212 213 214 215 216 217 218 219 220 ... ## $ edge.length: num [1:418] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 209 ## $ tip.label : chr [1:210] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Look at the data glimpse(mydata) ## Rows: 210 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… # Convert to a dataframe mydata &lt;- as.data.frame(mydata) # Check this is now a data frame class(mydata) ## [1] &quot;data.frame&quot; Note that is is possible to directly to do this in caper using the comparative.data function, but it is good practice to do this to check the data and taxa match as you expected them to before you start your analyses. Now we’re ready to run our analyses! 6.2 Phylogenetic generalized least squares models (PGLS) Much of the information below assumes that you are familiar with fitting and interpreting linear models (regressions, ANOVA, ANCOVA) in R using the function lm. If you aren’t I recommend taking a quick break to refamiliarise yourself with these models. It will make things much clearer. Even if you have never done these in R before, you should at least be familiar with the models, their assumptions and the kinds of results you might expect. Let’s investigate the relationship between eye size in frogs and their body size. Theory leads us to believe that bigger animals will have bigger eyes, but is this true in frogs? We can first quickly look at the phylogenetic non-independence/pseudoreplication on the graph by colouring the points by family. # Plot eyesize against body mass, coloured by family ggplot(mydata, aes(x = log(mass), y = log(eyesize), colour = Family)) + geom_point() + theme_bw() This is a bit messy because there are a lot of families, but note how certain families are clustered on the graph. It’s clear that close relatives are more similar than distant relatives. So we need to account for phylogenetic non-independence, both because of the statistical issues caused by this and because it’s a better way to model the biological reality of our question. We know frog species evolve from other frog species, and that close relatives will therefore be similar, so we should add this into our models. There are several ways of accounting for phylogenetic non-independence in your analyses. Here we will use phylogenetic generalized least squares (PGLS). Another popular earlier method is independent contrasts (PIC). This method is really similar to PGLS, in fact it is just a special kind of PGLS where \\(\\lambda\\) is equal to 1. PGLS offers some important advantages over independent contrasts. The model of trait evolution can be more flexible i.e., it can depart from a strict Brownian motion process (\\(\\lambda\\) or K = 1). Different scaling parameters (\\(\\lambda\\), \\(\\kappa\\), and \\(\\delta\\)) can be incorporated in the analysis, which can significantly improve the fit of the data to the model and thus also improve the estimation of the trait correlation. Another advantage of PGLS is that the intercept of the regression is not forced to be zero. See the Primer for more details on the theory underlying PICs and PGLS. 6.2.1 Fitting PGLS models in R To perform PGLS models in R, caper requires you to first combine the phylogeny and data into one object using the function comparative.data. Note that vcv = TRUE stores a variance covariance matrix of your tree (you will need this for the pgls function). na.omit = FALSE stops the function from removing species without data for all variables. warn.dropped = TRUE will tell you if any species are not in both the tree and the data and are therefore dropped from the comparative data object. Here we won’t drop any species because we already did this above. frog &lt;- comparative.data(phy = mytree, data = as.data.frame(mydata), names.col = tiplabel, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE) If you do need to drop species, this function will give a warning telling you that some species have been dropped. You can view the dropped species using: frog$dropped$tips ## character(0) frog$dropped$unmatched.rows ## character(0) Always make sure you check the list of dropped species is what you expected, it often reveals typos in your species names, or mismatches in taxonomies used etc. Here we already fixed this problem, so nothing is listed. See the 04-Preparation chapter for more details. The function for PGLS analyses in caper is pgls. To fit a model which uses the Maximum Likelihood (ML) estimate of \\(\\lambda\\) we use the following code: # Fit a PGLS model model.pgls &lt;- pgls(log(eyesize) ~ log(mass), data = frog, lambda = &quot;ML&quot;) To look at the output we use anova (in the same way as we would when fitting a model using lm): # Look at the model outputs anova(model.pgls) ## Analysis of Variance Table ## Sequential SS for pgls: lambda = 0.98, delta = 1.00, kappa = 1.00 ## ## Response: log(eyesize) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## log(mass) 1 58.595 58.595 906.82 &lt; 2.2e-16 *** ## Residuals 208 13.440 0.065 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 It’s always good to look at the output using anova first. This uses sequential sum of squares to tell you whether a model including your predictor variable(s) is a better fit than a model without your predictor variable(s). For a complex model with lots of predictors this is the easiest way to find out the answer to the question you were asking (this will become more obvious in the next example using two predictor variables). Here we asked “is there a significant effect of log(mass) on log(eyesize)?”. The answer is YES, there is a significant effect of log(mass) on log(eyesize). If we were reporting this result in a report/thesis/paper we would do it as follows: There was a significant effect of mass on eyesize (PGLS: F = 906.82, df = 1,208, p &lt; 0.001, \\(\\lambda\\) = 0.98). This is exactly how you would report the output of any non-phylogenetic linear model, except we also include the \\(\\lambda\\) value when reporting the PGLS results. We might also be interested in the model coefficients, i.e. the intercept and slope. To do this, just like we do for lm, we use summary: # Look at the model coefficients summary(model.pgls) ## ## Call: ## pgls(formula = log(eyesize) ~ log(mass), data = frog, lambda = &quot;ML&quot;) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.01708 -0.15412 0.00854 0.17623 0.82580 ## ## Branch length transformations: ## ## kappa [Fix] : 1.000 ## lambda [ ML] : 0.976 ## lower bound : 0.000, p = &lt; 2.22e-16 ## upper bound : 1.000, p = 0.092889 ## 95.0% CI : (0.924, NA) ## delta [Fix] : 1.000 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.0327690 0.1472023 7.016 3.157e-11 *** ## log(mass) 0.2774303 0.0092128 30.113 &lt; 2.2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2542 on 208 degrees of freedom ## Multiple R-squared: 0.8134, Adjusted R-squared: 0.8125 ## F-statistic: 906.8 on 1 and 208 DF, p-value: &lt; 2.2e-16 We’d report this in a paper/report/thesis as: There was a significant positive relationship between mass and eyesize (PGLS: slope \\(\\pm\\) SE = 0.277 \\(\\pm\\) 0.009, t = 30.113, df = 208, p &lt; 0.001, \\(\\lambda\\) = 0.976). Again this is exactly the same as we would do for lm without the phylogenetic component, except we also include the \\(\\lambda\\) value when reporting the PGLS results. Note that as well as the standard regression outputs, the summary output includes the estimated ML value of \\(\\lambda\\) (0.976) and p values from likelihood ratio tests showing whether the ML \\(\\lambda\\) is significantly different from 0 or 1. You may have also noticed \\(\\kappa\\) and \\(\\delta\\) in the PGLS output. \\(\\kappa\\) and \\(\\delta\\) are also tree transformations which can improve the fit of the data to the tree. It is possible to use pgls to optimise \\(\\kappa\\) or \\(\\delta\\) (using kappa = “ML” or delta = “ML” instead of lambda = “ML” in the code above). We will not cover this here. Optimizing more than one of these parameters at the same time is not advisable because it would be impossible to interpret the results! We can also plot the results as follows: ggplot(mydata, aes(x = log(mass), y = log(eyesize))) + geom_point() + geom_abline(slope = coefficients(model.pgls)[2], intercept = coefficients(model.pgls)[1]) + theme_bw() Note that coefficients(model.pgls) gives us the intercept coefficients(model.pgls)[2], and slope coefficients(model.pgls)[2] of the line, allowing us to use geom_abline to fit the line. # Check out the model coefficients (intercept and slope) coefficients(model.pgls) ## (Intercept) log(mass) ## 1.0327690 0.2774303 6.2.2 Model diagnostics for PGLS models You must always check model diagnostic plots whenever you fit a model in R to check that your data meet the assumptions of the model. Ideally you should do this BEFORE looking at anova or summary as if your assumptions are not met, then the model is useless and needs to be modified before you can use it to extract p values etc. The method for getting model diagnostics for PGLS is the same for linear models, independent contrasts and PGLS models (though the graphs are slightly different) - we just use the function plot. You might recall we also use plot to plot phylogenies and other things. plot is one of a set of clever functions in R that uses an ifelse statement to decide what kind of plot it should do. When you ask R to plot something, it first determines what class of object it is. It then chooses the correct version of plot for that class. In this case the function it is actually using to plot the model diagnostics for PGLS is plot.pgls. You might also have spotted that anova and summary work in the same way… To get model diagnostic plots for PGLS: # First make a plotting window with four panes as there are four plots par(mfrow = c(2, 2)) # Now plot the model diagnostics plot(model.pgls) # Return the plot window to one pane for later plotting par(mfrow = c(1, 1)) If you’ve no idea what these diagnostic plots are for I suggest reading up on this. Getting Started With R is a good place to start, but plots 2 and 3 at least should have been covered in whatever standard statistics course you’ve taken previously. In brief: In plot 1 (upper left-hand plot) you should not see any data with a studentized residual &gt; \\(\\pm\\) 3. Any species with such large residuals may overly influence the results of the regression. Often these are the result of measurement error associated with species pairs joined by very short branches. You should report results with and without these outliers included, to see how much of an impact they have on your results. In plot 2 (upper right-hand plot), the Normal Q-Q plot, the points should approximately fall on the line. This tests for normality of residuals, one of the assumptions of linear models. Note that Q-Q plots often look a bit messy, but unless you plan to use your PGLS model to predict values for your response variable outside of the range of the predictors used in your model (i.e. if you fitted a model of mass vs eyesize with mass ranging from 1g to 100g and then you wanted to use the model to predict eyesize when mass was 1000g) it isn’t too much of a problem. The other diagnostic plots are much more important. In plot 3 (lower left-hand plot), the Fitted versus Residuals plot, we hope to see a fairly random scattering of points, often referred to as a sky at night distribution. This diagnostic plot is related to the systematic component of the model - any pattern here (e.g. strong positive or negative slopes, or humped or U-shaped patterns) suggests that the model has not been correctly specified. This might reflect a missing variable or interaction term, or that you need to transform your variables. Or that you need a different kind of model entirely. In plot 4 (lower right-hand plot), the Fitted versus Observed plot, we should see a correlation among the observed values and fitted values in the model. This will vary depending on how good the model fit is. It takes practice to know what is “good”, “bad” and “acceptable” with these plots. Here I would say the plots above are fine. 6.2.3 Likelihood profiles for \\(\\lambda\\) in PGLS models You should also look at the likelihood profiles for branch length transformations in PGLS models using pgls.profile: # Create a likelihood profile of the lambda estimate lambda.profile &lt;- pgls.profile(model.pgls, &quot;lambda&quot;) # Plot the likelihood profile plot(lambda.profile) This graph shows the likelihood profile of \\(\\lambda\\) in our model. Ideally you want a line with an obvious peak/optimum, rather than a flat line which would suggest \\(\\lambda\\) could be anything. You can see that the optimum (the peak of the curve) is at 0.976 as estimated in our PGLS model. The dotted red lines are the 95% confidence intervals on \\(\\lambda\\) for our model. pgls.confint prints out these numbers in $ci.val if you want to know the exact numbers. # Extract the confidence intervals on lambda pgls.confint(model.pgls, &quot;lambda&quot;)$ci.val ## [1] 0.9237133 NA Note that because our \\(\\lambda\\) value is so close to 1, and this is the upper bound for \\(\\lambda\\) in a PGLS model, the upper confidence interval is NA. If you needed to report the upper and lower confidence intervals (and this is good practice if they cover a large range of numbers), you could report the upper confidence interval here as 1. If the opposite situation occurred for a \\(\\lambda\\) close to 0, you would use the lower confidence interval of 0. 6.2.4 A PGLS example with more than one predictor variable In reality we are often interested in fitting models with more than one predictor variable. In the case of our frog eye size example, we’ve shown that smaller frogs have smaller eyes than larger frogs, but we imagine that the habitat the frogs live in might also influence eye size. For example, frogs living underground might have smaller eyes for their body size compared to frogs living in trees because they don’t use their eyes as much (see K. N. Thomas et al. (2020) to see whether this is indeed the case!). We can fit a more complex model to test whether eye size is correlated with both mass and adult habitat as follows: # Fit a PGLS model model.pgls2 &lt;- pgls(log(eyesize) ~ log(mass) * as.factor(Adult_habitat), data = frog, lambda = &quot;ML&quot;) It may help some of you if I tell you this is a phylogenetic version of an ANCOVA (analysis of covariance), whereas our first example was a regression. Both are linear models. Two things to note. First, as with lm in R, * means fit each predictor as a main effect AND include the interaction between them too. log(mass) * as.factor(Adult_habitat) is actually shorthand for typing log(mass) + as.factor(Adult_habitat) + log(mass):as.factor(Adult_habitat). log(mass):as.factor(Adult_habitat) is the interaction between mass and habitat, shown with the :. Second, I’ve added as.factor in front of Adult_habitat. This is to get R to treat this variable as a factor with levels, rather than as either a numeric variable, or as character data. Here it is not strictly needed as R already thinks Adult_habitat is a factor, but it’s a good idea to make sure. Now we’ve fitted the model, we need to check the model diagnostic plots. If these are unsuitable then we need to rethink how we fit the model. # First make a plotting window with four panes as there are four plots par(mfrow = c(2, 2)) # Now plot the model diagnostics plot(model.pgls2) # Return the plot window to one pane for later plotting par(mfrow = c(1, 1)) And let’s check out the lambda profile too. # Create a likelihood profile of the lambda estimate lambda.profile &lt;- pgls.profile(model.pgls2, &quot;lambda&quot;) # Plot the likelihood profile plot(lambda.profile) These all look fine so we can move on… Let’s look at the anova outputs. anova(model.pgls2) ## Analysis of Variance Table ## Sequential SS for pgls: lambda = 0.93, delta = 1.00, kappa = 1.00 ## ## Response: log(eyesize) ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## log(mass) 1 44.771 44.771 1084.2494 &lt; 2.2e-16 *** ## as.factor(Adult_habitat) 5 2.436 0.487 11.8005 5.335e-10 *** ## log(mass):as.factor(Adult_habitat) 5 0.604 0.121 2.9275 0.01422 * ## Residuals 198 8.176 0.041 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 OK great, this output is fairly easy to read (compared to the summary which we will look at in a bit!). The first row, labelled log(mass) tells us that the main effect of log(mass) is significant (p &lt; 0.001), i.e. log(mass) is significantly correlated with log(eyesize). It doesn’t tell us anything about direction (positive or negative) of the correlation, but we can do a quick plot to work this out: ggplot(mydata, aes(x = log(mass), y = log(eyesize))) + geom_point() + theme_bw() The plot clearly shows that as body size increases so does eye size (we already knew this from our first model above). The second row, labelled as.factor(Adult_habitat) tells us that the main effect of Adult habitat is also significant (p &lt; 0.001), i.e. Adult_habitat is significantly correlated with log(eyesize). Again we can do a quick plot to work to see which habitats are different… ggplot(mydata, aes(x = Adult_habitat, y = log(eyesize))) + geom_boxplot() + theme_bw() Eye size is smallest, on average, in fossorial (burrowing) frogs. That fits with what we know about burrowing animals - they tend to have reduced eyes (think of moles!). Finally the last row labelled log(mass):as.factor(Adult_habitat) tells us that the interaction between mass and habitat is significant (p = 0.014). This means that the relationship (i.e. the slope in a plot) between log(mass) and log(eyesize) varies in relation to Adult_habitat. We can look at this with another quick plot. ggplot(mydata, aes(x = log(mass), y = log(eyesize), colour = Adult_habitat)) + geom_point() + geom_smooth(method = &#39;lm&#39;, se = FALSE, formula = &#39;y ~ x&#39;) + theme_bw() We can see that the slope for fossorial (burrowing) species is shallower than for other species, suggesting that eye size increases more slowly with increasing mass in that group. I used geom_smooth(method = ‘lm’, se = FALSE) in the code above to get a quick idea of what the slopes look like using an lm. These slopes won’t be exactly the same in the PGLS model, but it gives us an idea of what is going on. Do not use geom_smooth to draw regression lines in your reports/papers/thesis. The function is for data exploration only and does not give the correct slope/confidence interval unless your models is very simple. We can get the correct intercepts and slopes for each of these lines using the summary function and our PGLS model, see below. I showed you the plots and anova output first because, as you’ll see below, summary outputs get complicated fast! summary(model.pgls2) ## ## Call: ## pgls(formula = log(eyesize) ~ log(mass) * as.factor(Adult_habitat), ## data = frog, lambda = &quot;ML&quot;) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.70184 -0.11053 0.01051 0.13012 0.68947 ## ## Branch length transformations: ## ## kappa [Fix] : 1.000 ## lambda [ ML] : 0.931 ## lower bound : 0.000, p = &lt; 2.22e-16 ## upper bound : 1.000, p = 0.0027911 ## 95.0% CI : (0.827, 0.985) ## delta [Fix] : 1.000 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.063339 0.168677 6.3040 1.849e-09 *** ## log(mass) 0.237742 0.037012 6.4234 9.696e-10 *** ## as.factor(Adult_habitat)Fossorial 0.108237 0.245771 0.4404 0.6601 ## as.factor(Adult_habitat)Ground-dwelling -0.018248 0.136761 -0.1334 0.8940 ## as.factor(Adult_habitat)Scansorial 0.081581 0.139220 0.5860 0.5586 ## as.factor(Adult_habitat)Semiaquatic 0.123482 0.147832 0.8353 0.4046 ## as.factor(Adult_habitat)Subfossorial -0.150782 0.139996 -1.0770 0.2828 ## log(mass):as.factor(Adult_habitat)Fossorial -0.114428 0.073321 -1.5606 0.1202 ## log(mass):as.factor(Adult_habitat)Ground-dwelling 0.056417 0.039114 1.4424 0.1508 ## log(mass):as.factor(Adult_habitat)Scansorial 0.047165 0.042531 1.1090 0.2688 ## log(mass):as.factor(Adult_habitat)Semiaquatic 0.018215 0.042324 0.4304 0.6674 ## log(mass):as.factor(Adult_habitat)Subfossorial 0.087142 0.042066 2.0715 0.0396 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2032 on 198 degrees of freedom ## Multiple R-squared: 0.854, Adjusted R-squared: 0.8459 ## F-statistic: 105.3 on 11 and 198 DF, p-value: &lt; 2.2e-16 If you’re unfamiliar with these kinds of outputs it’s worth taking this slowly. Note that this is exactly the same as interpreting the output of a non-phylogenetic ANCOVA fitted using lm. The first row, labelled (Intercept), gives the intercept for the Adult_habitat that is first alphabetically. The row labelled log(mass) is the slope for the Adult_habitat that is first alphabetically. In this case that’s the Aquatic habitat (if you scroll back up to the figure with the different slopes you’ll see that it’s the first alphabetically, and also because of this it’s the only one not labelled in the output above). All of the other intercepts and slopes are treatment contrasts. Rather than the intercepts and slopes themselves, R reports the difference between the Adult_habitat in question and the Aquatic habitat (the first alphabetically). So the intercept for the fossorial frogs (as.factor(Adult_habitat)Fossorial) is… 1.063339 + 0.108237 ## [1] 1.171576 And the slope for the fossorial frogs (log(mass):as.factor(Adult_habitat)Fossorial) is… 0.237742 + -0.114428 ## [1] 0.123314 In some cases the exact numbers in the summary table will be important, but in most cases I’d report the results from a model like this using just the anova output, plus a nice figure that shows the information in the summary output much more clearly than copying out all these numbers. I might report these results like this (or if I had lots of models I would put the figures into a table). Mass, adult habitat and the interaction between them, were all significantly correlated with eye size (PGLS: \\(\\lambda\\) = 0.976; mass: F = 1084, df = 1, 198, p &lt; 0.001; habitat: F = 11.80, df = 5,198, p &lt; 0.001; interaction: F = 2.938, df = 5,198, p = 0.014; Figure 3). 6.3 Common issues when running PGLS models in R My example data are designed to work easily, but when you use your own data you may come across a couple of common errors. I therefore list these below. 6.3.1 Optim errors Sometimes you will find that pgls will not work and you get an optim error. This generally happens when the lambda profile is really flat, and the model is getting stuck near one of the bounds. To fix this error you need to change the bounds (i.e. upper and lower values) on the parameter being optimized, in this case \\(\\lambda\\). It usually seems to be the lower bound which is the issue. Just change the lower bound of \\(\\lambda\\) to something a little bigger than 1e-6 (the default lower bound) until it works. For example: # Fit PGLS model with a higher lower bound on lambda model.pgls2 &lt;- pgls(log(eyesize) ~ log(mass), data = frog, lambda = &quot;ML&quot;, bounds = list(lambda = c(1e-05, 1))) 6.3.2 Big problems with small datasets You will often find strange \\(\\lambda\\) profiles when you don’t have a lot of species in your data, because \\(\\lambda\\) has very low power to detect phylogenetic signal for less than 20-30 data points (Freckleton, Harvey, and Pagel 2002). This means that using PGLS on small datasets is tricky - you almost always get ML \\(\\lambda\\) of zero but the \\(\\lambda\\) profile will show a pretty flat likelihood surface. Unfortunately people often forget to look at the \\(\\lambda\\) profile so erroneously conclude that there is no phylogenetic autocorrelation in their data. Generally I’d say don’t use small datasets, however, this seems unavoidable in some fields. Therefore my advice is to (only in this situation!) ignore one of Rob Freckleton’s deadly sins (Freckleton 2009) and report the results from a non-phylogenetic lm model (equivalent of PGLS with \\(\\lambda\\) = 0) and also report the results from a PGLS model with \\(\\lambda\\) set to 1 (equivalent to independent contrasts). This is not ideal but it’s the best solution at present if collecting more data is not an option. To set \\(\\lambda\\) to 1 you just replace “ML” with 1 # Fit PGLS model with lambda set to 1 model.pgls3 &lt;- pgls(log(eyesize) ~ log(mass), data = frog, lambda = 1) 6.4 Summary You should now know how to perform a PGLS analysis in R using the package caper. 6.5 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Let’s investigate the relationship between gestation length in Primates and their body size. Theory leads us to believe that bigger mammals have longer gestation lengths (compare mice to elephants), but is this true in Primates? Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit a PGLS model to investigate the relationship between log gestation length (y = log(GestationLen_d)) and log body size (x = log(AdultBodyMass_g)) in Primates. Don’t forget to look at the model diagnostics! Then answer the following questions. What is the maximum likelihood estimate of \\(\\lambda\\) in the model? What are the confidence intervals on the maximum likelihood estimate of \\(\\lambda\\). How would you interpret these? Plot the \\(\\lambda\\) profile for the the maximum likelihood estimate of \\(\\lambda\\). What does it look like? Is there a significant relationship between log gestation length and log body size? What is the slope of this relationship? References "],["phylogenetic-generalised-linear-mixed-models-in-r.html", "Chapter 7 Phylogenetic generalised linear mixed models in R Before you start 7.1 Why fit phylogenetic generalised linear mixed models? 7.2 A really quick reminder of how Bayesian analyses work, with apologies to Bayesian scholars for the simplification! 7.3 Preparation 7.4 MCMCglmm specific preparation 7.5 Other arguments in MCMCglmm 7.6 Fitting the MCMCglmm model 7.7 Did the model converge? 7.8 MCMC outputs 7.9 Extracting lambda for MCMCglmm models 7.10 Checking the effects of priors 7.11 An example using a PGLMM 7.12 Adding extra fixed and random effects 7.13 Summary 7.14 Practical exercises", " Chapter 7 Phylogenetic generalised linear mixed models in R The aims of this exercise are to learn how to use R to perform Phylogenetic Generalised Linear Mixed models (PGLMM)in R using MCMCglmm. We will be using the evolution of eye size in frogs as an example. The data and modified tree come from K. N. Thomas et al. (2020), and the original tree comes from Feng et al. (2017). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out K. N. Thomas et al. (2020)! Before you start Open the 07-MCMCglmm.RProj file in the 07-MCMCglmm folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data ape - functions for reading, plotting and manipulating phylogenies geiger - to fit models of evolution MCMCglmm - to fit GLMMs coda - to assess convergence of MCMC runs 7.1 Why fit phylogenetic generalised linear mixed models? Up this point we have been working with models where our diagnostic plots look pretty good, and where the residuals are roughly normally distributed. Unfortunately this is not the case for all models, especially those with particular kinds of response variables. Where response variables are counts (e.g. number of individuals) we don’t expect normally distributed residuals because counts can only be whole numbers, and cannot go below zero. Instead count data are usually pretty well described by a Poisson distribution instead. Where response variables are binary (e.g. 0 or 1) or proportion data, we also don’t expect to see normally distributed residuals because again these variables cannot be negative, and in the case of binary data cannot be anything other than 0 or 1, and in the case of proportion data can only be between 0 and 1. Binary/proportion data are usually pretty well described by a binomial distribution instead. In your statistics classes you may have heard that the solution in these cases is to fit a generalised linear model, glm in R (rather than just a linear model; lm in R). We need to add this generalised linear modelling framework if we want to use count, or proportion, or binary response variables in our models. Unfortunately, there is not an easy way to extend PGLS to do this, so we need another kind of model. As described in the Primer, there are a number of ways to incorporate phylogenetic information into statistical methods based on a variety of statistical models. We focus on the PGLS model because it’s quite easy to understand how it works, and uses standard models that we (should be) are already familiar with from basic statistics. Another way we can incorporate phylogenetic information into a model is by using a mixed effects model. Mixed effects models have fixed effects, usually the variables we are interested in investigating, and random effects, often “nuisance” variables that we might need to control for in our analysis, or information about the hierarchical nature of the model set up. We can add information about the phlyogeny into the random effects componenet of a mixed effects model. Mixed effects models are very useful, but very hard to fully understand. See the Primer for more details. Luckily, there is a package in R called MCMCglmm that performs generalised linear mixed models (GLMM), i.e. mixed effects models that are generalised to deal with response variables that result in non-normally distributed residuals. This package also allows us to add our phylogenetic information as a random effect in the model. Great! Unfortunately, fitting these models is quite tricky, in part because of the MCMC part of the MCMCglmm package name. MCMC stands for Markov Chain Monte Carlo, and this is a Bayesian method which means it works somewhat differently to the models we’ve met before. I’ll try to explain as we go along, and see the Primer for more details. Bayesian phylogenetic generalised mixed models are very powerful tools, but can be complicated to understand and difficult to use properly. Before jumping in to these it is vital that you have a good understanding of generalised linear models (GLMs), and generalised linear mixed models (GLMMs) including how to fit and interpret the outputs of these models in R. This is beyond the scope of this book. If you feel uncomfortable with these we suggest you go back and learn these methods first. You also need a basic understanding of Bayesian statistics. 7.2 A really quick reminder of how Bayesian analyses work, with apologies to Bayesian scholars for the simplification! Bayesian methods calculate the probability of the model given the data, P(model|data), i.e. the reverse of Maximum Likelihood. To fit Bayesian models we first assign a set of priors. These are our hypotheses about how we think the world works. They provide a starting point for the MCMC algorithm to search model space. I like to think of Bayesian MCMC algorithms as a little robot friend wandering about. The robot starts where the priors suggest it should, then searches the virtual space of all possible model fits to find the parameters for your model (e.g. slopes and intercepts). The first few (hundreds, thousands, sometimes millions depending on the model!) tend to be poor attempts as the robot is still getting oriented, so we exclude these from the output as burnin. The robot keeps going until it’s tried as many models as you asked for (again this can be thousands to millions depending on the model). Because the robot will find very similar results close together due to the nature of the way it searches, we say that the results are autocorrelated. To deal with this, we only sample the results every so often, rather than sampling all of them. This is called thinning and we tell the robot in advance how we want to thin the sample (usually we ask for an answer every couple of thousand attempts). Finally the robot gives us a distribution of results (often thousands or even millions), that we call the posterior distribution (or just the posterior). The posterior is a sample of all possible results across all of models fitted, in proportion to their posterior probability. This means there will be a range of results in the posterior, but those the robot encountered more often will appear more often, and those it encountered rarely will appear less often. Before we look at the results, we need to check that the robot did a good job and converged on a sensible set of results, rather than wandering all over the place like it did during the burnin phase. We generally look at trace plots to assess this (see below) and also calculate Effective Sample Size or ESS. ESS of over 200 suggests the model has converged, and we can then go on to look at our results. This is a simplification of course! But the take home is that to fit MCMCglmm models we need to consider priors, burnin, number of iterations, thinning, convergence and the posterior. In addition to the model, data and phylogeny that we’ve been considering in previous examples… If you want to learn more about Bayesian statistics we highly recommend McElreath (2020) and the accompanying online course. Now let’s try a practical example… 7.3 Preparation To begin we need to load the packages for this practical. # Load the packages library(tidyverse) library(ape) library(geiger) library(MCMCglmm) library(coda) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. Hopefully you’re pretty comfortable with this by now. # Read in the data frogdata &lt;- read_csv(&quot;data/frog-eyes.csv&quot;) # Check everything loaded corrected glimpse(frogdata) ## Rows: 215 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Check it loaded correctly str(frogtree) ## List of 4 ## $ edge : int [1:426, 1:2] 215 216 217 218 219 220 221 222 223 224 ... ## $ edge.length: num [1:426] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 213 ## $ tip.label : chr [1:214] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Check whether the tree is binary # We want this to be TRUE is.binary(frogtree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(frogtree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(frogtree) ## [1] TRUE # Check whether the names match in the data and the tree check &lt;- name.check(phy = frogtree, data = frogdata, data.names = frogdata$tiplabel) # Look at check check ## $tree_not_data ## [1] &quot;Incilius_nebulifer_Bufonidae&quot; &quot;Leptobrachella_bidoupensis_Megophryidae&quot; ## [3] &quot;Microhyla_fissipes_Microhylidae&quot; &quot;Microhyla_marmorata_Microhylidae&quot; ## ## $data_not_tree ## [1] &quot;Gastrophryne_carolinensis_Microhylidae&quot; &quot;Leptobrachella_dringi_Megophryidae&quot; ## [3] &quot;Megophrys_gerti_Megophryidae&quot; &quot;Microhyla_pulverata_Microhylidae&quot; ## [5] &quot;Oreobates_quixensis_Strabomantidae&quot; # Remove species missing from the data mytree &lt;- drop.tip(frogtree, check$tree_not_data) # Remove species missing from the tree matches &lt;- match(frogdata$tiplabel, check$data_not_tree, nomatch = 0) mydata &lt;- subset(frogdata, matches == 0) # Look at the tree summary str(mytree) ## List of 4 ## $ edge : int [1:418, 1:2] 211 212 213 214 215 216 217 218 219 220 ... ## $ edge.length: num [1:418] 0.166 0.114 0.102 0.4 0.133 ... ## $ Nnode : int 209 ## $ tip.label : chr [1:210] &quot;Ascaphus_truei_Ascaphidae&quot; &quot;Leiopelma_hochstetteri_Leiopelmatidae&quot; &quot;Alytes_obstetricans_Alytidae&quot; &quot;Discoglossus_pictus_Alytidae&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Look at the data glimpse(mydata) ## Rows: 210 ## Columns: 11 ## $ Binomial &lt;chr&gt; &quot;Allophryne_ruthveni&quot;, &quot;Eupsophus_roseus&quot;, &quot;Alytes_obstetricans&quot;, &quot;… ## $ Family &lt;chr&gt; &quot;Allophrynidae&quot;, &quot;Alsodidae&quot;, &quot;Alytidae&quot;, &quot;Alytidae&quot;, &quot;Aromobatidae… ## $ Genus &lt;chr&gt; &quot;Allophryne&quot;, &quot;Eupsophus&quot;, &quot;Alytes&quot;, &quot;Discoglossus&quot;, &quot;Allobates&quot;, &quot;… ## $ tiplabel &lt;chr&gt; &quot;Allophryne_ruthveni_Allophrynidae&quot;, &quot;Eupsophus_roseus_Alsodidae&quot;, … ## $ Adult_habitat &lt;chr&gt; &quot;Scansorial&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwellin… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… ## $ SVL &lt;dbl&gt; 23.76667, 38.37500, 37.46667, 62.64000, 25.60000, 27.03333, 38.4000… ## $ mass &lt;dbl&gt; 1.0000000, 7.5000000, 6.6666667, 24.4000000, 2.1000000, 2.4666667, … ## $ rootmass &lt;dbl&gt; 0.9917748, 1.9273451, 1.8690601, 2.8885465, 1.2549697, 1.3507613, 1… ## $ eyesize &lt;dbl&gt; 3.200000, 5.362500, 6.366667, 7.550000, 4.116667, 3.783333, 4.75000… # Convert to a dataframe mydata &lt;- as.data.frame(mydata) # Check this is now a data frame class(mydata) ## [1] &quot;data.frame&quot; 7.4 MCMCglmm specific preparation 7.4.1 Inverse phylogenetic variance-covariance matrix For MCMCglmm we need the inverse of the phylogenetic variance-covariance matrix. To do this, we first need the tree to have no zero-length branches. In 04-Preparation you may recall that we deal with polytomies by replacing them with zero length branches using the ape function multi2di. To remove the zero length branches we are going to use the opposite function: di2multi. This deletes all zero length branches and collapses them back into polytomies. # Remove zero length branches and replace with polytomies mytree2 &lt;- di2multi(mytree) Although not an issue here, inverseA (see below) can break if your tree has node labels. We can remove these using: # Remove node labels mytree2$node.label &lt;- NULL Now we can get the inverse of the phylogenetic variance-covariance matrix using the function inverseA. # Get the inverse vcv matrix for the phylogeny inv.phylo &lt;- inverseA(mytree2, nodes = &quot;TIPS&quot;, scale = TRUE)$Ainv nodes = \"TIPS\" means that we are only including the tips in the calculation. We can use nodes = \"ALL\" to include ancestral nodes in the calculation. scale = TRUE means the tree is scaled so that total branch length from root to tips, is equal to one. This makes the model a bit easier to fit, but only works with ultrametric trees. For non-ultrametric trees you need to set this as FALSE. Using nodes = \"TIPS\" can mean it takes longer for the model to run. Very large phylogenies usually require nodes = \"ALL\" or MCMCglmm won’t even run. However, nodes = \"ALL\" can result in higher auto-correlation (see below). 7.4.2 Priors MCMCglmm requires us to set prior distributions for the fixed and random effects. For the random effects this is actually a bit trickier than many help tutorials might suggest. If you’re fitting any model with any degree of complexity you’ll need to read up on this to get the most appropriate priors (e.g. see http://www.wildanimalmodels.org/tiki-download_wiki_attachment.php?attId=24 for some examples using non-phylogenetic models). The default prior for the fixed effects is a Normal distribution with a mean (mu) of 0 and variance (V) of 1^10. This is known as a diffuse prior, as the variance is so large the prior is basically saying that the fixed effects can be pretty much any number, positive or negative. Generally this is fine so we don’t tend to change this from the default. For the random effects we need to define a set of priors for the variance components of each random effect. MCMCglmm uses something called an inverse Wishart distribution for the random effects prior, and this is described by two parameters: the variance (V) and degree of belief (nu). This distribution tends to be right-skewed when nu is small. The inverse Wishart distribution Often in examples you’ll see people using priors where V = 1 and nu = 0.02. This prior specification is used a lot because it was believed to be relatively uninformative (it is also equivalent to an inverse-gamma prior with shape and scale of 0.001, for anyone more familiar with that distribution). It is generally is fairly uninformative, but can behave inappropriately when the posterior distribution for the variances has support close to zero. In these cases it’s worth looking at the parameter expanded priors section of the MCMCglmm course notes for some solutions. Using priors where V = 1 and nu = 0.02 tells R that it shouldn’t pay too much attention to our prior of V = 1, because our degree of belief is very low (nu = 0.02). This is why we say it is a fairly uniformative prior. Why do we want priors to be uniformative? We don’t always. If we have a pretty good idea of what answer we should get through theory, we might use more informative priors. However, in the analyses we do in most of biology, we don’t have good theory to back them up, so using an uniformative prior means we’re allowing the model to find the best answer without biasing the possible choices. To set up priors for MCMCglmm we use a list, as follows (G is for the random effect(s), and R is for the residual variance): # Set up priors for MCMCglmm # Inverse Wishart with V = 1 and nu = 0.02 # i.e. fairly uninformative priors prior &lt;- list(G = list(G1 = list(V = 1, nu = 0.02)), R = list(V = 1, nu = 0.02)) 7.5 Other arguments in MCMCglmm We also need to decide on a couple of other things before using MCMCglmm. 7.5.1 nitt How many iterations of the model do we want to run? It’s standard to run quite a lot, sometimes in the millions, meaning it can take a really long time to run these models. Note that you don’t need to run millions of iterations if your model converges fairly quickly. Often a good plan is to choose a number of iterations, run the model, check for convergence (see below), then increase the number of iterations if needed. Bayesian analyses often involve a lot of tinkering with parameters, and this can be useful if you have lots of models to run and don’t want to edit for them unnecessarily. # Set number of iterations nitt &lt;- 1000000 7.5.2 burnin The variables nitt, burnin and thin are used to calibrate the MCMCM algorithm. If we set burnin = 1000, nitt = 1,000,000 and thin = 500, it will iterate for 1000 iterations (burnin) before recording samples (to ensure convergence), and then iterate 1,000,000 times. The parameter thin helps us to save memory by saving only every 500th value in this example and thus, dropping highly auto-correlated values. # Set burnin burnin &lt;- 1000 7.5.3 thin # Sampling interval thin &lt;- 500 7.6 Fitting the MCMCglmm model OK now let’s fit a simple model that we’ve looked at before, eye size as a function of body size… To tell MCMCglmm that we want to fit a model with a phylogeny we use random = ~ tiplabel. tiplabel is the name of the column in our dataset that matches the tip labels of the phylogeny. We use ginverse = list(tiplabel = inv.phylo) to tell it to use inv.phylo, the inverse phylogenetic variance-covariance matrix we made above. # Fit MCMCglmm model model_mcmcglmm &lt;- MCMCglmm(log(eyesize) ~ log(mass), data = mydata, random = ~ tiplabel, ginverse = list(tiplabel = inv.phylo), prior = prior, nitt = nitt, thin = thin, burnin = burnin, verbose = TRUE) # Save the model #saveRDS(model_mcmcglmm, file = &quot;data/model_mcmcglmm_output1.rda&quot;) This will take a long time to run, dependent on your computer power. You’ll know it is working because you’ll see text appearing, e.g. MCMC iteration = 1000, every time the MCMC takes a sample for the posterior. You can turn this off with verbose = FALSE if it gets annoying. In fact this takes so long to run (at least an hour on my machine), that to save you some time here I’ve run the model myself and saved it using saveRDS. You do not need to run the code above if you don’t have an hour to spare!. We can then read it back in using: # Read in the saved model output run in advance to save time model_mcmcglmm &lt;- readRDS(&quot;data/model_mcmcglmm_output1.rda&quot;) 7.7 Did the model converge? Before we look at the outputs we need to know if the model converged. If it didn’t you’ll need to fiddle with your parameters and run it again (usually the first thing to try is increasing nitt - this also means you might want to increase burnin and thin too). We can check for convergence in two ways. First we can look at the model diagnostics using plot as we have done for other models in earlier exercises. We can look at the fixed effects first, then the random effects: # Plot model diagnostics for MCMCglmm # For fixed effects plot(model_mcmcglmm$Sol) The plots on the left show a time series of the values of samples of the posterior distribution. The plots on the right show the same data as a distribution. We are looking for a “furry caterpillar” on the left hand plots, suggesting that the values are fluctuating about a largely unchanging mean value of each parameter. On the right hand plots we hope to see a distribution with one clear peak. The rows show the different parameters of the model from the fixed effects component, i.e. the intercept, the slope (labelled as log(mass)). If it doesn’t look like the caterpillar is converging near the start of the plots that suggests you might need to increase the burnin. If there’s still a lot of fluctuation up and down you might need to increase burnin and the number of iterations. If the autocorrelation is high (see below) you might need to increase the thinning interval. # Plot model diagnostics for MCMCglmm # For random effects plot(model_mcmcglmm$VCV) We interpret these in the same way as above except the first row is the random effect that contains the information from the phylogeny, and the second row is the residual variance. This is called units in MCMCglmm. Mean centring and scaling your variables to unit variance. Often people advise that you rescale numeric variables so they are mean centred and scaled to unit variance. This can be really helpful if you’ve got models with multiple numeric variables that are quite different in scale (i.e. one ranges from 1 to 3 and one from 100 to 1000). If your models are not converging this may also help. To do this in R using functions from the tidyverse package: mydata &lt;- mydata %&gt;% mutate(variable1_Z = scale(log(mydata\\(variable1))) %&amp;gt;% mutate(variable2_Z = scale(abs(mydata\\)variable2))) Just remember to reverse the transformation when trying to interpret any parameter estimates on the scale of the original variable. These plots look fine to me! :). Remember because of the nature of MCMC we won’t have the exact same plots here, don’t worry! We can also calculate the effective sample size (ESS) as follows. # Calculate ESS effectiveSize(model_mcmcglmm$Sol[, 1:model_mcmcglmm$Fixed$nfl, drop = FALSE])[[1]] ## [1] 1998 This is above 200 so the model has converged. We should also check the validity of the posterior by looking at levels of autocorrelation… # Look for autocorrelation autocorr(model_mcmcglmm$VCV) ## , , tiplabel ## ## tiplabel units ## Lag 0 1.00000000 -0.526793220 ## Lag 500 -0.01961702 0.001163258 ## Lag 2500 0.02760427 -0.013775871 ## Lag 5000 -0.02899116 0.006129946 ## Lag 25000 -0.01119349 -0.006134928 ## ## , , units ## ## tiplabel units ## Lag 0 -0.5267932199 1.000000000 ## Lag 500 -0.0006145319 -0.003037141 ## Lag 2500 -0.0187737699 -0.016918298 ## Lag 5000 0.0064124393 -0.015999863 ## Lag 25000 -0.0173105728 0.015958313 Ideally, all samples of the posterior distribution should be independent, and the autocorrelation for all lag values greater than zero should be near zero. These values look OK - they’re mostly below 0.03 which is pretty close to zero - but we could try and improve them by increasing the thinning interval and the number of iterations if we needed to. 7.8 MCMC outputs Now we can finally look at the results using summary. # Look at summary of fixed effect results summary(model_mcmcglmm)$solutions ## post.mean l-95% CI u-95% CI eff.samp pMCMC ## (Intercept) 1.0375044 0.7484659 1.2955290 1998.000 0.0005005005 ## log(mass) 0.2768096 0.2581998 0.2955905 3277.781 0.0005005005 This gives us a similar output to the other models we’ve used previously, except the numbers come from the posterior distribution. We get the mean value of the intercept from the posterior, its 95% credible interval (the Bayesian equivalent of confidence intervals), its effective sample size, and an associated p value testing whether the value is signficantly different from zero. The second row shows the same information for the slope (log(mass)). Here neither of the posterior distributions for the intercept or slope overlaps zero, so we can consider them both statistically supported. In a paper/report/thesis we’d report these parameter estimates and their credible intervals. I’d rarely report the MCMCp values. p values don’t really belong in a Bayesian world. Remember we also need to look at results for the random effect variances. Generally the mode of the posterior is a better thing to look at here than the mean of the posterior, as the mode tells us where the peak of the posterior is. We can look at these using posterior.mode. Recall that units is what MCMCglmm calls the residual variance. # Look at G-structure and R-structure posterior modes posterior.mode(model_mcmcglmm$VCV) ## tiplabel units ## 0.11949510 0.00491087 We also need the 95% credible intervals for these components: # Look at G-structure and R-structure 95% credible intervals HPDinterval(model_mcmcglmm$VCV) ## lower upper ## tiplabel 0.095286046 0.16795035 ## units 0.002140634 0.01023753 ## attr(,&quot;Probability&quot;) ## [1] 0.9499499 While testing the significance of fixed effects by evaluating whether or not their posterior distributions overlap zero is simple and valid, this approach does not work for variance components. Variance components should be positive so even when a random effect is not meaningful, the posterior distribution will never overlap zero. If we really care about whether a random effect is “significant”, we can fit a model without the random effect, and a model with the random effect, and then compare them using DIC (smaller DIC = better model). To get the DIC of the model we just do: # Extract DIC model_mcmcglmm$DIC ## [1] -354.1069 If the model with the random effect has the lowest DIC, we can say that inclusion of the term statistically justifiable. DIC has a lot of issues however, and this won’t be appropriate in all cases. Luckily in the case of our phylogenetic random effect we already have a very good reason for including it in the model, whether or not it is “significant”. We can also look at \\(\\lambda\\) to assess the amount of phylogenetic signal in the model. This should give us a good idea of occasions where adding the phylogenetic random effect is not appropriate. 7.9 Extracting lambda for MCMCglmm models We can estimate the posterior probability of the phylogenetic signal \\(\\lambda\\) as follows. # Get lambda lambda &lt;- model_mcmcglmm$VCV[,&#39;tiplabel&#39;]/ (model_mcmcglmm$VCV[,&#39;tiplabel&#39;] + model_mcmcglmm$VCV[,&#39;units&#39;]) We can then get the mean and mode (for Bayesian analyses the mode is often a better measure of central tendency than the mean as it tells us where the peak of the posterior distribution is) of the posterior distribution for \\(\\lambda\\), along with its 95% credible interval: # Posterior mean of lambda mean(lambda) ## [1] 0.9551432 # Posterior mode of lambda posterior.mode(lambda) ## var1 ## 0.9658262 # HPD interval HPDinterval(lambda) ## lower upper ## var1 0.9146033 0.9884231 ## attr(,&quot;Probability&quot;) ## [1] 0.9499499 We could also quickly plot the whole posterior, with the mode and 95% credible intervals. # Plot the posterior ggplot(as.data.frame(lambda), aes(x = lambda))+ geom_density() + geom_vline(xintercept = posterior.mode(lambda), colour = &quot;red&quot;) + geom_vline(xintercept = HPDinterval(lambda)[[1]], linetype = &quot;dotted&quot;, colour = &quot;red&quot;) + geom_vline(xintercept = HPDinterval(lambda)[[2]], linetype = &quot;dotted&quot;, colour = &quot;red&quot;) + theme_bw() Note that this isn’t precisely \\(\\lambda\\) as formulated by Pagel. It’s the proportion of the variance components (G + R) compromised by the phylogenetic variance component (G). But we can interpret it in the same way, i.e. 0 = no phylogenetic signal, 1 = expectation under Brownian motion. The MCMCglmm results are very close to what we got from PGLS where intercept = 1.03, slope = 0.277, and lambda was 0.976 (95% CI: 0.924 - 1). 7.10 Checking the effects of priors You shouldn’t stop here! It’s important to repeat the analysis with different priors to see if that would influence your conclusions. Generally I’d increase the value for nu, maybe to 1 and see what happens. # Set up new priors for MCMCglmm # Inverse Wishart with V = 1 and nu = 1 prior &lt;- list(G = list(G1 = list(V = 1, nu = 1)), R = list(V = 1, nu = 1)) # Run the model model_mcmcglmm2 &lt;- MCMCglmm(log(eyesize) ~ log(mass), data = mydata, random = ~ tiplabel, ginverse = list(tiplabel = inv.phylo), prior = prior, nitt = nitt, thin = thin, burnin = burnin, verbose = FALSE) # Save the model saveRDS(model_mcmcglmm2, file = &quot;data/model_mcmcglmm_output2.rda&quot;) Again this takes ages to run (at least an hour on my machine), so to save you some time here I’ve run the model myself and saved it using saveRDS. You do not need to run the code above if you don’t have an hour to spare!. We can then read it back in using: # Read in the saved model output run in advance to save time model_mcmcglmm2 &lt;- readRDS(&quot;data/model_mcmcglmm_output2.rda&quot;) Let’s look at the results: # Fixed effects results summary(model_mcmcglmm2)$solutions ## post.mean l-95% CI u-95% CI eff.samp pMCMC ## (Intercept) 1.0317751 0.7789332 1.2671116 2097.988 0.0005005005 ## log(mass) 0.2733169 0.2518094 0.2962124 1998.000 0.0005005005 # Look at G-structure and R-structure 95% credible intervals posterior.mode(model_mcmcglmm2$VCV) ## tiplabel units ## 0.09779188 0.02390362 HPDinterval(model_mcmcglmm2$VCV) ## lower upper ## tiplabel 0.06703434 0.12782712 ## units 0.01708881 0.03047269 ## attr(,&quot;Probability&quot;) ## [1] 0.9499499 There’s no major change. Phew! We can therefore say that the difference in the priors has little effect on the outcome of the analysis (this is usual for an analysis where lots of data are available relative to the complexity of the model, but it is important to check!). Hopefully you now see why these models are complicated and should be considered very carefully before using them. You should never skip the checking and tinkering steps. 7.11 An example using a PGLMM A reminder. Before jumping in to these models it is vital that you have a good understanding of generalised linear models (GLMs), and generalised linear mixed models (GLMMs) including how to fit and interpret the outputs of these models in R. This is beyond the scope of this book. If you feel uncomfortable with these we suggest you go back and learn these methods first. The example above is technically only a LMM (linear mixed model) as we used a model with Gaussian or Normal errors. But what if our response is a count? Or a proportion? We can then use the GLMM architecture of MCMCglmm to help. For Poisson models (used generally when the response variable is a count) we actually only need to change one thing, we need to add family = \"poisson\" to tell MCMCglmm to fit this model. This is the same as in standard glm analyses in R. Make sure you understand GLMs before attempting PGLMMs! For a fake example here, if we had a variable called number_of_eggs that contained count data, we could fit a model like this: model_eggs &lt;- MCMCglmm(number_of_eggs ~ log(mass), data = mydata, family = &quot;poisson&quot;, random = ~ Species, ginverse = list(Species = inv.phylo), prior = prior, nitt = nitt, thin = thin, burnin = burnin, verbose = FALSE) Other than these changes, everything runs as above including the priors and all the model diagnostics and checking. If we had proportion data instead, for example the number of individuals with blue eyes and the number with red eyes, we could use a binomial model. Again this works just like in a basic glm model. Again, make sure you understand GLMs before attempting PGLMMs! We tell R we want to use a binomial error structure using family = \"binomial\", and we include successes (number of frogs with red eyes) and failures (number of frogs with blue eyes) as one variable as the response using cbind to stick them together. If you’re not sure why we would do this, go back and read up on GLMs. # Fit MCMCglmm model_eyes &lt;- MCMCglmm(cbind(numberred, numberblue) ~ log(mass), data = mydata, family = &quot;binomial&quot;, random = ~ Species, ginverse = list(Species = inv.phylo), prior = prior, nitt = nitt, thin = thin, burnin = burnin, verbose = FALSE) Again, other than these changes, everything runs as above including the priors and all the model diagnostics and checking. Remember the parameter estimates for binomial GLMs are log odds ratios, so might look a little strange. Again, go back and read up on GLMs if this is all sounding unfamiliar to you. If you’re worried about whether you’ve fitted the right model, and the additional Bayesian components of MCMCglmm are causing you confusion, it’s fine to fit the model using a standard GLM (using the glm function in R) to see if the results are similar. Remember that we expect the results to be somewhat different because glm does not incorporate the phylogeny. 7.12 Adding extra fixed and random effects I won’t run these models here; this is just to give you an indication of how we can add complexity to these models. Adding fixed effects to models is easy, we just add variables as we would in any other model in R. For example, if we wanted to fit this model from the PGLS exercise: model.pgls2 &lt;- pgls(log(eyesize) ~ log(mass) * as.factor(Adult_habitat), data = frog, lambda = &quot;ML&quot;) We could fit a MCMCglmm model like this: model_multiple&lt;- model_mcmcglmm &lt;- MCMCglmm(log(eyesize) ~ log(mass) * as.factor(Adult_habitat), data = mydata, random = ~ Species, ginverse = list(Species = inv.phylo), prior = prior, nitt = nitt, thin = thin, burnin = burnin) Note that we are adding fixed effects in this example. If we want to add more random effects we need to be a bit more careful because we need to remember to define the priors for those random effects too. Let’s say we wanted to fit a model with phylogeny as a random effect and a random effect of Sex. We’d now have two random effects in the G-structure. We would define the priors as follows. Note that Sex is referred to as G2. prior2 &lt;- list(G = list(G1 = list(V = 1, n = 0.002), G2 = list(V = 1, n = 0.002)), R = list(V = 1, n = 0.002)) We’d then fit the model as follows. model_new &lt;- model_mcmcglmm &lt;- MCMCglmm(log(eyesize) ~ log(mass), data = mydata, random = ~ Species + Sex, ginverse = list(Species = inv.phylo), prior = prior2, nitt = nitt, thin = thin, burnin = burnin) Note that this gets more complex if you want to fit hierarchical or repeated measures type models so we recommend reading the materials below, and getting a thorough understanding of mixed models, before attempting this. 7.13 Summary You should now know how to perform a GLMM analysis in R using the package MCMCglmm. I also recommend reading the following if you want to know more: http://www.wildanimalmodels.org/tiki-download_wiki_attachment.php?attId=24 https://cran.r-project.org/web/packages/MCMCglmm/vignettes/CourseNotes.pdf 7.14 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Let’s repeat the analyses we did in the PGLS chapter but using MCMCglmm. We will investigate the relationship between gestation length in Primates and their body size. Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit a MCMCglmm model to investigate the relationship between log gestation length (y = log(GestationLen_d)) and log body size (x = log(AdultBodyMass_g)) in Primates. Don’t forget to check that the model has converged, and to look at the model diagnostics and for autocorrelation. Then answer the following questions. What is \\(\\lambda\\) in the model? What are the 95% credible intervals (HPD) around \\(\\lambda\\)? Plot the \\(\\lambda\\) profile for the the maximum likelihood estimate of \\(\\lambda\\). Is there a significant relationship between log gestation length and log body size? What is the slope of this relationship? References "],["macroevolutionary-models-for-continuous-traits.html", "Chapter 8 Macroevolutionary models for continuous traits Before you start 8.1 Preparation 8.2 Models of evolution for continuous traits 8.3 Summary 8.4 Practical exercises", " Chapter 8 Macroevolutionary models for continuous traits The aims of this exercise are to learn how to use R to fit macroevolutionary models in R to continuous traits. We will be using the evolution of head shape in natricine snakes as an example. The data and modified tree come from V. Deepak, Gower, and Cooper (2023), and the tree comes from V. Deepak et al. (2021). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out V. Deepak, Gower, and Cooper (2023)! Before you start Open the 08-ModelsContinuous.RProj file in the 08-ModelsContinuous folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data ape - functions for reading, plotting and manipulating phylogenies geiger - to fit models of evolution patchwork - to plot multi-panel plots 8.1 Preparation To begin we need to load the packages for this practical. # Load the packages library(tidyverse) library(ape) library(geiger) library(patchwork) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data snakedata &lt;- read_csv(&quot;data/snake-heads.csv&quot;) # Check everything loaded corrected glimpse(snakedata) ## Rows: 206 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Amphiesma_beddomei&quot;, &quot;… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;anurans&quot;, &quot;generalist… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 19.950, 18.810, 16.375, 22.640, 17.… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 10.32, 9.82, 8.39, 11.30, 9.04, 9.55, 4.49… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 7.56, 5.80, 6.40, 8.70, 5.68, 6.64, 4.19, … ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.84, 5.42, 6.00, 6.05, 5.01, 6.39, 3.12, 3… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 165, 155, NA, 163, 130, 309, 31, 62, 56, 35, 16… To load the tree we will use read.nexus. # Read in the tree snaketree &lt;- read.nexus(&quot;data/snake-tree.nex&quot;) # Check it loaded correctly str(snaketree) ## List of 4 ## $ edge : int [1:496, 1:2] 250 251 252 253 254 255 256 257 258 259 ... ## $ edge.length: num [1:496] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 248 ## $ tip.label : chr [1:249] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_1&quot; &quot;Rhabdophis_nuchalis_2&quot; &quot;Rhabdophis_adleri_1&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary(snaketree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(snaketree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(snaketree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. Note that in this dataset the species names are in the column Species. # Check whether the names match in the data and the tree check &lt;- name.check(phy = snaketree, data = snakedata, data.names = snakedata$Species) # Look at check check ## $tree_not_data ## [1] &quot;Afronatrix_anoscopus_1&quot; &quot;Afronatrix_anoscopus_3&quot; ## [3] &quot;Aspidura_ravani&quot; &quot;Atretium_schistosum_1&quot; ## [5] &quot;Blythia_hmuifang&quot; &quot;Fowlea_piscator_1&quot; ## [7] &quot;Fowlea_piscator_3&quot; &quot;Fowlea_piscator_4&quot; ## [9] &quot;Hebius_andreae&quot; &quot;Hebius_atemporale_2&quot; ## [11] &quot;Hebius_atemporale_3&quot; &quot;Hebius_atemporale_4&quot; ## [13] &quot;Hebius_bitaeniatum_1&quot; &quot;Hebius_bitaeniatum_2&quot; ## [15] &quot;Hebius_bitaeniatum_3&quot; &quot;Hebius_boulengeri_1&quot; ## [17] &quot;Hebius_cf._boulengeri&quot; &quot;Hebius_concelarum&quot; ## [19] &quot;Hebius_craspedogaster_1&quot; &quot;Hebius_craspedogaster_3&quot; ## [21] &quot;Hebius_deschauenseei_1&quot; &quot;Hebius_deschauenseei_2&quot; ## [23] &quot;Hebius_ishigakiensis&quot; &quot;Hebius_khasiense_2&quot; ## [25] &quot;Hebius_khasiense_3&quot; &quot;Hebius_leucomystax&quot; ## [27] &quot;Hebius_octolineatum_1&quot; &quot;Hebius_octolineatum_2&quot; ## [29] &quot;Hebius_optatum_2&quot; &quot;Hebius_popei_1&quot; ## [31] &quot;Hebius_pryeri_1&quot; &quot;Hebius_sangzhiensis&quot; ## [33] &quot;Hebius_sauteri_2&quot; &quot;Hebius_sp&quot; ## [35] &quot;Hebius_sp1&quot; &quot;Hebius_sp2&quot; ## [37] &quot;Hebius_sp4&quot; &quot;Hebius_taronense&quot; ## [39] &quot;Hebius_venningi_1&quot; &quot;Hebius_venningi_3&quot; ## [41] &quot;Hebius_venningi_4&quot; &quot;Hebius_yanbianensis&quot; ## [43] &quot;Herpetoreas_burbrinki&quot; &quot;Limnophis_branchi&quot; ## [45] &quot;Natriciteres_olivacea_2&quot; &quot;Natriciteres_sylvatica_2&quot; ## [47] &quot;Natriciteres_sylvatica_3&quot; &quot;Natrix_helvatica&quot; ## [49] &quot;Natrix_tessellata_1&quot; &quot;Opisthotropis_cheni&quot; ## [51] &quot;Opisthotropis_daovantieni&quot; &quot;Opisthotropis_durandi&quot; ## [53] &quot;Opisthotropis_guangxiensis&quot; &quot;Opisthotropis_haihaensis&quot; ## [55] &quot;Opisthotropis_hungtai&quot; &quot;Opisthotropis_kuatunensis&quot; ## [57] &quot;Opisthotropis_laui&quot; &quot;Opisthotropis_maculosa&quot; ## [59] &quot;Opisthotropis_maxwelli&quot; &quot;Opisthotropis_shenzhenensis&quot; ## [61] &quot;Opisthotropis_voquyi&quot; &quot;Opisthotropis_zhaoermii&quot; ## [63] &quot;Rhabdophis_adleri_1&quot; &quot;Rhabdophis_adleri_2&quot; ## [65] &quot;Rhabdophis_callichromus&quot; &quot;Rhabdophis_formosanus&quot; ## [67] &quot;Rhabdophis_guangdongensis&quot; &quot;Rhabdophis_nuchalis_1&quot; ## [69] &quot;Rhabdophis_nuchalis_2&quot; &quot;Rhabdophis_nuchalis_pentasupralabialis&quot; ## [71] &quot;Rhabdophis_pentasupralabialis&quot; &quot;Rhabdophis_swinhonis_2&quot; ## [73] &quot;Thamnophis_exsul_1&quot; &quot;Thamnophis_gigas&quot; ## [75] &quot;Thamnophis_mendax&quot; &quot;Thamnophis_nigronuchalis&quot; ## [77] &quot;Thamnophis_ordinoides&quot; &quot;Thamnophis_scalaris_1&quot; ## [79] &quot;Thamnophis_scaliger_2&quot; &quot;Trachischium_apteii&quot; ## [81] &quot;Trachischium_monticola_2&quot; &quot;Trimerodytes_praemaxillaris&quot; ## [83] &quot;Trimerodytes_yapingi&quot; &quot;Tropidonophis_dahlii&quot; ## [85] &quot;Tropidonophis_dendrophiops&quot; &quot;Tropidonophis_multiscutellatus_2&quot; ## [87] &quot;Tropidonophis_statisticus_2&quot; ## ## $data_not_tree ## [1] &quot;Amphiesma_stolatum&quot; &quot;Amphiesma_stolatum_WII&quot; ## [3] &quot;Aspidura_brachyorrhos&quot; &quot;Aspidura_copei&quot; ## [5] &quot;Fowlea_flavipunctatus&quot; &quot;Fowlea_melanzostus&quot; ## [7] &quot;Hebius_bitaeniatum_4&quot; &quot;Hebius_celabicus&quot; ## [9] &quot;Hebius_clerki&quot; &quot;Hebius_flavifrons&quot; ## [11] &quot;Hebius_groundwateri&quot; &quot;Hebius_inas&quot; ## [13] &quot;Hebius_petersi&quot; &quot;Hebius_sanguinea&quot; ## [15] &quot;Hebius_sarasinorum&quot; &quot;Hebius_sarawacensis&quot; ## [17] &quot;Hebius_vibakari_2&quot; &quot;Hebius_vibakari_ruthveni&quot; ## [19] &quot;Herpetoreas_sieboldi&quot; &quot;Hydrablabes_periops&quot; ## [21] &quot;Hydrablabes_prafrontalis&quot; &quot;Hydraethiops_laevis&quot; ## [23] &quot;Isanophis_boonsongi&quot; &quot;Opisthotropis_spenceri&quot; ## [25] &quot;Paratapinophis_praemaxillaris&quot; &quot;R_lineatus&quot; ## [27] &quot;Rhabdophis_barbouri&quot; &quot;Rhabdophis_chrysargoides&quot; ## [29] &quot;Rhabdophis_chrysargos&quot; &quot;Smithophis_sp&quot; ## [31] &quot;Storeria_hidalgoensis&quot; &quot;Thamnophis_elegans_lineolata&quot; ## [33] &quot;Thamnophis_rossmani&quot; &quot;Thamnophis_rufipunctatus_unilabialis&quot; ## [35] &quot;Trachischium_susantai&quot; &quot;Tropidonophis_celebicus&quot; ## [37] &quot;Tropidonophis_elongatus&quot; &quot;Tropidonophis_halmahericus&quot; ## [39] &quot;Tropidonophis_hypomelas&quot; &quot;Tropidonophis_mairii_brongersmai&quot; ## [41] &quot;Tropidonophis_mcdowelli&quot; &quot;Tropidonophis_novaeguinea&quot; ## [43] &quot;Tropidonophis_parkeri&quot; &quot;Tropidonophis_truncatus&quot; There are a lot of species in the tree that are not in the data (n = 87) and vice versa (n = 44)! But (you’ll have to take my word for it!) all the excluded species are excluded because they are genuinely missing, not because of any typos, so we can move on. Having a lot of species missing from trees and data is not uncommon. To build trees we usually need molecular data which may be absent for newly collected specimens, or for older specimens. Likewise, it can be really difficult to gather all the data required for all of the species in a group - we know very little about the natural history of some species for example. This is nothing to panic about in your own datasets, but knowing which species are in the tree could help you target species to collate extra data for. Finally remove species not in the data and the tree and ensure the data is a data frame. # Remove species missing from the data mytree &lt;- drop.tip(snaketree, check$tree_not_data) # Remove species missing from the tree matches &lt;- match(snakedata$Species, check$data_not_tree, nomatch = 0) mydata &lt;- subset(snakedata, matches == 0) # Look at the tree summary str(mytree) ## List of 4 ## $ edge : int [1:322, 1:2] 163 164 165 166 167 168 169 170 171 172 ... ## $ edge.length: num [1:322] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 161 ## $ tip.label : chr [1:162] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; &quot;Rhabdophis_nigrocinctus&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Look at the data glimpse(mydata) ## Rows: 162 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Amphiesma_beddomei&quot;, &quot;… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;anurans&quot;, &quot;generalist… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 18.810, 16.375, 22.640, 19.760, 10.… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 9.82, 8.39, 11.30, 9.55, 4.03, 4.90, 3.44,… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 5.80, 6.40, 8.70, 6.64, 3.24, 4.41, 3.12, … ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.42, 6.00, 6.05, 6.39, 3.34, 2.27, 1.70, 3… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 155, NA, 163, 309, 62, 35, 16, 23, NA, 33, 81, … # Convert to a dataframe mydata &lt;- as.data.frame(mydata) # Check this is now a data frame class(mydata) ## [1] &quot;data.frame&quot; Overall we have 162 species in the data and the tree. Now we’re ready to run our analyses! 8.2 Models of evolution for continuous traits For fitting models of evolution to continuous data we will use the fitContinuous function in the R package geiger. fitContinuous is a likelihood based method, so the output will give the maximum likelihood (ML) estimates of the parameters. Bayesian methods are becoming preferred for these kinds of analyses and fitContinuousMCMC will perform these analyses, but I’m not going to cover it here. As an example, let’s look at the evolution of head length in our snake data. Snake head shape is closely related to the ecology of the species, so we are interested in understanding how it evolves. These first analyses are quite simple, but would be the first step in a more detailed analysis. 8.2.1 Look at the data It’s always a good idea to take a quick look at the data before we start analyses. Here we’re going to focus on the HeadLength variable. Let’s plot it. Note that we generally log transform continuous variables so we can look at rates of change rather than absolute change, so let’s plot the log transformed data too. Recall that log in R gives the natural log. p1 &lt;- ggplot(mydata, aes(x = HeadLength)) + geom_histogram(bins = 20, fill = &quot;darkblue&quot;) + theme_bw(base_size = 14) p2 &lt;- ggplot(mydata, aes(x = log(HeadLength))) + geom_histogram(bins = 20, fill = &quot;orangered&quot;) + theme_bw(base_size = 14) p1 + p2 8.2.2 Fitting the Brownian motion and OU models of evolution using fitContinuous We’ll fit two commonly used evolutionary models to the data; the Brownian motion (BM) model and the single peak Ornstein-Uhlenbeck (OU) model. As a quick reminder, the BM model is a so called “random walk” model where traits change gradually through time. The model has two parameters, the Brownian rate parameter, \\(\\sigma^2\\) and the state of the root at time zero, \\(z(0)\\). The OU model is a random walk where trait values are pulled back towards some “optimal” value with an attraction strength proportional to the “rubber-band” parameter \\(\\alpha\\). The OU model has four parameters the Brownian rate parameter, \\(\\sigma^2\\), the state of the root at time zero, \\(z(0)\\), the long-term mean, \\(\\mu\\), and the strength of evolutionary force that returns traits back towards the long-term mean if they evolve away from it, \\(\\alpha\\). If \\(\\alpha\\) is close to zero then evolution is approximately Brownian. For more details on these models please see the Primer. fitContinuous can also fit several other models. For more details look at the help file by typing: ?fitContinuous We are going to use the package geiger to fit models in this exercise, which means there is an important additional preparation step that you may remember from when we used the package phytools and the function phylosig when were looking at phylogenetic signal in 05-PhyloSignal. At this point you may be thinking, argh why can’t all R packages work in the same way? This is because different packages were written by different people. We all have different programming styles, preferences and biases (some people really hate the tidyverse and ggplot2 for example!) and these feed into the code we write. My advice is to follow these tutorials (and others) carefully, and don’t worry about the differences too much. To put a positive spin on this, yes there may be lots of different ways to do things in R but at least they exist! In the recent past people published methods without the accompanying R packages. If you were lucky you might get some FORTRAN or C++ or C code, but generally you’d be expected to program the new methods yourself if you wanted to use them. Dealing with the idiosyncrasies of different people’s R packages is a breeze compared to that! The first thing we need to do is to create an object in R that only contains the variable required, and the species names (so we can match it up to the tree). We can use the function pull to extract just the head length values, and we can log transform all these numbers using log if we want to work with log head length values. # Create logHL containing just log head length length values logHL &lt;- log(pull(mydata, HeadLength)) # Look at the first few rows head(logHL) ## [1] 2.530517 3.222868 2.712042 3.000969 2.934389 2.795756 Notice that this is currently just a long list of numbers. We can then name these values with the species names from mydata using the function names. Note that this requires the trait data is in the same order as the tree tip labels so we need to reorder the data first… # Check first few tip labels and species mytree$tip.label[1:5] ## [1] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; ## [4] &quot;Rhabdophis_nigrocinctus&quot; &quot;Rhabdophis_tigrinus&quot; mydata$Species[1:5] ## [1] &quot;Adelophis_foxi&quot; &quot;Afronatrix_anoscopus_2&quot; &quot;Amphiesma_beddomei&quot; ## [4] &quot;Amphiesma_monticola&quot; &quot;Amphiesma_stolatum_1&quot; # These are different so we reorder the data by the tips mydata &lt;- mydata[match(mytree$tip.label, mydata$Species), ] # Check this now matches the tip label order mydata$Species[1:5] ## [1] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; ## [4] &quot;Rhabdophis_nigrocinctus&quot; &quot;Rhabdophis_tigrinus&quot; # Give log head length names = species names at the tips of the phylogeny names(logHL) &lt;- mydata$Species # Look at the first few rows head(logHL) ## Rhabdophis_leonardi Rhabdophis_nuchalis_3 Rhabdophis_swinhonis_1 ## 2.530517 3.222868 2.712042 ## Rhabdophis_nigrocinctus Rhabdophis_tigrinus Rhabdophis_tigrinus_lateralis ## 3.000969 2.934389 2.795756 Now we have a list of values with associated species names. To fit the Brownian model we can then use the code below. BM &lt;- fitContinuous(mytree, logHL, model = c(&quot;BM&quot;)) To look at the output type: BM ## GEIGER-fitted comparative model of continuous data ## fitted &#39;BM&#39; model parameters: ## sigsq = 0.059709 ## z0 = 3.003849 ## ## model summary: ## log-likelihood = -191.927134 ## AIC = 387.854268 ## AICc = 387.929740 ## free parameters = 2 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 100 ## frequency of best fit = 1.00 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates The maximum likelihood estimates of the model parameters are found near the top of the output. In a Brownian motion (BM) model we estimate the Brownian rate parameter, \\(\\sigma^2\\) or sigsq in the output above, which is 0.037 and the value of the trait at the root of the tree, \\(z(0)\\) or z0 in the output above, which is 2.854. Other useful things in the output are the maximum-likelihood estimate of the model (log-likelihood), the Akaike Information Criterion (AIC), sample-size corrected AIC (AICc) and the number of model parameters (free parameters) also known as \\(k\\) in the literature. We will return to the AIC values below. To fit an Ornstein-Uhlenbeck model we only need to change the model in the formula we used above: OU &lt;- fitContinuous(mytree, logHL, model = c(&quot;OU&quot;)) ## Warning in fitContinuous(mytree, logHL, model = c(&quot;OU&quot;)): ## Parameter estimates appear at bounds: ## alpha This gives us a warning message (it doesn’t say Error so it’s not an error message). This means the analysis has run, but there’s something we should be aware of. This warning is telling us something about the bounds of the parameter estimates, specifically the alpha or “rubber-band” parameter. What’s the deal with bounds? These BM and OU models are fitted using Maximum Likelihood. We talk more about this in the Primer. But as a quick reminder, to get the Maximum Likelihood for a model, we need to find the values of the parameters that maximise the likelihood function. Rather than trying every possible combination of parameter values we instead use some kind of optimisation procedure. Optimisations are often described in terms of hills and valleys. If you’re in the mountains looking for the highest peak, you could wander around the whole area, recording the height at each point, or we can make the process faster by always walking towards higher ground. If we did this we’d spend less time in the valleys and more time climbing towards the highest peaks. This is optimisation. To prevent us from spending lots of time looking in the wrong place, we could also define the boundaries of our search area, so we only look within a certain region. Our models do this by having bounds on the parameter values. So, for example, instead of looking at models with all possible values of \\(\\alpha\\) in an OU model, fitContinuous constrains the values of \\(\\alpha\\) to be between exp(-500) and exp(1). To fix this issue we just change the bounds and refit the model. If you check out the help file for fitContinuous it tells us: Default bounds are alpha = c(min = exp(-500), max = exp(1)) We can see what the value of alpha was in the model we fitted as follows: OU$opt$alpha ## [1] 2.718282 This is the same as exp(1). So alpha is the same as the upper bound, meaning that is the bound we need to change. We can do that as follows: OU &lt;- fitContinuous(mytree, logHL, model = c(&quot;OU&quot;), bounds = list(alpha = c(exp(-500), 10))) ## Warning in fitContinuous(mytree, logHL, model = c(&quot;OU&quot;), bounds = list(alpha = c(exp(-500), : ## Parameter estimates appear at bounds: ## alpha We don’t get any kind of message this time so it looks like we fixed the problem! To look at the output type: OU ## GEIGER-fitted comparative model of continuous data ## fitted &#39;OU&#39; model parameters: ## alpha = 10.000000 ## sigsq = 2.788514 ## z0 = 2.967816 ## ## model summary: ## log-likelihood = -69.334126 ## AIC = 144.668252 ## AICc = 144.820151 ## free parameters = 3 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 27 ## frequency of best fit = 0.27 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates As for Brownian motion, the maximum likelihood estimates of the model parameters are found near the top of the output. In an Ornstein-Uhlenbeck (OU) model we estimate the Brownian rate parameter, \\(\\sigma^2\\) or sigsq in the output above, the value of the trait at the root of the tree, \\(z(0)\\) or z0 in the output above, and the “rubber-band” parameter, \\(\\alpha\\) or alpha in the output above. As alpha = 9.014 here, it suggests that there is evolution towards a particular head length. I mentioned above that the OU model has four parameters, \\(\\sigma^2\\), \\(z(0)\\), \\(\\mu\\) and \\(\\alpha\\). But only three appear on the output above. This is because fitContinuous only estimates \\(\\sigma^2\\), \\(z(0)\\), and \\(\\alpha\\). It does not estimate \\(\\mu\\) but in this implementation of the model, \\(\\mu\\) is equivalent to \\(X(0)\\). Sometimes these models will tell you they have not converged. This just means the model has failed to find the optimal values for the parameters. This is most common in the OU model, and tends to happen when the likelihood surface for the parameter has long flat ridges that cause the likelihood search to get “stuck” and unable to find the peak (in our mountain climbing analogy it’s like getting stuck in a massive flat valley when it’s foggy and you can’t see the mountains around you to work out how to get to higher ground). If this happens, try changing the bounds on the alpha parameter. Moving the lower bound away from zero can help, as can increasing the upper bound. 8.2.3 Comparing models of evolution using AIC Often we want to know which of the models fits our variable best. We can use fitContinuous to fit the models we are interested in and can then compare them using AIC. We can extract the AICs from the models we fitted above as follows: BM$opt$aic ## [1] 387.8543 OU$opt$aic ## [1] 144.6683 The “best” model is the one with the smallest AIC, in this case the OU model. There is much debate about how big of a difference in AIC values can be classed as substantial improvement to a model fit (it usually ranges from 2-10 AIC units). Generally we use 4 units, so OU fits this data substantially better than BM. Alternatively we can use \\(\\Delta\\)AIC or AIC weights to compare our models using the following code and the geiger function aicw: aic.scores &lt;- setNames(c(BM$opt$aic, OU$opt$aic), c(&quot;BM&quot;,&quot;OU&quot;)) aicw(aic.scores) ## fit delta w ## BM 387.8543 243.186 1.558934e-53 ## OU 144.6683 0.000 1.000000e+00 aicw outputs the AIC (fit), \\(\\Delta\\)AIC (delta) and AIC weights (w) for each of the models we fitted. The best model is the model with \\(\\Delta\\)AIC = 0 or with AICw closest to 1. Using \\(\\Delta\\)AIC we can conclude that the OU model is the best fit to the data. 8.3 Summary You should now know how to fit simple BM and OU models of evolution to continuous trait data in R. 8.4 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit Brownian and OU models to log adult body mass for Primates (AdultBodyMass_g). Then answer the following questions. Which model fits best? What is the rate of evolution for the Brownian model? What is the strength of pull towards the long-term mean in the OU model? What does this value suggest? References "],["macroevolutionary-models-for-discrete-traits.html", "Chapter 9 Macroevolutionary models for discrete traits Before you start 9.1 Preparation 9.2 Models of evolution for discrete traits 9.3 Ancestral state estimations 9.4 Summary 9.5 Practical exercises", " Chapter 9 Macroevolutionary models for discrete traits The aims of this exercise are to learn how to use R to fit macroevolutionary models in R to discrete traits. We will be using the evolution of head shape in natricine snakes as an example. The data and modified tree come from V. Deepak, Gower, and Cooper (2023), and the tree comes from V. Deepak et al. (2021). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out V. Deepak, Gower, and Cooper (2023)! Before you start Open the 09-ModelsDiscrete.RProj file in the 09-ModelsDiscrete folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data ape - functions for reading, plotting and manipulating phylogenies geiger - to fit models of evolution phytools - for plots of transition rates 9.1 Preparation To begin we need to load the packages for this practical. # Load the packages library(tidyverse) library(ape) library(geiger) library(phytools) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data snakedata &lt;- read_csv(&quot;data/snake-heads.csv&quot;) # Check everything loaded corrected glimpse(snakedata) ## Rows: 206 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Amphiesma_beddomei&quot;, &quot;… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;anurans&quot;, &quot;generalist… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 19.950, 18.810, 16.375, 22.640, 17.… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 10.32, 9.82, 8.39, 11.30, 9.04, 9.55, 4.49… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 7.56, 5.80, 6.40, 8.70, 5.68, 6.64, 4.19, … ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.84, 5.42, 6.00, 6.05, 5.01, 6.39, 3.12, 3… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 165, 155, NA, 163, 130, 309, 31, 62, 56, 35, 16… To load the tree we will use read.nexus. # Read in the tree snaketree &lt;- read.nexus(&quot;data/snake-tree.nex&quot;) # Check it loaded correctly str(snaketree) ## List of 4 ## $ edge : int [1:496, 1:2] 250 251 252 253 254 255 256 257 258 259 ... ## $ edge.length: num [1:496] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 248 ## $ tip.label : chr [1:249] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_1&quot; &quot;Rhabdophis_nuchalis_2&quot; &quot;Rhabdophis_adleri_1&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary(snaketree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(snaketree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(snaketree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. I haven’t printed check here as we already did this in the previous exercise and it’s a long list but we have already checked these in advance. Do not skip this step for your own analyses! # Check whether the names match in the data and the tree check &lt;- name.check(phy = snaketree, data = snakedata, data.names = snakedata$Species) # check Finally remove species that are not in the tree and the data and ensure the data is a data frame. # Remove species missing from the data mytree &lt;- drop.tip(snaketree, check$tree_not_data) # Remove species missing from the tree matches &lt;- match(snakedata$Species, check$data_not_tree, nomatch = 0) mydata &lt;- subset(snakedata, matches == 0) # Look at the tree summary str(mytree) ## List of 4 ## $ edge : int [1:322, 1:2] 163 164 165 166 167 168 169 170 171 172 ... ## $ edge.length: num [1:322] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 161 ## $ tip.label : chr [1:162] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; &quot;Rhabdophis_nigrocinctus&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Look at the data glimpse(mydata) ## Rows: 162 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Amphiesma_beddomei&quot;, &quot;… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;anurans&quot;, &quot;generalist… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 18.810, 16.375, 22.640, 19.760, 10.… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 9.82, 8.39, 11.30, 9.55, 4.03, 4.90, 3.44,… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 5.80, 6.40, 8.70, 6.64, 3.24, 4.41, 3.12, … ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.42, 6.00, 6.05, 6.39, 3.34, 2.27, 1.70, 3… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 155, NA, 163, 309, 62, 35, 16, 23, NA, 33, 81, … # Convert to a dataframe mydata &lt;- as.data.frame(mydata) # Check this is now a data frame class(mydata) ## [1] &quot;data.frame&quot; Overall we have 162 species in the data and the tree. Now we’re ready to run our analyses! 9.2 Models of evolution for discrete traits For fitting simple models of evolution to discrete data we will use the fitDiscrete function in the R package geiger. fitDiscrete is a likelihood based method, so the output will give the maximum likelihood (ML) estimates of the parameters. As an example, let’s look at the evolution of ecomorphs in our snake data. Before we start let’s make sure we have an idea of what these data look like. # How many species are in each category of ecomorph? mydata %&gt;% group_by(Ecomorph) %&gt;% summarise(number = n()) ## # A tibble: 5 × 2 ## Ecomorph number ## &lt;chr&gt; &lt;int&gt; ## 1 Aquatic 43 ## 2 Aquatic Burrowing 11 ## 3 Burrowing 17 ## 4 Semiaquatic 54 ## 5 Terrestrial 37 We can also visualize these variables on our tree by plotting them with colours. We’ll then create a vector of five colours for the ecomorphs. These need to be in alphabetical order, so the colours should be in the order Aquatic, Aquatic burrower, Burrower, Semi-aquatic, Terrestrial. # Set up list of colours ecomorph.colors &lt;- c(&quot;darkblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightblue&quot;, &quot;lightgreen&quot;) We then need to make sure the variable Ecomorph is a factor rather than a character as R deals with these differently and we need it to be a factor for the next bit of code to work. We can do this using the function as.factor and we can change it in mydata usign the tidyverse function mutate. # Make Ecomorph a factor mydata &lt;- mydata %&gt;% mutate(Ecomorph = as.factor(Ecomorph)) Finally we can plot the tree with coloured tip labels to match the ecomorphs. I’ve rearranged the colour order in the legend so it makes more sense biologically (i.e. putting the aquatic and semi-aquatic next to each other rather than ordering it alphabetically). To make things a bit easier to read I’ve left off the tip labels. I’ve done this using ape plotting functions but you can also do this using ggtree. # Plot the tree with colours at the tips to represent ecomorph plot(mytree, cex = 0.5, adj = c(0.2), type = &quot;fan&quot;, no.margin = TRUE, show.tip.label = FALSE) tiplabels(pch = 16, col = ecomorph.colors[mydata$Ecomorph]) legend(&quot;bottomleft&quot;, pch = 15, bty = &quot;n&quot;, legend = c(&quot;Aquatic&quot;, &quot;Semi-aquatic&quot;, &quot;Aquatic burrower&quot;, &quot;Burrower&quot;, &quot;Terrestrial&quot;), col = c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightgreen&quot;)) Some ecomorphs are clustered, but others appear across the phylogeny (this is the result of some pretty cool convergent evolution - check out V. Deepak, Gower, and Cooper (2023) for more details). 9.2.1 Fitting the ER, SYM and ARD models of evolution using fitDiscrete We’ll fit three commonly used evolutionary models to the data; the equal rates (ER) model, the symmetric rates (SYM) model and the all rates different (ARD) model. As a quick reminder, in the ER model, transitions between any pair of states occur at the same rate and are therefore equally probable. This is also known as the Mk1 model because it as a Markov model (Mk) with only 1 parameter (k). In the SYM model transitions between any pair of states occurs at the same rate regardless of direction, but that the rate of change differs among states. A symmetric model with only 2 states becomes an equal rates (Mk1) model. Finally, in the ARD model all transitions between pairs of states occurs at different rates. It’s important to be wary of over-fitting with this model as it can result in a lot of rates when you have more than a few states. For more details on these models please see the Primer. We are going to use the package geiger to fit models in this exercise, so we need the additional preparation step we first met in chapter 05-PhyloSignal. We need to create an object in R that only contains the variable required, and the species names (so we can match it up to the tree). We use the function pull to extract just the ecomorph values. We then name these values with the species names from mydata using the function names. Note that this requires the trait data is in the same order as the tree tip labels so we need to reorder the data first… # Check first few tip labels and species mytree$tip.label[1:5] ## [1] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; ## [4] &quot;Rhabdophis_nigrocinctus&quot; &quot;Rhabdophis_tigrinus&quot; mydata$Species[1:5] ## [1] &quot;Adelophis_foxi&quot; &quot;Afronatrix_anoscopus_2&quot; &quot;Amphiesma_beddomei&quot; ## [4] &quot;Amphiesma_monticola&quot; &quot;Amphiesma_stolatum_1&quot; # These are different so we reorder the data by the tips mydata &lt;- mydata[match(mytree$tip.label, mydata$Species), ] # Check this now matches the tip label order mydata$Species[1:5] ## [1] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; ## [4] &quot;Rhabdophis_nigrocinctus&quot; &quot;Rhabdophis_tigrinus&quot; # Create ecomorph containing just ecomorph values ecomorph &lt;- pull(mydata, Ecomorph) # Make sure ecomorph is a character, not a factor ecomorph &lt;- as.character(ecomorph) # Look at the first few rows head(ecomorph) ## [1] &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; # Give log head length names = species names at the tips of the phylogeny names(ecomorph) &lt;- mydata$Species # Look at the first few rows head(ecomorph) ## Rhabdophis_leonardi Rhabdophis_nuchalis_3 Rhabdophis_swinhonis_1 ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Semiaquatic&quot; ## Rhabdophis_nigrocinctus Rhabdophis_tigrinus Rhabdophis_tigrinus_lateralis ## &quot;Terrestrial&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; Now we have a list of values with associated species names. To fit the ER model we can then use the code below. # Fit the ER model equal &lt;- fitDiscrete(mytree, ecomorph, model = &quot;ER&quot;) Let’s look at the output for the equal rates model: # Look at the output equal ## GEIGER-fitted comparative model of discrete data ## fitted Q matrix: ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## Aquatic -0.034973712 0.008743428 0.008743428 0.008743428 0.008743428 ## Aquatic Burrowing 0.008743428 -0.034973712 0.008743428 0.008743428 0.008743428 ## Burrowing 0.008743428 0.008743428 -0.034973712 0.008743428 0.008743428 ## Semiaquatic 0.008743428 0.008743428 0.008743428 -0.034973712 0.008743428 ## Terrestrial 0.008743428 0.008743428 0.008743428 0.008743428 -0.034973712 ## ## model summary: ## log-likelihood = -176.839091 ## AIC = 355.678181 ## AICc = 355.703181 ## free parameters = 1 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 100 ## frequency of best fit = 1.00 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates This looks very similar to the output from fitContinuous in the 08-ModelsContinuous exercise. We’ve got a model summary, with log likelihoods and AIC scores, convergence diagnostics and an object summary. The only major difference is the first part, which gives us a fitted transition matrix or \\(Q\\) matrix, rather than a summary of model parameters. In fact the \\(Q\\) matrix is the model parameters for these models as it contains all the rates of change between different states. This is an equal rates model, so the off-diagonal elements are all same and show that the rate of change from one state to any other state is 0.00874. Why are the diagonal elements of the \\(Q\\) matrix -0.034973712? The rows of the \\(Q\\) matrix must sum to zero: -0.034973712 + (4 * 0.008743428) = 0. To fit the SYM model we just switch the model name. Note that this might be a bit slow on your computer as we have quite a lot of different ecomorphs, so a lot of different rates to fit. A good point to grab a coffee/tea/biscuit! # Fit the SYM model sym &lt;- fitDiscrete(mytree, ecomorph, model = &quot;SYM&quot;) # Look at the output sym ## GEIGER-fitted comparative model of discrete data ## fitted Q matrix: ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## Aquatic -3.410257e-02 6.787882e-03 8.536690e-03 1.877800e-02 ## Aquatic Burrowing 6.787882e-03 -6.787882e-03 1.163160e-19 3.309475e-18 ## Burrowing 8.536690e-03 1.163160e-19 -1.172452e-02 3.187830e-03 ## Semiaquatic 1.877800e-02 3.309475e-18 3.187830e-03 -6.519697e-02 ## Terrestrial 1.664242e-23 9.507585e-18 2.981126e-19 4.323114e-02 ## Terrestrial ## Aquatic 1.664242e-23 ## Aquatic Burrowing 9.507585e-18 ## Burrowing 2.981126e-19 ## Semiaquatic 4.323114e-02 ## Terrestrial -4.323114e-02 ## ## model summary: ## log-likelihood = -148.281974 ## AIC = 316.563949 ## AICc = 318.020902 ## free parameters = 10 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 4 ## frequency of best fit = 0.04 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates Again the \\(Q\\) matrix is the key output here. You could just read the numbers, we can see this more clearly if we plot the \\(Q\\) matrix for the model: # Plot Q matrix as network plot.gfit(sym) The transition rate between Semi-aquatic and Terrestrial is highest (0.043), followed by transitions between Semi-aquatic and Aquatic (0.019). Burrowing and Aquatic (0.009) and Aquatic Burrowing and Aquatic (0.007) have the next highest rates, followed by Burrowing and Semi-aquatic (0.003). All the other rates are &lt; 0.001 so they appear as zeros on this plot Finally let’s fit the ARD model. Again this may take some time! Go and grab a tea/coffee/biscuit or take a short break. # Fit the ARD model ard &lt;- fitDiscrete(mytree, ecomorph, model = &quot;ARD&quot;) # Look at the output ard ## GEIGER-fitted comparative model of discrete data ## fitted Q matrix: ## Aquatic Aquatic Burrowing Burrowing Semiaquatic ## Aquatic -3.871262e-02 7.710796e-03 1.070672e-02 2.029510e-02 ## Aquatic Burrowing 3.070007e-16 -3.085515e-16 1.550706e-18 7.000260e-38 ## Burrowing 4.008351e-19 4.966449e-23 -4.116883e-19 4.081239e-23 ## Semiaquatic 1.592909e-02 3.156430e-19 2.496600e-03 -5.538242e-02 ## Terrestrial 2.472419e-19 3.097357e-21 1.042375e-20 2.673830e-03 ## Terrestrial ## Aquatic 4.967164e-21 ## Aquatic Burrowing 2.883901e-24 ## Burrowing 1.076274e-20 ## Semiaquatic 3.695673e-02 ## Terrestrial -2.673830e-03 ## ## model summary: ## log-likelihood = -145.506018 ## AIC = 331.012035 ## AICc = 336.969482 ## free parameters = 20 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 1 ## frequency of best fit = 0.01 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates Again the \\(Q\\) matrix is the key output. We can plot the \\(Q\\) matrix for the model: # Plot Q matrix as network plot.gfit(ard) This is quite complex because in the ARD model we have different rates for each type of state change. Here, for example, the bottom left hand arrows joining Semi-aquatic and Terrestrial show that rates of change from Semi-aquatic to Terrestrial (0.037) are higher than those from Terrestrial to Semi-aquatic (0.003). These plots can be a little easier to read if we hide all the transitions where rates are &lt; 0.001 as follows. # Plot Q matrix as network without zeros plot.gfit(ard, show.zeros = FALSE) For now these plots are pretty simple, but you can add some code to make the arrows different sizes etc. if you need to using the code here http://blog.phytools.org/2020/09/graphing-fitted-m-k-model-with.html. Also check out future versions of phytools which should have these functions added. 9.2.2 Comparing models of evolution using AIC As we discussed in the continuous traits exercise in 08-ModelsContinuous, we often want to know which of the models fits our variable best. We can use fitDiscrete to fit the models we are interested in and then compare them using AIC. We can extract the AICs from the models we fitted above as follows: equal$opt$aic ## [1] 355.6782 sym$opt$aic ## [1] 316.5639 ard$opt$aic ## [1] 331.012 The “best” model is the one with the smallest AIC. Here the best model of evolution appears to be the SYM model, whereby rates of transition are the same in both directions, but are different for the different pairs of ecomorphs. Alternatively we can use \\(\\Delta\\)AIC or AIC weights to compare our models using the following code and the geiger function aicw: aic.scores &lt;- setNames(c(equal$opt$aic, sym$opt$aic, ard$opt$aic), c(&quot;equal&quot;, &quot;symmetric&quot;, &quot;different&quot;)) aicw(aic.scores) ## fit delta w ## equal 355.6782 39.11423 3.207273e-09 ## symmetric 316.5639 0.00000 9.992717e-01 ## different 331.0120 14.44809 7.283186e-04 aicw outputs the AIC (fit), \\(\\Delta\\)AIC (delta) and AIC weights (w) for each of the models we fitted. The best model is the model with \\(\\Delta\\)AIC = 0 or with AICw closest to 1. Using \\(\\Delta\\)AIC we can conclude that the SYM model is the best fit to the data. 9.3 Ancestral state estimations I’m not a big fan of ancestral state estimation as you probably realised from the Primer! There are many reasons to be highly sceptical of ancestral state estimates and interpretations of macroevolutionary patterns and process that are based on them. However, if you want to know if evolutionary tempo or mode have varied over clade history based on the state of a discrete trait as we intend to do in the next chapter, you’ll need to do it so you can assign each node to a particular state. We’ll use ape’s ace function here. There are other options out there, for example in the phytools package, but ace will work for our purposes. To perform ancestral state estimation of ecomorphs for snakes we can use the ecomorph object we made earlier and used to fit the ER, SYM and ARD models. Recall that ecomorph is just the Ecomorph column from the snake heads dataset, in the same order as the tips in the tree, with names equal to the tip labels/Species names in the tree. # Take a quick look at the first few rows of ecomorph head(ecomorph) ## Rhabdophis_leonardi Rhabdophis_nuchalis_3 Rhabdophis_swinhonis_1 ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Semiaquatic&quot; ## Rhabdophis_nigrocinctus Rhabdophis_tigrinus Rhabdophis_tigrinus_lateralis ## &quot;Terrestrial&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; To perform an ancestral state estimation of ecomorphs under the symmetric model (the best fitting model for the data as discovered above) we use this code: # Ancestral state estimation of ecomorph under the SYM model ancestral_ecomorphs &lt;- ace(ecomorph, mytree, type = &quot;discrete&quot;, model = &quot;SYM&quot;) ## Warning in log(comp[-TIPS]): NaNs produced ## Warning in sqrt(diag(solve(h))): NaNs produced You should notice a series of warning messages appear that say NaNs produced and NA/Inf replaced by maximum positive value. Don’t worry about this – it happens when rates for one transition are particularly low (and we know from above that many of the transition rates were &lt; 0.001) but doesn’t really affect our node state estimates. ace now defaults to a joint estimation procedure, where the ancestral states are optimized based on all information in the tree, not just the states at descendant tips. Older versions of ace did not do this, so be wary of this when reading older critiques of this method We can look at the first few rows of our ancestral state estimates by typing: head(ancestral_ecomorphs$lik.anc) In this matrix the rows correspond to nodes in the tree (although the numbering is bit off; we don’t need to worry about this here but it will come up in the next exercise) and the five columns give the scaled likelihoods that the node is in each of the different ecomorphs. The scaled likelihoods are like probabilities, so for the first node, the probability of it being Aquatic is highest (probability = 0.5417), followed by the probability of it being Semi-aquatic (0.3587), Terrestrial (0.0755), Burrowing (0.0206), or Aquatic Burrowing (0.0035). These scaled likelihoods can be visualized with pie charts on the tree we plotted earlier byt adding the nodelabels line of code below. # Plot the tree with colours at the tips and nodes to represent ecomorph plot(mytree, cex = 0.5, adj = c(0.2), type = &quot;fan&quot;, no.margin = TRUE, show.tip.label = FALSE) tiplabels(pch = 16, col = ecomorph.colors[mydata$Ecomorph]) nodelabels(pie = ancestral_ecomorphs$lik.anc, piecol = ecomorph.colors, cex = 0.5) legend(&quot;bottomleft&quot;, pch = 15, bty = &quot;n&quot;, legend = c(&quot;Aquatic&quot;, &quot;Semi-aquatic&quot;, &quot;Aquatic burrower&quot;, &quot;Burrower&quot;, &quot;Terrestrial&quot;), col = c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightgreen&quot;)) Aquatic is most commonly estimated as the ancestral ecomorph for natricine snakes, with Semi-aquatic as a close second, and with multiple transitions to other ecomorphs throughout the tree. Ancestral state estimates (not reconstructions) are, at best, weighted averages of your trait based on branch lengths of the phylogeny and the model of evolution used. If your phylogeny or traits or model have error (and they always will) then your ancestral state estimates should be interpreted with care. 9.4 Summary You should now know how to fit simple models of evolution to discrete trait data in R. 9.5 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit equal rates, symmetric rates and all rates different models to the social status variable for Primates (SocialStatus). Note that social status has two states: non-social (1) or social (2). Then answer the following questions. Which model fits best? What is the transition rate from non-social (1) to social (2), and vice versa, in the all rates different model? What does this mean biologically? Plot ancestral state estimates of social status (from the ARD model) on the phylogeny. Is the root node estimated as being non-social or social? Why didn’t I ask you to fit the symmetric model? References "],["beyond-simple-macroevolutionary-models.html", "Chapter 10 Beyond simple macroevolutionary models Before you start 10.1 Preparation 10.2 More complex models of trait evolution 10.3 Summary 10.4 Practical exercises", " Chapter 10 Beyond simple macroevolutionary models The aims of this exercise are to learn how to use R to fit slightly more complex macroevolutionary models. Our question here still revolves around the snake head shape data. In 08-ModelsContinuous we fitted simple Brownian Motion (BM) and Ornstein-Uhlenbeck (OU) models to the head length data. We found that the OU model was a better fit, but we didn’t account for any of the limitations of the BM or OU models (see Primer). In the both models we only allowed head length to have one rate of evolution across the tree, and in the OU model we only fit a single optimum. We can extend these models by relaxing these assumptions. In 09-ModelsDiscrete we fitted three simple models of evolution to discrete data to see how ecomorph changed across the tree. We found the best fitting model was the symmetric (SYM) model, where rates of transition between ecomorphs were the same in both directions, but were different for the different pairs of ecomorphs. A more interesting question is how do these different ecomorphs relate to the head shape data? Do aquatic species have wider heads than terrestrial species? Are burrowers evolving their head shape more quickly than semi-aquatic species? We can use more complex evolutionary models to approach these questions. We will be using the evolution of head shape in natricine snakes as an example. The data and modified tree come from V. Deepak, Gower, and Cooper (2023), and the tree comes from V. Deepak et al. (2021). I’ve removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out V. Deepak, Gower, and Cooper (2023)! Before you start Open the 10-ModelsBeyond.RProj file in the 10-ModelsBeyond folder to open your R Project for this exercise. You will also need to install the following packages: tidyverse - for reading, manipulating and plotting data ape - functions for reading, plotting and manipulating phylogenies geiger - to fit models of evolution OUwie - to fit different kinds of OU models phytools - for stochastic character mapping 10.1 Preparation To begin we need to load the packages for this practical. # Load the packages library(tidyverse) library(ape) library(geiger) library(phytools) library(OUwie) Next we need to prepare the tree and data for the analyses. In the 04-Preparation exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven’t previously. It is important to do these things before beginning a phylogenetic comparative analysis, so let’s run through that code again here. # Read in the data snakedata &lt;- read_csv(&quot;data/snake-heads.csv&quot;) # Check everything loaded corrected glimpse(snakedata) ## Rows: 206 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Amphiesma_beddomei&quot;, &quot;… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;anurans&quot;, &quot;generalist… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 19.950, 18.810, 16.375, 22.640, 17.… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 10.32, 9.82, 8.39, 11.30, 9.04, 9.55, 4.49… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 7.56, 5.80, 6.40, 8.70, 5.68, 6.64, 4.19, … ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.84, 5.42, 6.00, 6.05, 5.01, 6.39, 3.12, 3… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 165, 155, NA, 163, 130, 309, 31, 62, 56, 35, 16… To load the tree we will use read.nexus. # Read in the tree snaketree &lt;- read.nexus(&quot;data/snake-tree.nex&quot;) # Check it loaded correctly str(snaketree) ## List of 4 ## $ edge : int [1:496, 1:2] 250 251 252 253 254 255 256 257 258 259 ... ## $ edge.length: num [1:496] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 248 ## $ tip.label : chr [1:249] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_1&quot; &quot;Rhabdophis_nuchalis_2&quot; &quot;Rhabdophis_adleri_1&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary(snaketree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(snaketree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(snaketree) ## [1] TRUE Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further. I haven’t printed check here as we already did this in the previous exercise and it’s a long list but we have already checked these in advance. Do not skip this step for your own analyses! # Check whether the names match in the data and the tree check &lt;- name.check(phy = snaketree, data = snakedata, data.names = snakedata$Species) # check Finally remove species that are not in the tree and the data and ensure the data is a data frame. # Remove species missing from the data mytree &lt;- drop.tip(snaketree, check$tree_not_data) # Remove species missing from the tree matches &lt;- match(snakedata$Species, check$data_not_tree, nomatch = 0) mydata &lt;- subset(snakedata, matches == 0) # Look at the tree summary str(mytree) ## List of 4 ## $ edge : int [1:322, 1:2] 163 164 165 166 167 168 169 170 171 172 ... ## $ edge.length: num [1:322] 4.695 2.225 0.587 0.307 0.832 ... ## $ Nnode : int 161 ## $ tip.label : chr [1:162] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; &quot;Rhabdophis_nigrocinctus&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Look at the data glimpse(mydata) ## Rows: 162 ## Columns: 9 ## $ Species &lt;chr&gt; &quot;Adelophis_foxi&quot;, &quot;Afronatrix_anoscopus_2&quot;, &quot;Amphiesma_beddomei&quot;, &quot;… ## $ Ecomorph &lt;chr&gt; &quot;Burrowing&quot;, &quot;Aquatic&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;, &quot;Terrestrial&quot;… ## $ Diet &lt;chr&gt; &quot;annelids&quot;, &quot;aquatic generalist&quot;, &quot;anurans&quot;, &quot;anurans&quot;, &quot;generalist… ## $ ReproductiveMode &lt;chr&gt; &quot;Viviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;Oviparous&quot;, &quot;… ## $ HeadLength &lt;dbl&gt; 12.560, 25.100, 15.060, 20.105, 18.810, 16.375, 22.640, 19.760, 10.… ## $ HeadWidth &lt;dbl&gt; 6.60, 15.80, 7.82, 9.13, 9.82, 8.39, 11.30, 9.55, 4.03, 4.90, 3.44,… ## $ HeadHeight &lt;dbl&gt; 5.43, 10.30, 5.40, 6.61, 5.80, 6.40, 8.70, 6.64, 3.24, 4.41, 3.12, … ## $ EyeDistance &lt;dbl&gt; 4.01, 7.40, 4.85, 5.85, 5.42, 6.00, 6.05, 6.39, 3.34, 2.27, 1.70, 3… ## $ TotalLength &lt;dbl&gt; 105, 194, 106, 185, 155, NA, 163, 309, 62, 35, 16, 23, NA, 33, 81, … # Convert to a dataframe mydata &lt;- as.data.frame(mydata) # Check this is now a data frame class(mydata) ## [1] &quot;data.frame&quot; Overall we have 162 species in the data and the tree. Now we’re ready to run our analyses! 10.2 More complex models of trait evolution We are now going to fit some of the slightly more complicated models of trait evolution that we discussed in the Primer. We will fit these using the package OUwie. There’s a little bit of extra preparation required to fit these models which we will do first. 10.2.1 Preparing the tree and data for OUwie To use OUwie we need to do a couple of things. We need to estimate the node values for each evolutionary regime in the analysis (see below), and we have to set up a dataframe in a particular way. Let’s sort out our node values first. 10.2.1.1 Estimating node values for the tree In 09-ModelsDiscrete we fitted three simple models of evolution to discrete data to see how ecomorph changed across the tree. We found the best fitting model was the symmetric (SYM) model, where rates of transition between ecomorphs were the same in both directions, but were different for the different pairs of ecomorphs. To extend this we can test whether head shape evolution varies among snakes with different ecomorphs. We refer to the different ecomorphs as representing different evolutionary regimes. To fit these more complex models using OUwie we need to assign each node in the tree to one of the ecomorph categories. This is of course a massive assumption, but we need it to determine which branches should belong to which evolutionary regimes. First we need to determine which model of evolution best fits the ecomorph data. We can do this using fitDiscrete in geiger. In fact this is exactly what we did in 09-ModelsDiscrete, so I’ll just quickly recap this here: To get the data into the correct format, we use the function pull to extract just the ecomorph values. We then name these values with the species names from mydata using the function names. Note that this requires the trait data is in the same order as the tree tip labels so we will check this first. # Check first few tip labels and species mytree$tip.label[1:5] ## [1] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; ## [4] &quot;Rhabdophis_nigrocinctus&quot; &quot;Rhabdophis_tigrinus&quot; mydata$Species[1:5] ## [1] &quot;Adelophis_foxi&quot; &quot;Afronatrix_anoscopus_2&quot; &quot;Amphiesma_beddomei&quot; ## [4] &quot;Amphiesma_monticola&quot; &quot;Amphiesma_stolatum_1&quot; # These are different so we reorder the data by the tips mydata &lt;- mydata[match(mytree$tip.label, mydata$Species), ] # Check this now matches the tip label order mydata$Species[1:5] ## [1] &quot;Rhabdophis_leonardi&quot; &quot;Rhabdophis_nuchalis_3&quot; &quot;Rhabdophis_swinhonis_1&quot; ## [4] &quot;Rhabdophis_nigrocinctus&quot; &quot;Rhabdophis_tigrinus&quot; # Create ecomorph containing just ecomorph values ecomorph &lt;- pull(mydata, Ecomorph) # Make sure ecomorph is a character, not a factor ecomorph &lt;- as.character(ecomorph) # Look at the first few rows head(ecomorph) ## [1] &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; # Give log head length names = species names at the tips of the phylogeny names(ecomorph) &lt;- mydata$Species # Look at the first few rows head(ecomorph) ## Rhabdophis_leonardi Rhabdophis_nuchalis_3 Rhabdophis_swinhonis_1 ## &quot;Semiaquatic&quot; &quot;Terrestrial&quot; &quot;Semiaquatic&quot; ## Rhabdophis_nigrocinctus Rhabdophis_tigrinus Rhabdophis_tigrinus_lateralis ## &quot;Terrestrial&quot; &quot;Terrestrial&quot; &quot;Terrestrial&quot; To fit the ER, SYM and ARD models we can then use the code below. I’ve commented these out here on the assumption that you’ve already run this in 09-ModelsDiscrete. The SYM and ARD models take a while to run so don’t rerun thee unless you need to! # Fit the models equal &lt;- fitDiscrete(mytree, ecomorph, model = &quot;ER&quot;) sym &lt;- fitDiscrete(mytree, ecomorph, model = &quot;SYM&quot;) ard &lt;- fitDiscrete(mytree, ecomorph, model = &quot;ARD&quot;) We can then use AIC to determine the “best model” from these three: # Extract AICc values for each model and give them names aic.discrete &lt;- setNames(c(equal$opt$aic, sym$opt$aic, ard$opt$aic), c(&quot;equal&quot;, &quot;symmetric&quot;, &quot;different&quot;)) # Compare AICw values aicw(aic.discrete) ## fit delta w ## equal 355.6782 39.11423 3.207273e-09 ## symmetric 316.5639 0.00000 9.992717e-01 ## different 331.0120 14.44809 7.283186e-04 The best model of evolution is the symmetric model, the same as we found in 09-ModelsDiscrete. Phew! Next we use this model to determine what the best fit state value is for each node. Let’s remind ourselves of the ancestral state estimates we got for ecomorphs in 09-ModelsDiscrete… # Ancestral state estimation of ecomorph under the SYM model ancestral_ecomorphs &lt;- ace(ecomorph, mytree, type = &quot;discrete&quot;, model = &quot;SYM&quot;) ## Warning in log(comp[-TIPS]): NaNs produced ## Warning in sqrt(diag(solve(h))): NaNs produced You should notice a series of warning messages appear that say NaNs produced and NA/Inf replaced by maximum positive value. These can be ignored (see 09-ModelsDiscrete). Let’s visualize the results on our tree by plotting them with colours. We’ll then create a vector of five colours for the ecomorphs. These need to be in alphabetical order, so the colours should be in the order Aquatic, Aquatic burrower, Burrower, Semi-aquatic, Terrestrial. # Set up list of colours ecomorph.colors &lt;- c(&quot;darkblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightblue&quot;, &quot;lightgreen&quot;) We then need to make sure the variable Ecomorph is a factor rather than a character as R deals with these differently and we need it to be a factor for the next bit of code to work. We can do this using the function as.factor and we can change it in mydata usign the tidyverse function mutate. # Make Ecomorph a factor mydata &lt;- mydata %&gt;% mutate(Ecomorph = as.factor(Ecomorph)) And now we can plot… # Plot the tree with colours at the tips and nodes to represent ecomorph plot(mytree, cex = 0.5, adj = c(0.2), type = &quot;fan&quot;, no.margin = TRUE, show.tip.label = FALSE) tiplabels(pch = 16, col = ecomorph.colors[mydata$Ecomorph]) nodelabels(pie = ancestral_ecomorphs$lik.anc, piecol = ecomorph.colors, cex = 0.5) legend(&quot;bottomleft&quot;, pch = 15, bty = &quot;n&quot;, legend = c(&quot;Aquatic&quot;, &quot;Semi-aquatic&quot;, &quot;Aquatic burrower&quot;, &quot;Burrower&quot;, &quot;Terrestrial&quot;), col = c(&quot;darkblue&quot;, &quot;lightblue&quot;, &quot;plum&quot;, &quot;chocolate&quot;, &quot;lightgreen&quot;)) Each pie shows the scaled likelihoods of the node being within each of the five ecomorphs. Many of these are ambiguous, so how do we pick the “best” state? To solve this problem we use simulations. We use the transition or \\(Q\\) matrix from the SYM model and use it to simulate tip values and node values of ecomorph category for the tree. We repeat this a number of times - below I use 500 simulations but if the states are fairly simply distributed across the tree you could use fewer. This takes a bit of time to run… # Simulate node and tip values for 500 trees using the SYM model trees.SYM &lt;- make.simmap(mytree, ecomorph, model = &quot;SYM&quot;, nsim = 500) ## make.simmap is sampling character histories conditioned on ## the transition matrix ## ## Q = ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## Aquatic -0.033980020 0.006989515 0.008443046 0.018547459 0.0000000 ## Aquatic Burrowing 0.006989515 -0.006989515 0.000000000 0.000000000 0.0000000 ## Burrowing 0.008443046 0.000000000 -0.011914946 0.003471901 0.0000000 ## Semiaquatic 0.018547459 0.000000000 0.003471901 -0.065115565 0.0430962 ## Terrestrial 0.000000000 0.000000000 0.000000000 0.043096205 -0.0430962 ## (estimated using likelihood); ## and (mean) root node prior probabilities ## pi = ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## 0.2 0.2 0.2 0.2 0.2 ## Done. # Store the results of the summary of the 500 trees summary.SYM &lt;- summary(trees.SYM) Now we can use a simple trick to extract the most likely states. We use apply to extract the maximum value for each node from the summary.SYM. However, summary.SYM contains the summary of estimates at the tips and the nodes. A fully bifurcating/resolved tree has n - 1 nodes. This means we have 161 nodes in our snake tree. summary.SYM reports the node values first, and then the tip values, so we only want entries 1 to 161. WE can write this in our code as: summary.SYM$ace[1:161, ]. # Get the max likelihood state at each node best &lt;- apply(summary.SYM$ace[1:161, ], 1, which.max) # Look at first few rows of the output head(best) ## 163 164 165 166 167 168 ## 1 1 4 4 4 4 Finally we assign these “best” node states to the tree node labels. Note that best only contains the numerical versions of the ecomorphs, i.e. 1, 2, 3 etc. rather than the ecomorph names, so we need to use levels(mydata$Ecomorph)[best] to select the names that go with the numbers. # Assign to the tree node labels mytree$node.label &lt;- levels(mydata$Ecomorph)[best] 10.2.1.2 Preparing the data Finally for OUwie to work we need to set up a dataset with three columns: the species names first, then the evolutionary regime which in this case is the ecomorphs, and then the continuous variable we think might be evolving differently in response to different regimes. Here we are going to look at head width, as we predict that burrowing snakes and aquatic snakes may have narrower heads than terrestrial species. Note that I have also log transformed head width. # Make new dataset with just three columns for OUwie headw &lt;- data.frame(species = mydata$Species, regime = mydata$Ecomorph, trait = log(mydata$HeadWidth)) # look at the first few rows head(headw) ## species regime trait ## 1 Rhabdophis_leonardi Semiaquatic 2.618855 ## 2 Rhabdophis_nuchalis_3 Terrestrial 2.004179 ## 3 Rhabdophis_swinhonis_1 Semiaquatic 2.149434 ## 4 Rhabdophis_nigrocinctus Terrestrial 2.682390 ## 5 Rhabdophis_tigrinus Terrestrial 2.634762 ## 6 Rhabdophis_tigrinus_lateralis Terrestrial 2.961658 We are now ready to run some more complex models with OUwie! This is a key point to remember the “Jurassic Park caveat”; just because we can fit all of these models to our data doesn’t mean that we should. Before applying any of the models below, think very carefully. What questions are you trying to answer? What would a result one way or the other tell you about evolution in your study group? It is often tempting to just fit all of these models, then tell a “just so” story about why one model fits best. But without a clear question and a prediction about what you might find, at best the results might not tell you anything interesting about evolution in your group, and at worst the results may be nonsensical. This is especially true when sample sizes are low, and/or we expect there is error in our data or our phylogeny. Pay close attention to the caveats discussed below. Especially for the complex models near the end of the exercise. 10.2.2 Running models using OUwie Before we dive into the exciting new models, it’s worth using OUwie to fit the simple BM and OU models we already learned how to fit in 08-ModelsContinuous first. Why? Well, it’s always a good idea to compare complex models to simpler models to see if adding complexity is worthwhile. Sometimes a BM model fits just as well as these more complex ones. We’ll fit the simple models and the more complex ones so we can compare them all using AIC at the end of the exercise. 10.2.3 Single rate BM models As a quick reminder, the BM model is a so called “random walk” model where traits change gradually through time. The model has two parameters, the Brownian rate parameter, \\(\\sigma^2\\) and the state of the root at time zero, \\(z(0)\\). To fit a BM model in OUwie we use the following code. The model name here is BM1 to indicate this is a simple BM model with only one rate of evolution. BM &lt;- OUwie(mytree, headw, model = &quot;BM1&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. You should see some messages here. An algorithm was not specified. Defaulting to computing the determinant and inversion of the vcv. just tells you that the model will use the older (slower) method to fit the likelihood, rather than the faster three-point algorithm. The other messages just tell you the code is working, and when it is finished. This is for people running complex analyses that take some time, just so they know the code is running! Let’s look at the results. BM ## ## Fit ## lnL AIC AICc BIC model ntax ## -221.3888 446.7775 446.853 452.9527 BM1 162 ## ## Rates ## alpha sigma.sq ## NA 0.08589727 ## ## Optima ## 1 ## estimate 2.1862946 ## se 0.7488703 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). We don’t fit \\(\\alpha\\) in a BM model so it’s NA in this output. The Optima section tells us what the trait “optima” are for each regime. In a BM model we don’t have any different regimes so this is just estimated value of log head width at the root, \\(z(0)\\). Arrived at a reliable solution tells us that the model converged on a reliable set of parameter estimates. The rest of the output includes log likelihood and AIC of the model etc. 10.2.4 Single optimum OU models Again as a reminder, the OU model is a random walk where trait values are pulled back towards some “optimal” value with an attraction strength proportional to the “rubber-band” parameter \\(\\alpha\\). The OU model has four parameters the Brownian rate parameter, \\(\\sigma^2\\), the state of the root at time zero, \\(z(0)\\), the long-term mean, \\(\\mu\\), and the strength of evolutionary force that returns traits back towards the long-term mean if they evolve away from it, \\(\\alpha\\). If \\(\\alpha\\) is close to zero then evolution is approximately Brownian. To fit a single peak OU model in OUwie we use the following code. The model name here is OU1 to indicate this is a simple OU model with only one rate of evolution and one peak. OU &lt;- OUwie(mytree, headw, model = &quot;OU1&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OU ## ## Fit ## lnL AIC AICc BIC model ntax ## -80.87437 167.7487 167.9006 177.0115 OU1 162 ## ## ## Rates ## alpha sigma.sq ## 9.094921 2.927057 ## ## Optima ## 1 ## estimate 2.30982153 ## se 0.03169223 ## ## ## Half life (another way of reporting alpha) ## alpha ## 0.07621256 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). The Optima section tells us what the trait “optima” are for each regime. In a one peak OU model we only have one optimum, so here there is only one estimate for the overall long-term mean for log head width. Finally, the OU model output also reports the Half life of \\(\\alpha\\). This is how long it takes for the trait to get half way to its long-term mean. Here the half life is 0.07621256, i.e. it takes 0.07621256 units of branch length for log head width to get half way to the optima of head width. That’s pretty fast! 10.2.5 Multi-rate BM (BMS) models Now we’ve fitted the simple models, let’s make things more complex and, hopefully, more realistic. The first model we will fit is a BM model where different rates of evolution are allowed for each evolutionary regime. Here the evolutionary regimes are the ecomorphs. BMS models allow different \\(\\sigma^2\\) values for different regimes. We can use the code below to fit them. # Fit BMS model BMS &lt;- OUwie(mytree, headw, model = &quot;BMS&quot;, root.station = FALSE) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Note that we set the root to invoke the non-censored model of O’Meara et al. (2006), by using root.station = FALSE. This means a single regime at the root is estimated. If we instead want to use the censored model of O’Meara et al. (2006) or the group means model of G. H. Thomas, Freckleton, and Székely (2006), where the number of means equals the number of regimes, we use root.station == TRUE. However, the beaviour of these latter two models appears to approximate OUMV (see below) and is not fully understood, so the authors of OUwie recommend using root.station = FALSE whenever you fit a BMS model. Let’s look at the results. BMS ## ## Fit ## lnL AIC AICc BIC model ntax ## -157.5303 327.0606 327.6025 345.5862 BMS 162 ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha NA NA NA NA NA ## sigma.sq 0.02204614 0.00311173 0.0116445 0.1598786 0.0046875 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 1.9969812 1.9969812 1.9969812 1.9969812 1.9969812 ## se 0.4476255 0.4476255 0.4476255 0.4476255 0.4476255 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) for each of the ecomorphs or evolutionary regimes. The semi-aquatic ecomorphs have a much higher rate of evolution than the others. Again as this is a BM model it does not have \\(\\alpha\\) estimates. The Optima section tells us what root state \\(z0\\) is for each ecomorph. In the BMS model this is the same for each evolutionary regime. 10.2.6 Multi-optima OU (OUM) models Next let’s fit an OUM model. These models allow different trait optima or long-term mean values for different evolutionary regimes but the same \\(\\sigma^2\\) and \\(\\alpha\\). Here the evolutionary regimes are the ecomorphs. We fit the model as follows: # Fit OUM model OUM &lt;- OUwie(mytree, headw, model = &quot;OUM&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OUM ## ## Fit ## lnL AIC AICc BIC model ntax ## -35.86695 85.73389 86.46117 107.3471 OUM 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 9.094924 9.094924 9.094924 9.094924 9.094924 ## sigma.sq 1.679235 1.679235 1.679235 1.679235 1.679235 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.55900183 2.07636983 1.6375381 2.36487673 2.32107617 ## se 0.04635974 0.09161043 0.0736914 0.04203024 0.04995087 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## 0.07621253 0.07621253 0.07621253 0.07621253 0.07621253 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). In an OUM model these are the same for each regime/ecomorph, so the Half life of \\(\\alpha\\) is also the same for each regime. The key part in this output is the Optima section as the OUM model fits a trait “optimum” or long-term mean for each regime. So here we have an estimate for the long-term mean for log head width for each ecomorph. Note that the value for Burrowing species is quite a lot lower than for the other ecomorphs, perhaps reflecting evolution towards narrower heads in that ecomorph? It’s important to stop and think carefully before interpreting these “optima” or long-term means. Do they make sense in terms of what we know about head shape in these snake ecomorphs? I think it looks pretty sensible given where they plot (see DEEPAK) but it’s always good to check there’s nothing weird going on. 10.2.7 Multi-rate multi-optima OU motion models (OUMV) Next let’s fit an OUMV model. These models allow different \\(\\sigma^2\\) values and different trait optima or long-term mean values for different evolutionary regimes but the same \\(\\alpha\\). Here the evolutionary regimes are the ecomorphs. We fit the model as follows: # Fit OUMV model OUMV &lt;- OUwie(mytree, headw, model = &quot;OUMV&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OUMV ## ## Fit ## lnL AIC AICc BIC model ntax ## -46.42607 114.8521 116.6121 148.8157 OUMV 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 1.1037667 1.1037667 1.10376674 1.1037667 1.1037667 ## sigma.sq 0.2731041 0.1454491 0.07296744 0.3966615 0.1943118 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.56532695 2.07371859 1.63075029 2.35506791 2.33131038 ## se 0.05492185 0.07756587 0.04493174 0.05916478 0.05051628 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## 0.6279834 0.6279834 0.6279834 0.6279834 0.6279834 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). \\(\\alpha\\) (and the Half life of \\(\\alpha\\)) are the same across the whole tree in OUMV, but \\(\\sigma^2\\) varies for each ecomorph, with highest rates of log head width evolution in the semi-aquatic and aquatic species. In the Optima section we have an estimate for the long-term mean for log head width for each ecomorph. As for the OUM model, the value for Burrowing species is quite a lot lower than for the other ecomorphs, perhaps reflecting evolution towards narrower heads in that ecomorph? 10.2.8 Multi-alpha multi-optima OU motion models (OUMA) The OUMA models allow different \\(\\alpha\\) values and different trait optima or long-term mean values for different evolutionary regimes but the same \\(\\sigma^2\\) across the whole tree. To fit the model: OUMA &lt;- OUwie(mytree, headw, model = &quot;OUMA&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OUMA ## ## Fit ## lnL AIC AICc BIC model ntax ## -84.65133 191.3027 193.0627 225.2662 OUMA 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 0.06790343 0.04095888 0.07302106 0.10542290 0.07140882 ## sigma.sq 0.03081986 0.03081986 0.03081986 0.03081986 0.03081986 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.5841710 1.3840516 1.3126153 2.2863236 2.4554550 ## se 0.1375442 0.4360235 0.1925937 0.1019231 0.1683863 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## 10.207837 16.923001 9.492429 6.574921 9.706745 ## ## Arrived at a reliable solution The Rates section shows us what the parameter estimates are for \\(\\sigma^2\\) and \\(\\alpha\\). \\(\\sigma^2\\) is the same across the whole tree in OUMA, but \\(\\alpha\\) (and the Half life of \\(\\alpha\\)) varies for each ecomorph, with highest pull back to the long-term mean of log head width evolution in the aquatic burrowing species. In the Optima section we have an estimate for the long-term mean for log head width for each ecomorph. The value for Burrowing and Aquatic burrowing species is lower than for the other ecomorphs, perhaps reflecting evolution towards narrower heads in these ecomorphs? 10.2.9 Multi-rate multi-optima OU motion models (OUMVA) Finally, OUMVA models allow us to vary everything! We fit different \\(\\sigma^2\\) and \\(\\alpha\\) values and different trait optima or long-term mean values for different evolutionary regimes. We don’t have enough data to fit this model but I’ve included it for completeness. It takes a while to run… OUMVA &lt;- OUwie(mytree, headw, model = &quot;OUMVA&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Let’s look at the results. OUMVA ## ## Fit ## lnL AIC AICc BIC model ntax ## -86.01823 202.0365 205.3241 248.3504 OUMVA 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 0.02051446 0.1133908481 0.060623770 0.06486770 0.056621938 ## sigma.sq 0.04240642 0.0004831934 0.003578768 0.01515573 0.005968367 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.663854 2.00083536 1.4168574 2.248932 2.3634432 ## se 0.360076 0.07619711 0.1451648 0.139991 0.1542472 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## 33.788226 6.112902 11.433587 10.685551 12.241672 ## ## Arrived at a reliable solution The Rates section shows how \\(\\sigma^2\\) and \\(\\alpha\\) vary for each ecomorph, and in the Optima section we have an estimate for the long-term mean for log head width for each ecomorph. It would not be sensible to over-interpret these results given the complexity of the model and the relative paucity (n = 162) of the data. Above I included code for all of the complex models discussed in the Primer. However, it is likely that the complexity of some of these models is greater than the information contained within the data. As a result one or more parameters may be poorly estimated. Always check parameter estimates from your models to ensure that they make biological sense. If you don’t check, you might unknowingly pick a poor model with incorrect biological interpretations. The more complex your models the more likely this is. Beware! 10.2.10 Comparing models of evolution using AIC As we have done in the last few exercises, we’re going to compare models using AIC, \\(\\Delta\\)AIC and AIC weights (AICw). The “best” model is the one with the smallest AIC, with \\(\\Delta\\)AIC = 0 or with AICw closest to 1. # Extract AICc scores from the models aic.scores &lt;- setNames(c(BM$AICc, OU$AICc, BMS$AICc, OUM$AICc, OUMV$AICc, OUMA$AICc, OUMVA$AICc), c(&quot;BM&quot;, &quot;OU&quot;, &quot;BMS&quot;, &quot;OUM&quot;, &quot;OUMV&quot;, &quot;OUMA&quot;, &quot;OUMVA&quot;)) # Get aic weights aicw(aic.scores) ## fit delta w ## BM 446.85300 360.39183 5.519603e-79 ## OU 167.90063 81.43947 2.068446e-18 ## BMS 327.60252 241.14136 4.333305e-53 ## OUM 86.46117 0.00000 9.999997e-01 ## OUMV 116.61214 30.15097 2.836609e-07 ## OUMA 193.06265 106.60149 7.108556e-24 ## OUMVA 205.32414 118.86297 1.546088e-26 The best fitting model for the data is the OUM model, i.e. where there are different trait optima or long-term mean values for different ecomorphs but the same \\(\\sigma^2\\) and \\(\\alpha\\). A second look at the output for this model suggests that there is a rather strong pull towards the ecomorph optima for log head width, and that burrowing species have the narrowest heads. Does this make sense biologically? # Look at the output OUM ## ## Fit ## lnL AIC AICc BIC model ntax ## -35.86695 85.73389 86.46117 107.3471 OUM 162 ## ## ## Rates ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## alpha 9.094924 9.094924 9.094924 9.094924 9.094924 ## sigma.sq 1.679235 1.679235 1.679235 1.679235 1.679235 ## ## Optima ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## estimate 2.55900183 2.07636983 1.6375381 2.36487673 2.32107617 ## se 0.04635974 0.09161043 0.0736914 0.04203024 0.04995087 ## ## ## Half life (another way of reporting alpha) ## Aquatic Aquatic Burrowing Burrowing Semiaquatic Terrestrial ## 0.07621253 0.07621253 0.07621253 0.07621253 0.07621253 ## ## Arrived at a reliable solution 10.3 Summary You should now know how to fit some of the more complex models of evolution in R. 10.4 Practical exercises In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Using log body size (AdultBodyMass_g) as your continuous trait, and social status (SocialStatus) to define the selective regimes, fit (A) a multi-rate Brownian motion model and (B) an OU model with trait optima or long-term mean values for different evolutionary regimes but the same \\(\\sigma^2\\) and \\(\\alpha\\). Note that social status has two states: non-social (1) or social (2). Assume it is evolving according to an all rates different model. Then answer the following questions: Which is the best fitting model? If you were running these analyses for a publication, what additional models would you compare these models to? In the multi rate Brownian model, which social status state has the higher rate of log body mass evolution? Look at the parameter estimates of the multi peak OU model. Do you see anything worrying there? It might help to look at a histogram showing the body sizes of species in the non-social and the social categories. References "],["diversification-rate-analyses.html", "Chapter 11 Diversification rate analyses Before you start 11.1 Preparation 11.2 Lineage through time plots and the \\(\\gamma\\) statistic 11.3 BAMM: Bayesian Analysis of Macroevolutionary Mixtures 11.4 Running BAMM 11.5 Looking at the output of BAMM using BAMMtools in R 11.6 Credible sets of shifts 11.7 Clade specific evolutionary rates 11.8 Rate-through-time analysis 11.9 Macroevolutionary cohort analysis 11.10 Assumptions and issues with BAMM 11.11 Summary 11.12 Practical exercises", " Chapter 11 Diversification rate analyses The aims of this exercise are to learn how to use R to perform some simple diversification rate analyses, and to analyse the output from a BAMM analysis. We will be using the diversification rates of dragonflies (Anisoptera) as an example. The tree comes from Letsch, Gottsberger, and Ware (2016b) and is available to download from Letsch, Gottsberger, and Ware (2016a). I’m only using one of their trees. If you want to see the full results check out Letsch, Gottsberger, and Ware (2016b)! Before you start Open the 11-Diversification.RProj file in the 11-Diversification folder to open your R Project for this exercise. You will also need to install the following packages: ape - functions for reading, plotting and manipulating phylogenies BAMMtools - functions to work with outputs from BAMM coda - to assess convergence of MCMC runs phytools - for lineage through time plots and force.ultrametric viridis - colour palettes 11.1 Preparation To begin we need to load the packages for this practical. # Load the packages library(ape) library(BAMMtools) library(coda) library(phytools) library(viridis) To load the tree we will use read.tree. # Read in the tree dragonflytree &lt;- read.tree(&quot;data/dragonflies-tree.tre&quot;) # Check it loaded correctly str(dragonflytree) ## List of 4 ## $ edge : int [1:1042, 1:2] 523 524 525 525 526 527 527 526 528 528 ... ## $ edge.length: num [1:1042] 53.62 128.32 54.18 5.07 17.93 ... ## $ Nnode : int 521 ## $ tip.label : chr [1:522] &quot;Hypopetalia_pestilens&quot; &quot;Phyllopetalia_apicalis&quot; &quot;Ophiopetalia_diana&quot; &quot;Phyllopetalia_apollo&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Look at the tree plot(dragonflytree, show.tip.label = FALSE) Remember to check the tree is dichotomous, i.e. has no polytomies, rooted, and ultrametric. # Check whether the tree is binary # We want this to be TRUE is.binary(dragonflytree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(dragonflytree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE is.ultrametric(dragonflytree) ## [1] FALSE Oh dear, the tree is not ultrametric! But it looks ultrametric so we can fix this using the phytools function force.ultrametric. Note that this function is designed to deal with situations like this, but if your tree is genuinely non-ultrametric you should not use this function. # Force the tree to be ultrametric dragonflytree &lt;- force.ultrametric(dragonflytree) ## *************************************************************** ## * Note: * ## * force.ultrametric does not include a formal method to * ## * ultrametricize a tree &amp; should only be used to coerce * ## * a phylogeny that fails is.ultramtric due to rounding -- * ## * not as a substitute for formal rate-smoothing methods. * ## *************************************************************** Why does a tree that looks ultrametric appear to be non-ultrametric? Most of the methods we use expect trees to be ultrametric, i.e. that all the tips line up, generally at the present day (time 0). Here we plotted the tree and it looks ultrametric, but when we check using is.ultrametric the answer returned is FALSE. What is going on? The tree is actually ultrametric, and will run in most analyses with R treating it as an ultrametric tree. The reason is.ultrametric tells us it is not ultrametric is related to rounding errors. When you save a tree file, it will save the branch lengths to a certain level of accuracy, but not always the full level of accuracy if your branch lengths have lots and lots of decimal places. When you read these trees back into R, a teeny tiny bit of the accuracy is lost which sometimes means that when R adds up the root-to-tip distances for each tip, they aren’t all exactly the same length, so therefore technically the tree is not ultrametric. For most implementations this tiny difference is not a big deal. A quick fix to this problem is to use the function force.ultrametric which essentially fudges the numbers to force the tree to be ultrametric. If your tree is genuinely non-ultrametric you should not use this function as it can introduce negative branch lengths which will break most functions you might want to use in R. Because these analyses only require a dated phylogeny and no additional data we do not need to do any extra data cleaning steps, unless you want to only look at a particular subset of the data. 11.2 Lineage through time plots and the \\(\\gamma\\) statistic Drawing lineage through time (LTT) plots is very easy in R using the phytools function ltt. This function will also calculate \\(\\gamma\\) statistic for you, but for this first example I have turned off that option using gamma = FALSE. # Draw LTT plot ltt(dragonflytree, gamma = FALSE) ## Object of class &quot;ltt&quot; containing: ## ## (1) A phylogenetic tree with 522 tips and 521 internal ## nodes. ## ## (2) Vectors containing the number of lineages (ltt) and ## branching times (times) on the tree. This looks like diversification in dragonflies is fairly constant through most of the phylogeny, except early in the tree where there are some larger bursts of speciation. There may also be a bit of slowdown in the later stages of the phylogeny too. If we wanted to we can also plot the tree and the LTT on the same plot as follows: # Plot LTT and tree ltt(dragonflytree, gamma = FALSE, show.tree = TRUE) ## Object of class &quot;ltt&quot; containing: ## ## (1) A phylogenetic tree with 522 tips and 521 internal ## nodes. ## ## (2) Vectors containing the number of lineages (ltt) and ## branching times (times) on the tree. We often also want to compare the observed LTT, to simulated LTTs assuming a pure-birth model. To do this we first need to simulate pure-birth trees that are the same age as our tree, and result in the same number of species. We can do this using the phytools function pbtree. This takes a few minutes to run… time for more cake/biscuits/tea/coffee/fresh air! I’m only using 10 simulations nsim = 10 below to save some time. For your own analyses, nsim = 100 (or higher) is likely to be give a better answer as it will explore more options. # Extract the number of species from the tree n_dragonflies &lt;- Ntip(dragonflytree) # Extract the total age of the tree age_dragonflies &lt;- max(nodeHeights(dragonflytree)) # Extract the speciation rate (number of new tips per unit time), assuming it follows an exponential curve (as expected under pure-birth) lambda_dragonflies &lt;-(log(n_dragonflies)-log(2))/age_dragonflies # Simulate 10 pure-birth trees using the above parameters sim_trees &lt;- pbtree(b = lambda_dragonflies, n = n_dragonflies, t = age_dragonflies, nsim = 10, quiet = TRUE, method = &quot;direct&quot;) We then use the ltt95 function to plot the 95% confidence intervals for the LTT based on the simulated set of pure-birth trees. This shows how much our observed LTT differs from the pure-birth null model (see Primer for more details). Note that if working with Bayesian posterior distributions of trees you can also use ltt95 to plot these. # Extract LTT plots for all simulations and plot the 95% confidence intervals ltt95(sim_trees, log = TRUE) # Add the original tree&#39;s LTT plot to the simulated data in red ltt(dragonflytree, add = TRUE, col = &quot;red&quot;, lwd = 2, gamma = FALSE, log = FALSE) ## Object of class &quot;ltt&quot; containing: ## ## (1) A phylogenetic tree with 522 tips and 521 internal ## nodes. ## ## (2) Vectors containing the number of lineages (ltt) and ## branching times (times) on the tree. It’s clear from this plot that the diversification of dragonflies is pretty close to the expectation under a pure-birth model. Fun with log transforms. The function ltt95 plots log number of lineages on the y-axis, but shows the real numbers of lineages on the y axis tick labels and spreads them out, rather than the actual logged values. This is fine until we try to add our original LTT plot from ltt back onto the graph! If we do that with log = TRUE in the ltt function, the line plots in completely the wrong place! A counter-intuitive solution to this, as shown in the code above, is to use log = FALSE instead which gives the correct plot! Finally, we can also use ltt to extract the value of the \\(\\gamma\\) statistic (Pybus and Harvey 2000): # Extract gamma ltt(dragonflytree, gamma = TRUE, plot = FALSE) ## Object of class &quot;ltt&quot; containing: ## ## (1) A phylogenetic tree with 522 tips and 521 internal ## nodes. ## ## (2) Vectors containing the number of lineages (ltt) and ## branching times (times) on the tree. ## ## (3) A value for Pybus &amp; Harvey&#39;s &quot;gamma&quot; statistic of ## gamma = -5.9763, p-value = 0. \\(\\gamma = -5.9763\\), and is significantly different from a pure-birth model of constant speciation rates (\\(p = 0\\), i.e. \\(p &lt; 0.001\\)). This confirms our suspicions from looking at the LTT plots above that dragonfly diversification rates have significantly decreased through time. If you get an NA here for gamma, try restarting RStudio and starting the exercise again, this fixed the issue for me. 11.3 BAMM: Bayesian Analysis of Macroevolutionary Mixtures The BAMM part of this practical is based on the Rabosky lab’s excellent resource for using BAMM found at http://bamm-project.org/index.html. I highly recommend reading it, especially if you want to use BAMM on your own data. BAMM (Bayesian Analysis of Macroevolutionary Mixtures; Rabosky (2014), Rabosky et al. (2014)) identifies discrete shifts in diversification rates at nodes of a tree (it can also investigate trait evolution but we will focus on diversification rates here), i.e places where diversification rates speed up or slow down. BAMM looks for rate shifts across the whole tree, so it can find one or more shifts. It does this using reversible jump Markov Chain Monte (MCMC) methods to automatically explore a vast universe of possible models (reversible jump MCMC is a special kind of MCMC algorithm; see Rabosky (2014) for details). It is biased towards simpler models (a common tactic in most evolutionary models, e.g. parsimony) so rarely results in lots of rate shifts. For each MCMC run (generally over 1 million iterations are run in these analyses), BAMM simulates speciation and extinction along the tree, extracts the number of rate shifts, and then works out the probability of that particular combination of rate shifts occurring. The resulting BAMM outputs are a sample of all possible combinations of rates and rate shifts across all models, in proportion to their posterior probability. The posterior, or distribution of results, from BAMM will thus contain lots of different combinations of rates and rate shifts, but those that occur more often across all the models will appear more often than those that occur rarely. In the posterior, we call each of these possible combinations distinct shift configurations. These are the most probable configuration of shifts from one model from the posterior. For example, one shift configuration may be a speed up at node 34 and a slow down at node 22 on model 10000. Each model in the posterior might have a different distinct shift configuration, or they might all be very similar. It depends on the dataset. The number of possible distinct shift configurations is huge. Eventually, if you ran BAMM for for long enough you’d find a shift on every branch in the tree (because the branches can show shifts due to the effect of the prior alone). We know that all the distinct shift configurations are possible but they aren’t equally probable. As mentioned above some may be common, and others rare. We need some way of summarising thousands of models, and taking this into account. There are two main approaches (and I’ll show you how to extract both from your BAMM outputs below). Overall best shift configuration You can get this by looking at the maximum a posteriori (MAP) probability shift configuration, i.e. the one that appeared the most often in the posterior. This is a bit like using a consensus tree in phylogenetics. However, for most real datasets, the best rate shift configuration is merely one of a large number of possible rate shift configurations that have similar probabilities. So this method is not preferred (also if you’ve bothered to fit over 1 million models it seems pointless to just get one result!). Credible shift sets An alternative way to present the results is to summarise all the distinct shift configurations. However, not all distinct shift configurations are going to be significant. Therefore, BAMM splits shifts into “important” ones that help explain the data (core shifts) and ones that are less important (or likely just due to priors) using marginal odds ratios. Specifically, BAMM computes the marginal odds ratio for each rate shift for every branch in the phylogeny. It then excludes all shifts that are unimportant using a pre-determined threshold value (usually 5). The remaining shifts are the credible shift set. These are usually reported in papers using BAMM. BAMM is easy to run which makes it a slightly dangerous! It’s easy to run with no idea of what you are doing or why. If you want to use it on your own data you’ll need to do a lot of reading and thinking first. Below I present a very simplified version so you can get a taste of what it does. 11.4 Running BAMM BAMM is a command line program written in C++. Analysis and visualization of the results are performed using the R package BAMMtools (Rabosky et al. 2014). We will not run BAMM itself in this practical, we will just use BAMMtools in R. Running BAMM using C++. BAMM is a command line program written in C++. To run BAMM, you need to download the program first, then you run it via the command line (Terminal for Macs or something like cygwin in Windows). Your command line window will need to be opened from a folder containing the following files: Your phylogeny A control file (there is an example with the datasets) Your data - if doing trait evolution analyses The control file specifies lots of information about how the BAMM model should be run, including MCMC settings (e.g. number of generations, number of chains, acceptance rates), the priors (including your expectation for the number of shifts, rates of speciation and extinction) and the initial values of the parameters. It is crucial that these settings are carefully thought through, and that multiple different combinations are tried to make sure models are converging etc. To get a sensible starting set of priors you can use the BAMMtools function setBAMMpriors. Running BAMM is then as simple as running this in the command line: bamm -c control.txt Assuming your control file is called control.txt, and your command line is running this in the folder containing the control file and your tree. 11.5 Looking at the output of BAMM using BAMMtools in R BAMM can take a long time to run for large datasets, and outputs several files with lots of different output. Rather than running BAMM here we are just going to investigate its outputs using the R package BAMMtools. I have created a control file for the dragonfly data (dragonflies_control.txt) and run this with BAMM. The output files we will use are: dragonflies_chain_swap.txt” dragonflies_event_data.txt” dragonflies_mcmc_out.txt” dragonflies_run_info.txt” Remember that BAMM is a Bayesian method, so rather than giving the one most likely result (like we get in maximum likelihood analyses), BAMM outputs a distribution of results, often containing thousands of results, that we call the posterior distribution (or just the posterior). 11.5.1 Assessing MCMC convergence Before we look at any of the exciting results, we need to check if our MCMC run actually converged. You should be familiar with this from building Bayesian phylogenies. Luckily BAMM is really helpful in what it outputs, so we can do this quite easily by looking at the dragonflies_mcmc_out.txt file. # Read in the file mcmc &lt;- read.csv(&quot;data/dragonflies_mcmc_out.txt&quot;) # Take a look at the plot plot(mcmc$logLik ~ mcmc$generation) This gives us a vague idea of whether your run has converged. SPOILER alert, it has because I played around with the parameters in BAMM until it did, and used the same priors as Letsch, Gottsberger, and Ware (2016b). Again, as with Bayesian phylogenies, we next want to discard some runs as burnin. Let’s discard the first 10% of samples. # What is 10% of rows? burnstart &lt;- floor(0.1 * nrow(mcmc)) # Remove the first 10% from the runs postburn &lt;- mcmc[burnstart:nrow(mcmc), ] We can also use the coda library to check the effective sample sizes (ESS) of the log-likelihood and the number of shift events present in each sample. # Extract ESS for the number of rate shifts parameter effectiveSize(postburn$N_shifts) ## var1 ## 273.7424 # Extract ESS for the log likelihood effectiveSize(postburn$logLik) ## var1 ## 219.238 In general, we want these to be at least 200, and larger for small datasets. Note that these are standard procedures for any Bayesian analysis, not anything magical invented just for BAMM. OK great now we know that our analysis converged we can look at the cool stuff. 11.5.2 Analysis of rate shifts in the dragonfly phylogeny We first need to load our phylogeny and the output of BAMM called the event data file. This contains most of the outputs we’ve mentioned above, such as the branch-specific speciation rates, positions of rate shifts etc. Note that we again exclude the first 10% of samples as burn-in using burnin = 0.1. # Read in the tree (if you haven&#39;t already) tree &lt;- read.tree(&quot;data/dragonflies-tree.tre&quot;) # This step may take a couple of minutes with a big dataset. edata &lt;- getEventData(tree, eventdata = &quot;data/dragonflies_event_data.txt&quot;, burnin = 0.1) ## Reading event datafile: data/dragonflies_event_data.txt ## ........... ## Read a total of 2501 samples from posterior ## ## Discarded as burnin: GENERATIONS &lt; 2490000 ## Analyzing 2252 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence The message this produces tells you how many samples were read and how many excluded as burnin. 11.5.2.1 How many rate shifts? The first thing we might like to know is how many rate shifts occur in our tree? We can do this using our event data (edata) to look at the posterior probabilities of models sampled by BAMM. # Look at the posterior for number of shifts summary(edata) This should show the posterior probabilities of each number of rate shifts observed during simulation of the posterior. This doesn’t tell us where they occur on the tree, just how many there are, and what their probability was. Here it looks like 3 shifts occurred most often, but with a range in number of shifts from 0 to 10. 11.5.3 Mean phylorate plot Next we might want to visualise these results on our tree. Mean phylorate plots are a way of visualizing the mean, model-averaged diversification rates along every branch of the tree. We can plot one using plot.bammdata. # Plot mean phylorate plot with legend and slighting larger line width (lwd) plot.bammdata(edata, legend = TRUE, lwd = 2) # If you want to make a large PDF version # pdf(&quot;data/dragonfly-phylorate-plot.pdf&quot;, height = 50, width = 50) # plot.bammdata(edata, lwd = 2, legend = TRUE, cex = 0.5, labels = TRUE) # dev.off() High rates are in red or yellow, and the low rates in blue. You can add the option labels = TRUE to get tip labels, but they’re really hard to read so you might need to look at a normal tree plot plot(tree, cex = 0.5) to see which species are involved here. I’ve provided a large PDF version of the tree in the folder where you can zoom in to see the details. In our dragonflies we see low rates (dark blues and blues) in most groups, but with higher rates near the base of the Libellulidae (the family that contains skimmers or perchers and their relatives, including my favourite the globe skimmer Pantala flavescens), and in one clade within the Libellulidae. It seems like there was a burst of diversification in the history of the clade, but rates have mostly slowed towards the present. See Letsch, Gottsberger, and Ware (2016b) for a much more thorough interpretation of these results. Help I get errors and no plots! Sometimes when working with these BAMMtools plots I’ve been getting an error Warning in gzfile(file, “wb”) : cannot open compressed file followed by a lot more red text. This appears to be a memory issue, as it happens when I’m making my laptop do something complex. It might only be on Mac, and/or only in RMarkdown, but if it happens when you try to plot things just try again. That works for me! We can also plot with slightly nicer colour-blind friendly colours from the package viridis (have a look at the options and choose your favourite). # Plot mean phylorate plot with a different colour palette (pal) taken # from the viridis package plot.bammdata(edata, lwd = 2, pal = plasma(4)) 11.5.4 Best single distinct shift configuration To extract the overall best distinct shift configuration, we use the maximum a posteriori (MAP) probability shift configuration, i.e. the one that appeared the most often in the posterior, as follows. # What is the single best rate shift configuration? best &lt;- getBestShiftConfiguration(edata, expectedNumberOfShifts = 1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 0 ## Analyzing 1 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence We can plot this as follows: # Plot mean phylorate plot for single best rate shift configuration plot.bammdata(best, lwd = 2, pal = plasma(4)) # Add the positions of the rate shifts addBAMMshifts(best, cex = 1.5, bg = &quot;white&quot;) The best single distinct shift configuration consists of two shifts, one on the branch leading to the Libellulidae, and one leading to a small clade within Libellulidae. 11.6 Credible sets of shifts Using just one answer is not very desirable, so let’s look at the shifts from across the posterior. As described above, the number of possible distinct shift configurations is huge, but not all these shifts are going to be significant. BAMM computes the marginal odds ratio for each a rate shift for every branch in the phylogeny. It then excludes all shifts that are unimportant using a pre-determined threshold value (usually 5). The remaining shifts are the credible shift set. To extract the credible shift set for our data, we can use the BAMMtools function credibleShiftSet. # Extract 95 % credible set of rate shift configurations css &lt;- credibleShiftSet(edata, expectedNumberOfShifts = 1, threshold = 5, set.limit = 0.95) # Look at the summary summary(css) ## ## 95 % credible set of rate shift configurations sampled with BAMM ## ## Distinct shift configurations in credible set: 516 ## ## Frequency of 9 shift configurations with highest posterior probability: ## ## ## rank probability cumulative Core_shifts ## 1 0.06216696 0.06216696 2 ## 2 0.05772647 0.11989343 3 ## 3 0.05461812 0.17451155 1 ## 4 0.04440497 0.21891652 2 ## 5 0.03507993 0.25399645 3 ## 6 0.02841918 0.28241563 2 ## 7 0.02664298 0.30905861 3 ## 8 0.02486679 0.33392540 2 ## 9 0.02353464 0.35746004 3 ## ## ...omitted 507 additional distinct shift configurations ## from the credible set. You can access the full set from your ## credibleshiftset object Here we see that there are 516 distinct shift configurations in our posterior. This highlights why using BAMM is a good idea - we can incorporate the distribution of results rather than giving just one best answer. We also see the nine of these account that for most of the probability of the data. In this case it’s only about 36%. BAMMtools chooses the first nine because it’s a good number to plot. You can plot fewer, to get six plots for example, using plot.credibleshiftset(css, plot.max = 6). We can generate phylorate plots for each of these shift configurations using plot.credibleshiftset # Plot top 9 from 95 % credible set of rate shift configurations plot.credibleshiftset(css) ## Omitted 507 plots The text above each phylorate plot gives the posterior probability of each shift configuration. Because many samples from the posterior can be assigned to each distinct shift configuration, the phylorate plots generated by plot.credibleshiftset are model-averaged mean rate parameters across all samples assignable to a given configuration. The shifts themselves are indicated with circles on branches, with the circle size being related to the probability of that particular shift. Note: this will set the plotting window to plot nine plots, so we need to take it back to the default of one plot using: # Return plot window to one plot only par(mfrow = c(1,1)) 11.7 Clade specific evolutionary rates We might also be interested in seeing if particular clades have different rates of speciation or extinction. This can be done in BAMMtools using the function getCladeRates, which computes the average rate for the chosen clade. Here we might be interested in seeing how different the rates are in our fastest clade, the Libellulidae, compared to the rest of our species. First we can look at the average rate across the whole tree using getCladeRates. # Extract speciation and extinction rates from the whole posterior allrates &lt;- getCladeRates(edata) allrates is a list with speciation and extinction rates, with the mean rate across all dragonflies for each sample in the posterior. We can extract the mean speciation rate for our tree and estimate the 90% highest posterior density (HPD) as follows. # Calculate overall mean speciation rate mean(allrates$lambda) ## [1] 0.02012068 # Calculate 90% highest posterior density for speciation rate quantile(allrates$lambda, c(0.05, 0.95)) ## 5% 95% ## 0.01792644 0.02336377 To get the rates for a specific clade, we just specify the node leading to that clade. In the our dragonfly example, node 771 is the node number of the Libellulidae clade (you can find identify node numbers using plot.phylo and nodelabels from the ape package). We can estimate the mean speciation rates for Libellulidae as follows: # Extract speciation and extinction rates for Libellulidae lib_rates &lt;- getCladeRates(edata, node = 771) # Calculate mean speciation rate for Libellulidae mean(lib_rates$lambda) ## [1] 0.02347474 # Calculate 90% highest posterior density for speciation rate for Libellulidae quantile(lib_rates$lambda, c(0.05, 0.95)) ## 5% 95% ## 0.01988954 0.02952452 As expected this is slightly higher than for dragonflies as a whole. To get the rates for everything but Libellulidae, we do the same thing, but add the argument nodetype = \"exclude\": # Extract speciation and extinction rates for everything but Libellulidae non_lib_rates &lt;- getCladeRates(edata, node = 771, nodetype = &quot;exclude&quot;) # Calculate mean speciation rate for everything but Libellulidae mean(non_lib_rates$lambda) ## [1] 0.01724914 # Calculate 90% highest posterior density for speciation rate for everything but Libellulidae quantile(non_lib_rates$lambda, c(0.05, 0.95)) ## 5% 95% ## 0.01497214 0.02008319 As expected this is slightly lower than for dragonflies as a whole, and quite a bit lower than for Libellulidae. Note that these are mean time-averaged clade-specific rates. If diversification rates have changed dramatically through the history of a particular clade, a single overall mean rate might not be particularly informative. This is likely true for Libellulidae which appears to have much higher rates at the base of the clade than towards the tips. 11.8 Rate-through-time analysis We may also want to visualise how rates of speciation change through time on our tree. We can do this by plotting a rate-through-time curve using the plotRateThroughTime function. # Plot speciation rate through time # This may take a minute or so plotRateThroughTime(edata, ratetype = &quot;speciation&quot;) The red line is the average speciation rate, with density shading showing the confidence intervals. The hump in the centre of the plot likely represents the higher rates at the base of the Libellulidae You can also use plotRateThroughTime to plot speciation through time curves for just a portion of your phylogeny. Here we can compare the whole tree, just Libellulidae (node 771), and everything but the Libellulidae. Note that to make the comparison easier I’ve set the y-axis limits using ylim so they are the same in all the plots. # Make the plotting window show two plots par(mfrow = c(1,3)) # This may take a minute or so # Plot speciation rate through time for all dragonflies plotRateThroughTime(edata, ylim = c(0, 0.2)) # Plot speciation rate through time for Libellulidae plotRateThroughTime(edata, node = 771, nodetype = &quot;include&quot;, ylim = c(0, 0.2)) # Plot speciation rate through time for everything but Libellulidae plotRateThroughTime(edata, node = 771, nodetype = &quot;exclude&quot;, ylim = c(0, 0.2)) # Return the plotting window to one plot par(mfrow = c(1,1)) We can also use plotRateThroughTime to plot the extinction rate, using ratetype = \"extinction\" or net diversification rate using ratetype = \"netdiv\". # Plot net diversification rate through time # This may take a minute or so # I&#39;ve also changed the colours of the line and confidence intervals plotRateThroughTime(edata, ratetype = &quot;netdiv&quot;, avgCol = &quot;darkgreen&quot;, intervalCol = &quot;palegreen&quot;) 11.9 Macroevolutionary cohort analysis A final nice feature of BAMMtools that we’ll play with here (there are others too) is the ability to easily perform a macroevolutionary cohort analysis (Rabosky et al. 2014). These are a good way of summarising which species/clades share correlated macroevolutionary dynamics i.e. similar rates of speciation etc. The basic idea is to visualize the pairwise probabilities that any two species share a common macroevolutionary rate regime. First we generate a cohort matrix, which contains the pairwise probabilities of shared macroevolutionary dynamics. We then pass this to the cohorts function, which generates the plot. cmat &lt;- getCohortMatrix(edata) cohorts(cmat, edata) Each cell of the cohort matrix corresponds to a pair of tip taxa from the phylogeny. You read these plots by drawing an imaginary line between any two tips of the tree - the colour of the matrix at their intersection is the probability that those taxa share a common rate dynamic. Species pairs that share a common rate dynamic are red, whereas species with different macroevolutionary dynamics are blue. This shows that Libellulidae and the other dragonflies have completely different macroevolutionary dynamics. Within each of these groups there is some variation, with certain clades being more similar to one another than others. For example, the small clade within Libellulidae (at the top of the phylogeny plot) that has a very high rate of evolution, has very different macroevolutionary dynamics to the other members of the Libellulidae. Check out this example with whales (http://bamm-project.org/bammgraph.html#whales-cohort) for an easier to interpret plot. And if you’re looking for a SciArt project, I always think these plots would make very lovely rugs with a slightly different colour scheme… 11.10 Assumptions and issues with BAMM Like all methods, BAMM has a number of important assumptions and issues. Second, the prior for the number of expected shifts will have a large effect on how many shifts are detected, particularly for long branches as the probability of seeing a shift due to the prior alone increases with branch length. To solve this BAMM estimates marginal odds ratios, scaling each marginal shift probability by the prior and branch length. You can (and should) check for this problem using the code below. # Plot the prior and the posterior plotPrior(mcmc, expectedNumberOfShifts = 1) There is some overlap, but it’s clear that the prior is different to the posterior, so this issue is not affecting our analyses. Predictions are better than post-hoc stories. BAMM is great, but it will often give answers you didn’t expect. It is not a good idea to just run a BAMM analysis and see what happens. Most phylogenies will contain some rate shifts, but if you don’t have hypotheses/predictions about what factors may influence diversification rates in your group then you’ll be stuck trying to invent reasons for these rate shifts after the fact. This is not a great way to do science, and can lead to some very odd conclusions if you’re just fishing around for ideas! Instead, thoroughly research your study group, think about why some species/groups/clades might diversify more rapidly than others, then run BAMM to see if your predictions are supported or not. Think about your sampling! Diversification rate analyses are powerful, exciting, and fairly easy to implement. As such they’re very tempting methods to use without really thinking carefully about the caveats, of which there are many! Incomplete sampling is a really big issue to consider. Sampling is generally incomplete and uneven; we never have every possible species in our phylogenies. If you only use living species, it is important to consider how extinct diversity may effect your conclusions. If you use living and fossil species you need to remember that for most groups the fossil record is patchy at best. If species are missing at random this is less of a problem, but if you’re missing a big chunk of diversity with a certain trait, or in a certain time period, your results may be meaningless at best, misleading at worst. 11.11 Summary You should now know how to plot LTT plots, calculate the \\(\\gamma\\) statistic, and analyses the outputs of BAMM using BAMMtools in R. 11.12 Practical exercises BAMMtools has a several inbuilt example datasets. For this practical exercise we will use the cetacean (whales; from (steeman2009radiation?)) and the ray-finned fishes (fishes; from (rabosky2013rates?)) datasets. Load the whales and fishes trees and BAMM outputs data into R (there is no mcmc.fishes file_) as follows. # Load whales data from BAMMtools data(whales) data(mcmc.whales) data(events.whales) # Load fishes data from BAMMtools data(fishes) data(mcmc.fishes) ## Warning in data(mcmc.fishes): data set &#39;mcmc.fishes&#39; not found data(events.fishes) # Read in the tree, mcmc, and edata for whales whales_tree &lt;- whales whales_mcmc &lt;- mcmc.whales whales_edata &lt;- getEventData(whales, eventdata = events.whales, burnin = 0.1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 995000 ## Analyzing 1801 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence # Read in the tree, mcmc, and edata for fishes fishes_tree &lt;- fishes fishes_edata &lt;- getEventData(fishes, eventdata = events.fishes, burnin = 0.1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 5 ## Analyzing 46 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence Then answer the following questions: How can we tell that the BAMM model for whales has converged? What is the effective sample size for number of shifts? What is the most common number of rate shifts in the posterior for the whales data? Plot the 95% credible set of rate shift configurations for whales. Plot the mean phylorate plot for fishes. What are the mean speciation rate and the 90% posterior density for mean speciation rate in fishes? References "],["answers-to-practical-exercises.html", "Chapter 12 Answers to practical exercises 12.1 Need to know R 12.2 Data wrangling 12.3 Phylogenies 12.4 Preparation 12.5 Phylogenetic signal 12.6 PGLS 12.7 MCMCglmm 12.8 Models of evolution with continuous traits 12.9 Models of evolution with discrete traits 12.10 Beyond simple macroevolutionary models of trait evolution 12.11 Diversification", " Chapter 12 Answers to practical exercises Below are all the questions and answers to the practical exercises at the end of each chapter. Note that you will need to make sure R knows where to find your data. My data are all in a data folder within the R Project I’m working with. Assuming you have not moved the data from where you downloaded everything, you will have a separate R Project and data folder for each of the chapters of this online book. 12.1 Need to know R No exercises 12.2 Data wrangling Using the frog-eyes-raw-data.csv data and R, create a new dataframe that contains only the columns genus_species, Family, and two new columns containing the species mean values for rootmass and eyemean. Note that we will talk more about this dataset in later exercises, but it comes from K. N. Thomas et al. (2020). There are many ways of doing this, but here’s how I would do this: # Load packages library(tidyverse) # Read in the data frog &lt;- read_csv(&quot;data/frog-eyes-raw-data.csv&quot;) # Take a look at it glimpse(frog) ## Rows: 640 ## Columns: 21 ## $ genus_species &lt;chr&gt; &quot;Acris_gryllus&quot;, &quot;Acris_gryllus&quot;, &quot;Acris_gryllus&quot;, &quot;Adenomus_kelaar… ## $ Order &lt;chr&gt; &quot;Anura&quot;, &quot;Anura&quot;, &quot;Anura&quot;, &quot;Anura&quot;, &quot;Anura&quot;, &quot;Anura&quot;, &quot;Anura&quot;, &quot;Anu… ## $ Family &lt;chr&gt; &quot;Hylidae&quot;, &quot;Hylidae&quot;, &quot;Hylidae&quot;, &quot;Bufonidae&quot;, &quot;Bufonidae&quot;, &quot;Hyperol… ## $ Genus &lt;chr&gt; &quot;Acris&quot;, &quot;Acris&quot;, &quot;Acris&quot;, &quot;Adenomus&quot;, &quot;Adenomus&quot;, &quot;Afrixalus&quot;, &quot;Af… ## $ Species &lt;chr&gt; &quot;gryllus&quot;, &quot;gryllus&quot;, &quot;gryllus&quot;, &quot;kelaartii&quot;, &quot;kelaartii&quot;, &quot;dorsali… ## $ tiplabel &lt;chr&gt; &quot;Acris_gryllus_Hylidae&quot;, &quot;Acris_gryllus_Hylidae&quot;, &quot;Acris_gryllus_Hy… ## $ SVL_mm &lt;dbl&gt; 22.6, 20.7, 16.7, 41.0, 41.7, 25.8, 24.7, 25.4, 48.9, 49.1, 62.5, 6… ## $ Mass_g &lt;dbl&gt; 1.1, 0.9, 0.6, 6.2, 6.5, 1.5, 1.3, 1.3, 7.0, 7.0, 14.0, 12.0, 30.1,… ## $ rootmass &lt;dbl&gt; 1.0322801, 0.9654894, 0.8434327, 1.8370906, 1.8662556, 1.1447142, 1… ## $ ED_right_mm &lt;dbl&gt; 3.3, 3.1, 2.9, NA, 4.7, 3.7, 3.6, 3.5, 7.4, 6.3, 8.3, 7.7, 8.7, 8.1… ## $ ED_left_mm &lt;dbl&gt; 2.3, 2.8, 2.5, 4.6, 4.7, 3.8, 3.5, 3.8, 7.2, 6.8, 7.8, 7.5, 8.3, 8.… ## $ eyemean &lt;dbl&gt; 2.80, 2.95, 2.70, 4.60, 4.70, 3.75, 3.55, 3.65, 7.30, 6.55, 8.05, 7… ## $ CD_right_mm &lt;dbl&gt; 3.1, 2.3, 2.0, NA, 3.8, 2.9, 2.8, 2.7, 5.7, 4.8, 5.8, 5.3, 6.7, 7.3… ## $ CD_left_mm &lt;dbl&gt; 2.5, 2.2, 2.3, 3.9, 4.2, 3.0, 2.7, 2.8, 5.3, 5.2, 5.9, 5.3, 6.6, 7.… ## $ cormean &lt;dbl&gt; 2.80, 2.25, 2.15, 3.90, 4.00, 2.95, 2.75, 2.75, 5.50, 5.00, 5.85, 5… ## $ Adult_habitat &lt;chr&gt; &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Ground-dwelling&quot;, &quot;Subfossor… ## $ Activity_period &lt;chr&gt; &quot;Both&quot;, &quot;Both&quot;, &quot;Both&quot;, &quot;Nocturnal&quot;, &quot;Nocturnal&quot;, &quot;Nocturnal&quot;, &quot;Noc… ## $ Mating_habitat &lt;chr&gt; &quot;Lentic water&quot;, &quot;Lentic water&quot;, &quot;Lentic water&quot;, &quot;Lotic water&quot;, &quot;Lot… ## $ Life_history &lt;chr&gt; &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;Free-living larvae&quot;, &quot;… ## $ Larval_habitat &lt;chr&gt; &quot;Lentic water&quot;, &quot;Lentic water&quot;, &quot;Lentic water&quot;, NA, NA, &quot;Lentic wat… ## $ Sex_dichromatism &lt;chr&gt; &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent… # Create a new dataframe called frog2 frog2 &lt;- # Start with the frog dataframe frog %&gt;% # Select only the columns of interest dplyr::select(genus_species, Family, rootmass, eyemean) %&gt;% # Group by species name, and Family (or summarise will try and average this too!) group_by(genus_species, Family) %&gt;% # Summarise to get the mean values summarise(mean_rootmass = mean(rootmass), mean_eyemean = mean(eyemean)) # Look at frog2 glimpse(frog2) ## Rows: 220 ## Columns: 4 ## Groups: genus_species [220] ## $ genus_species &lt;chr&gt; &quot;Acris_gryllus&quot;, &quot;Adenomus_kelaartii&quot;, &quot;Afrixalus_dorsalis&quot;, &quot;Agalychn… ## $ Family &lt;chr&gt; &quot;Hylidae&quot;, &quot;Bufonidae&quot;, &quot;Hyperoliidae&quot;, &quot;Hylidae&quot;, &quot;Phyllomedusidae&quot;, … ## $ mean_rootmass &lt;dbl&gt; 0.9470674, 1.8516731, 1.1091667, 2.1313583, 2.7840487, 1.9917795, 1.25… ## $ mean_eyemean &lt;dbl&gt; 2.816667, 4.650000, 3.650000, 7.375000, 8.700000, 6.166667, 4.116667, … # Write to file # This is commented out as I don&#39;t want to save this # write_csv(frog2, path = &quot;data/clean-frog-data.csv&quot;) 12.3 Phylogenies Read in the frog-tree.nex phylogeny from the folder. This comes from Feng et al. (2017). Then do the following: Read the tree into R. # Load packages library(ape) library(ggtree) library(tidyverse) # Read in the tree frogtree &lt;- read.nexus(&quot;data/frog-tree.nex&quot;) # Look at it frogtree ## ## Phylogenetic tree with 214 tips and 213 internal nodes. ## ## Tip labels: ## Ascaphus_truei_Ascaphidae, Leiopelma_hochstetteri_Leiopelmatidae, Alytes_obstetricans_Alytidae, Discoglossus_pictus_Alytidae, Barbourula_busuangensis_Bombinatoridae, Bombina_orientalis_Bombinatoridae, ... ## ## Rooted; includes branch lengths. Use R functions to determine: how many species are in the tree? # Look at the tree structure str(frogtree) # Or the whole tree frogtree There are 214 tips is the tree fully resolved? # Check whether the tree is binary/fully resolved is.binary(frogtree) Yes is the tree rooted? # Check whether the tree is rooted is.rooted(frogtree) Yes Use plot.phylo to plot the tree. Can you change the size of the tip labels? Can you make a fan-shaped plot? Can you change the colour of the tips and branches? # Plot the tree plot(frogtree, no.margin = TRUE, # to make sure it fills the whole space type = &quot;fan&quot;, # to make a fan tree cex = 0.6, # to reduce the tip label size (default = 1) tip.color = &quot;deeppink&quot;, # to change the tip colour edge.color = &quot;springgreen&quot;) # to change the branch colour # yuk! Save the tree to file as “mysuperdoopertree.nex” # Save the tree write.nexus(frogtree, file = &quot;data/mysuperdoopertree.nex&quot;) 12.4 Preparation In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data then prepare them for a PCM analysis. # Load packages library(ape) library(geiger) library(tidyverse) library(phytools) # Read in the tree primatetree &lt;- read.nexus(&quot;data/primate-tree.nex&quot;) # Look at the tree summary str(primatetree) ## List of 4 ## $ edge : int [1:446, 1:2] 227 228 229 230 231 232 233 234 234 235 ... ## $ edge.length: num [1:446] 4.95 17.69 19.65 8.12 4.82 ... ## $ Nnode : int 221 ## $ tip.label : chr [1:226] &quot;Allenopithecus_nigroviridis&quot; &quot;Cercopithecus_ascanius&quot; &quot;Cercopithecus_cephus&quot; &quot;Cercopithecus_cephus_cephus&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; # Plot the tree as a circular/fan phylogeny with small labels plot(primatetree, cex = 0.2, typ = &quot;fan&quot;, no.margin = TRUE) # Check whether the tree is binary # We want this to be TRUE is.binary(primatetree) ## [1] FALSE # It is FALSE so make the tree binary: primatetree &lt;- multi2di(primatetree) # Check whether the tree is binary now... is.binary(primatetree) ## [1] TRUE # Check whether the tree is rooted # We want this to be TRUE is.rooted(primatetree) ## [1] TRUE # Check whether the tree is ultrametric # We want this to be TRUE, but it is FALSE is.ultrametric(primatetree) ## [1] FALSE # Force ultrametric primatetree &lt;- force.ultrametric(primatetree) ## *************************************************************** ## * Note: * ## * force.ultrametric does not include a formal method to * ## * ultrametricize a tree &amp; should only be used to coerce * ## * a phylogeny that fails is.ultramtric due to rounding -- * ## * not as a substitute for formal rate-smoothing methods. * ## *************************************************************** # Read in the data primatedata &lt;- read_csv(&quot;data/primate-data.csv&quot;) ## Rows: 77 Columns: 9 ## ── Column specification ────────────────────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (3): Order, Family, Binomial ## dbl (6): AdultBodyMass_g, GestationLen_d, HomeRange_km2, MaxLongevity_m, SocialGroupSize, ... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. # Look at the data glimpse(primatedata) ## Rows: 77 ## Columns: 9 ## $ Order &lt;chr&gt; &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primate… ## $ Family &lt;chr&gt; &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Pitheciidae&quot;, &quot;Cebidae&quot;, &quot;Cebid… ## $ Binomial &lt;chr&gt; &quot;Ateles belzebuth&quot;, &quot;Ateles geoffroyi&quot;, &quot;Ateles paniscus&quot;, &quot;Calliceb… ## $ AdultBodyMass_g &lt;dbl&gt; 6692.42, 7582.40, 8697.25, 958.13, 558.00, 290.21, 123.94, 7077.66, … ## $ GestationLen_d &lt;dbl&gt; 138.20, 226.37, 228.18, 164.00, 153.99, 144.00, 134.44, 174.43, 148.… ## $ HomeRange_km2 &lt;dbl&gt; 2.28000, 0.73000, 1.36000, 0.02000, 0.32000, 0.02000, 0.00212, 0.510… ## $ MaxLongevity_m &lt;dbl&gt; 336.0, 327.6, 453.6, 303.6, 214.8, 201.6, 181.2, 252.0, 339.6, 276.0… ## $ SocialGroupSize &lt;dbl&gt; 14.50, 42.00, 20.00, 2.95, 6.85, 8.55, 6.00, 20.35, 26.30, 11.00, 16… ## $ SocialStatus &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1,… # Replace spaces with underscores in species names primatedata &lt;- primatedata %&gt;% mutate(Binomial = str_replace(string = Binomial, pattern = &quot; &quot;, replacement = &quot;_&quot;)) # Check it worked glimpse(primatedata) ## Rows: 77 ## Columns: 9 ## $ Order &lt;chr&gt; &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primate… ## $ Family &lt;chr&gt; &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Pitheciidae&quot;, &quot;Cebidae&quot;, &quot;Cebid… ## $ Binomial &lt;chr&gt; &quot;Ateles_belzebuth&quot;, &quot;Ateles_geoffroyi&quot;, &quot;Ateles_paniscus&quot;, &quot;Calliceb… ## $ AdultBodyMass_g &lt;dbl&gt; 6692.42, 7582.40, 8697.25, 958.13, 558.00, 290.21, 123.94, 7077.66, … ## $ GestationLen_d &lt;dbl&gt; 138.20, 226.37, 228.18, 164.00, 153.99, 144.00, 134.44, 174.43, 148.… ## $ HomeRange_km2 &lt;dbl&gt; 2.28000, 0.73000, 1.36000, 0.02000, 0.32000, 0.02000, 0.00212, 0.510… ## $ MaxLongevity_m &lt;dbl&gt; 336.0, 327.6, 453.6, 303.6, 214.8, 201.6, 181.2, 252.0, 339.6, 276.0… ## $ SocialGroupSize &lt;dbl&gt; 14.50, 42.00, 20.00, 2.95, 6.85, 8.55, 6.00, 20.35, 26.30, 11.00, 16… ## $ SocialStatus &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1,… # Check whether the names match in the data and the tree check &lt;- name.check(phy = primatetree, data = primatedata, data.names = primatedata$Binomial) # Look at check check ## $tree_not_data ## [1] &quot;Allenopithecus_nigroviridis&quot; ## [2] &quot;Allocebus_trichotis&quot; ## [3] &quot;Alouatta_caraya&quot; ## [4] &quot;Alouatta_sara&quot; ## [5] &quot;Aotus_azarae&quot; ## [6] &quot;Aotus_azarae_infulatus&quot; ## [7] &quot;Aotus_lemurinus_griseimembra&quot; ## [8] &quot;Aotus_nancymaae&quot; ## [9] &quot;Arctocebus_aureus&quot; ## [10] &quot;Arctocebus_calabarensis&quot; ## [11] &quot;Ateles_fusciceps&quot; ## [12] &quot;Ateles_geoffroyi_ornatus&quot; ## [13] &quot;Ateles_geoffroyi_vellerosus&quot; ## [14] &quot;Avahi_laniger&quot; ## [15] &quot;Avahi_occidentalis&quot; ## [16] &quot;Brachyteles_arachnoides&quot; ## [17] &quot;Bunopithecus_hoolock&quot; ## [18] &quot;Callicebus_donacophilus&quot; ## [19] &quot;Callithrix_(Mico)_emiliae&quot; ## [20] &quot;Callithrix_argentata&quot; ## [21] &quot;Callithrix_aurita&quot; ## [22] &quot;Callithrix_geoffroyi&quot; ## [23] &quot;Callithrix_humeralifera&quot; ## [24] &quot;Callithrix_kuhli&quot; ## [25] &quot;Callithrix_penicillata&quot; ## [26] &quot;Cercocebus_agilis&quot; ## [27] &quot;Cercocebus_atys&quot; ## [28] &quot;Cercocebus_torquatus&quot; ## [29] &quot;Cercopithecus_cephus_cephus&quot; ## [30] &quot;Cercopithecus_cephus_ngottoensis&quot; ## [31] &quot;Cercopithecus_diana&quot; ## [32] &quot;Cercopithecus_erythrogaster_erythrogaster&quot; ## [33] &quot;Cercopithecus_erythrotis&quot; ## [34] &quot;Cercopithecus_hamlyni&quot; ## [35] &quot;Cercopithecus_lhoesti&quot; ## [36] &quot;Cercopithecus_lowei&quot; ## [37] &quot;Cercopithecus_mona&quot; ## [38] &quot;Cercopithecus_petaurista&quot; ## [39] &quot;Cercopithecus_preussi&quot; ## [40] &quot;Cercopithecus_solatus&quot; ## [41] &quot;Cercopithecus_wolfi&quot; ## [42] &quot;Cheirogaleus_crossleyi&quot; ## [43] &quot;Chlorocebus_aethiops&quot; ## [44] &quot;Chlorocebus_pygerythrus&quot; ## [45] &quot;Chlorocebus_sabaeus&quot; ## [46] &quot;Chlorocebus_tantalus&quot; ## [47] &quot;Colobus_angolensis&quot; ## [48] &quot;Eulemur_albifrons&quot; ## [49] &quot;Eulemur_albocollaris&quot; ## [50] &quot;Eulemur_collaris&quot; ## [51] &quot;Eulemur_macaco_flavifrons&quot; ## [52] &quot;Eulemur_macaco_macaco&quot; ## [53] &quot;Eulemur_rubriventer&quot; ## [54] &quot;Eulemur_rufus&quot; ## [55] &quot;Eulemur_sanfordi&quot; ## [56] &quot;Euoticus_elegantulus&quot; ## [57] &quot;Galago_gallarum&quot; ## [58] &quot;Galago_zanzibaricus&quot; ## [59] &quot;Gorilla_gorilla_gorilla&quot; ## [60] &quot;Hapalemur_alaotrensis&quot; ## [61] &quot;Hapalemur_aureus&quot; ## [62] &quot;Hapalemur_griseus_griseus&quot; ## [63] &quot;Hapalemur_griseus_meridionalis&quot; ## [64] &quot;Hapalemur_occidentalis&quot; ## [65] &quot;Homo_sapiens&quot; ## [66] &quot;Hylobates_agilis&quot; ## [67] &quot;Hylobates_klossii&quot; ## [68] &quot;Hylobates_moloch&quot; ## [69] &quot;Hylobates_muelleri&quot; ## [70] &quot;Indri_indri&quot; ## [71] &quot;Leontopithecus_chrysomelas&quot; ## [72] &quot;Leontopithecus_chrysopygus&quot; ## [73] &quot;Lepilemur_aeeclis&quot; ## [74] &quot;Lepilemur_ankaranensis&quot; ## [75] &quot;Lepilemur_dorsalis&quot; ## [76] &quot;Lepilemur_edwardsi&quot; ## [77] &quot;Lepilemur_microdon&quot; ## [78] &quot;Lepilemur_mitsinjoensis&quot; ## [79] &quot;Lepilemur_randrianasoli&quot; ## [80] &quot;Lepilemur_ruficaudatus&quot; ## [81] &quot;Lepilemur_sahamalazensis&quot; ## [82] &quot;Lepilemur_seali&quot; ## [83] &quot;Lepilemur_septentrionalis&quot; ## [84] &quot;Lophocebus_aterrimus&quot; ## [85] &quot;Loris_lydekkerianus_grandis&quot; ## [86] &quot;Loris_lydekkerianus_malabaricus&quot; ## [87] &quot;Macaca_arctoides&quot; ## [88] &quot;Macaca_assamensis&quot; ## [89] &quot;Macaca_cyclopis&quot; ## [90] &quot;Macaca_hecki&quot; ## [91] &quot;Macaca_leonina&quot; ## [92] &quot;Macaca_maura&quot; ## [93] &quot;Macaca_nigra&quot; ## [94] &quot;Macaca_nigrescens&quot; ## [95] &quot;Macaca_ochreata&quot; ## [96] &quot;Macaca_ochreata_brunnescens&quot; ## [97] &quot;Macaca_pagensis&quot; ## [98] &quot;Macaca_siberu&quot; ## [99] &quot;Macaca_thibetana&quot; ## [100] &quot;Macaca_tonkeana&quot; ## [101] &quot;Mandrillus_leucophaeus&quot; ## [102] &quot;Microcebus_berthae&quot; ## [103] &quot;Microcebus_bongolavensis&quot; ## [104] &quot;Microcebus_danfossi&quot; ## [105] &quot;Microcebus_griseorufus&quot; ## [106] &quot;Microcebus_jollyae&quot; ## [107] &quot;Microcebus_lehilahytsara&quot; ## [108] &quot;Microcebus_lokobensis&quot; ## [109] &quot;Microcebus_mittermeieri&quot; ## [110] &quot;Microcebus_myoxinus&quot; ## [111] &quot;Microcebus_ravelobensis&quot; ## [112] &quot;Microcebus_sambiranensis&quot; ## [113] &quot;Microcebus_simmonsi&quot; ## [114] &quot;Microcebus_tavaratra&quot; ## [115] &quot;Nomascus_gabriellae&quot; ## [116] &quot;Nomascus_leucogenys&quot; ## [117] &quot;Nycticebus_coucang&quot; ## [118] &quot;Nycticebus_pygmaeus&quot; ## [119] &quot;Pan_troglodytes_schweinfurthii&quot; ## [120] &quot;Pan_troglodytes_troglodytes&quot; ## [121] &quot;Pan_troglodytes_verus&quot; ## [122] &quot;Papio_papio&quot; ## [123] &quot;Piliocolobus_badius&quot; ## [124] &quot;Pongo_abelii&quot; ## [125] &quot;Pongo_pygmaeus_pygmaeus&quot; ## [126] &quot;Presbytis_melalophos&quot; ## [127] &quot;Propithecus_coquereli&quot; ## [128] &quot;Propithecus_diadema&quot; ## [129] &quot;Propithecus_edwardsi&quot; ## [130] &quot;Propithecus_tattersalli&quot; ## [131] &quot;Pygathrix_nemaeus&quot; ## [132] &quot;Rhinopithecus_avunculus&quot; ## [133] &quot;Rhinopithecus_bieti&quot; ## [134] &quot;Rhinopithecus_brelichi&quot; ## [135] &quot;Rhinopithecus_roxellana&quot; ## [136] &quot;Rungwecebus_kipunji&quot; ## [137] &quot;Saguinus_geoffroyi&quot; ## [138] &quot;Saguinus_imperator&quot; ## [139] &quot;Saimiri_boliviensis_boliviensis&quot; ## [140] &quot;Saimiri_oerstedii&quot; ## [141] &quot;Trachypithecus_(Trachypithecus)_auratus&quot; ## [142] &quot;Trachypithecus_(Trachypithecus)_poliocephalus&quot; ## [143] &quot;Trachypithecus_cristatus&quot; ## [144] &quot;Trachypithecus_francoisi&quot; ## [145] &quot;Trachypithecus_johnii&quot; ## [146] &quot;Trachypithecus_phayrei&quot; ## [147] &quot;Trachypithecus_pileatus&quot; ## [148] &quot;Varecia_rubra&quot; ## [149] &quot;Varecia_variegata_variegata&quot; ## ## $data_not_tree ## character(0) # 149 species are in the tree but not the data # 0 species are in the data but not the tree # Remove species missing from the data mytree &lt;- drop.tip(primatetree, check$tree_not_data) # Remove species missing from the tree matches &lt;- match(primatedata$Binomial, check$data_not_tree, nomatch = 0) mydata &lt;- subset(primatedata, matches == 0) # Look at the tree summary str(mytree) ## List of 4 ## $ edge : int [1:152, 1:2] 78 79 80 81 82 83 84 85 86 87 ... ## $ edge.length: num [1:152] 4.95 17.69 19.65 8.12 4.82 ... ## $ Nnode : int 76 ## $ tip.label : chr [1:77] &quot;Cercopithecus_ascanius&quot; &quot;Cercopithecus_cephus&quot; &quot;Cercopithecus_mitis&quot; &quot;Cercopithecus_neglectus&quot; ... ## - attr(*, &quot;class&quot;)= chr &quot;phylo&quot; ## - attr(*, &quot;order&quot;)= chr &quot;cladewise&quot; ## - attr(*, &quot;RSS&quot;)= num 2.08e-08 # Look at the data glimpse(mydata) ## Rows: 77 ## Columns: 9 ## $ Order &lt;chr&gt; &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primates&quot;, &quot;Primate… ## $ Family &lt;chr&gt; &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Atelidae&quot;, &quot;Pitheciidae&quot;, &quot;Cebidae&quot;, &quot;Cebid… ## $ Binomial &lt;chr&gt; &quot;Ateles_belzebuth&quot;, &quot;Ateles_geoffroyi&quot;, &quot;Ateles_paniscus&quot;, &quot;Calliceb… ## $ AdultBodyMass_g &lt;dbl&gt; 6692.42, 7582.40, 8697.25, 958.13, 558.00, 290.21, 123.94, 7077.66, … ## $ GestationLen_d &lt;dbl&gt; 138.20, 226.37, 228.18, 164.00, 153.99, 144.00, 134.44, 174.43, 148.… ## $ HomeRange_km2 &lt;dbl&gt; 2.28000, 0.73000, 1.36000, 0.02000, 0.32000, 0.02000, 0.00212, 0.510… ## $ MaxLongevity_m &lt;dbl&gt; 336.0, 327.6, 453.6, 303.6, 214.8, 201.6, 181.2, 252.0, 339.6, 276.0… ## $ SocialGroupSize &lt;dbl&gt; 14.50, 42.00, 20.00, 2.95, 6.85, 8.55, 6.00, 20.35, 26.30, 11.00, 16… ## $ SocialStatus &lt;dbl&gt; 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1,… # Convert to a dataframe mydata &lt;- as.data.frame(mydata) # Check this is now a data frame class(mydata) ## [1] &quot;data.frame&quot; ## OPTIONAL # Write the cleaned data to a new file # write_csv(mydata, path = &quot;data/clean-primate-data.csv&quot;) # Write the cleaned tree to a new file # write.nexus(mytree, file = &quot;data/clean-primate-tree.nex&quot;) 12.5 Phylogenetic signal In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in the previous exercise which should save you some time). Then answer the following questions: # Load the packages library(ape) library(geiger) library(caper) library(tidyverse) library(phytools) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### What is \\(\\lambda\\) for log gestation length? # First create logGestation containing just log gestation length values logGestation &lt;- log(pull(mydata, GestationLen_d)) # Give log Eye names = species names at the tips of the phylogeny names(logGestation) &lt;- mydata$Binomial # Look at the first few rows head(logGestation) ## Ateles_belzebuth Ateles_geoffroyi Ateles_paniscus Callicebus_moloch ## 4.928702 5.422171 5.430135 5.099866 ## Callimico_goeldii Callithrix_jacchus ## 5.036888 4.969813 # Estimate lambda lambdaGestation &lt;- phylosig(mytree, logGestation, method = &quot;lambda&quot;, test = TRUE) # Look at the results lambdaGestation ## ## Phylogenetic signal lambda : 0.948326 ## logL(lambda) : 34.9204 ## LR(lambda=0) : 89.026 ## P-value (based on LR test) : 3.89649e-21 0.948 What is K for log gestation length? # Estimate Blomberg’s *K* KGestation &lt;- phylosig(mytree, logGestation, method = &quot;K&quot;, test = TRUE, nsim = 1000) # Look at the results KGestation ## ## Phylogenetic signal K : 0.775777 ## P-value (based on 1000 randomizations) : 0.001 0.776 What is D for social status? # Prepare the data for use in caper primate &lt;- comparative.data(phy = mytree, data = mydata, names.col = Binomial, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE) # Force the phylogeny to have polytomies again nrather than zero length branches primate$phy &lt;- di2multi(primate$phy) # Estimate D Dsocial &lt;- phylo.d(data = primate, names.col = tiplabel, binvar = SocialStatus, permut = 1000) # Look at the output Dsocial About -0.70. This is a randomisation test so may vary slightly 12.6 PGLS In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Let’s investigate the relationship between gestation length in Primates and their body size. Theory leads us to believe that bigger mammals have longer gestation lengths (compare mice to elephants), but is this true in Primates? Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit a PGLS model to investigate the relationship between log gestation length (y = log(GestationLen_d)) and log body size (x = log(AdultBodyMass_g)) in Primates. Don’t forget to look at the model diagnostics! # Load the packages library(ape) library(geiger) library(caper) library(tidyverse) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### # Prepare the data for use in caper primate &lt;- comparative.data(phy = mytree, data = mydata, names.col = Binomial, vcv = TRUE, na.omit = FALSE, warn.dropped = TRUE) # Check the list of dropped species is what you expected primate$dropped$tips primate$dropped$unmatched.rows # Fit a PGLS model model.pgls &lt;- pgls(log(GestationLen_d) ~ log(AdultBodyMass_g), data = primate, lambda = &quot;ML&quot;, bounds = list(lambda = c(0.01, 1))) ### Model diagnostics # Make a plotting window with 4 panes as there are four plots par(mfrow = c(2, 2)) # Now plot the model diagnostics plot(model.pgls) # Return the plot window to one pane for later plotting par(mfrow = c(1, 1)) # Look at the model outputs summary(model.pgls) # Plot the results ggplot(mydata, aes(x = log(AdultBodyMass_g), y = log(GestationLen_d))) + geom_point() + geom_abline(slope = coefficients(model.pgls)[2], intercept = coefficients(model.pgls)[1]) + theme_bw() Then answer the following questions. What is the maximum likelihood estimate of \\(\\lambda\\) in the model? # Look at the model outputs. Lambda is near the middle summary(model.pgls) 0.892 What are the confidence intervals on the maximum likelihood estimate of \\(\\lambda\\). How would you interpret these? # Extract the confidence intervals on lambda pgls.confint(model.pgls, &quot;lambda&quot;)$ci.val 0.753434, 0.966543. We are 95% certain that \\(\\lambda\\) is between these two values. Plot the \\(\\lambda\\) profile for the the maximum likelihood estimate of \\(\\lambda\\). What does it look like? # Create a likelihood profile of the lambda estimate lambda.profile &lt;- pgls.profile(model.pgls, &quot;lambda&quot;) # Plot the likelihood profile plot(lambda.profile) Is there a significant relationship between log gestation length and log body size? What is the slope of this relationship? # Look at the model outputs. summary(model.pgls) Yes. p &lt; 0.001. Slope = 0.105 \\(\\pm\\) 0.019 12.7 MCMCglmm In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Let’s repeat the analyses we did in the PGLS chapter but using MCMCglmm. We will investigate the relationship between gestation length in Primates and their body size. Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit a MCMCglmm model to investigate the relationship between log gestation length (y = log(GestationLen_d)) and log body size (x = log(AdultBodyMass_g)) in Primates. Don’t forget to check that the model has converged, and to look at the model diagnostics and for autocorrelation. # Load the packages library(tidyverse) library(ape) library(geiger) library(MCMCglmm) library(coda) ## MCMCglmm specific preparation # Remove zero length branches and replace with polytomies mytree2 &lt;- di2multi(mytree) # Remove node labels mytree2$node.label &lt;- NULL # Get the inverse vcv matrix for the phylogeny inv.phylo &lt;- inverseA(mytree2, nodes = &quot;TIPS&quot;, scale = TRUE)$Ainv # Set up priors for MCMCglmm # Inverse Wishart with V = 1 and nu = 0.02 # i.e. fairly uninformative priors prior &lt;- list(G = list(G1 = list(V = 1, nu = 0.02)), R = list(V = 1, nu = 0.02)) # Set number of iterations nitt &lt;- 1000000 # Set burnin burnin &lt;- 1000 # Sampling interval thin &lt;- 500 # Fit MCMCglmm model model_mcmcglmm &lt;- MCMCglmm(log(GestationLen_d) ~ log(AdultBodyMass_g), data = mydata, random = ~ Binomial, ginverse = list(Binomial = inv.phylo), prior = prior, nitt = nitt, thin = thin, burnin = burnin, verbose = TRUE) # Save the model # saveRDS(model_mcmcglmm, file = &quot;data/model_mcmcglmm_primate.rda&quot;) # Read in the saved model output run in advance to save time model_mcmcglmm &lt;- readRDS(&quot;data/model_mcmcglmm_primate.rda&quot;) ## Did the model converge? # Plot model diagnostics for MCMCglmm # For fixed effects plot(model_mcmcglmm$Sol) # Plot model diagnostics for MCMCglmm # For random effects plot(model_mcmcglmm$VCV) # Calculate ESS effectiveSize(model_mcmcglmm$Sol[, 1:model_mcmcglmm$Fixed$nfl, drop = FALSE])[[1]] ## [1] 1998 # Look for autocorrelation autocorr(model_mcmcglmm$VCV) ## , , Binomial ## ## Binomial units ## Lag 0 1.0000000000 -0.301495441 ## Lag 500 0.0008200833 -0.004268382 ## Lag 2500 0.0052744916 0.038062203 ## Lag 5000 -0.0446744855 0.014890222 ## Lag 25000 0.0104991347 -0.008261472 ## ## , , units ## ## Binomial units ## Lag 0 -0.301495441 1.000000000 ## Lag 500 0.012393397 0.002583728 ## Lag 2500 0.001343481 -0.015740264 ## Lag 5000 0.039810907 -0.009084549 ## Lag 25000 0.029927932 -0.018984469 What is \\(\\lambda\\) in the model? # Get lambda lambda &lt;- model_mcmcglmm$VCV[,&#39;Binomial&#39;]/ (model_mcmcglmm$VCV[,&#39;Binomial&#39;] + model_mcmcglmm$VCV[,&#39;units&#39;]) # Posterior mean of lambda mean(lambda) ## [1] 0.8699022 # Posterior mode of lambda posterior.mode(lambda) ## var1 ## 0.8925655 Posterior mean lambda is 0.870, the posterior mode is 0.893 What are the 95% credible intervals (HPD) around \\(\\lambda\\)? # HPD interval HPDinterval(lambda) ## lower upper ## var1 0.7615502 0.9613453 ## attr(,&quot;Probability&quot;) ## [1] 0.9499499 HPD interval of lambda is 0.762 to 0.961 Plot the \\(\\lambda\\) profile for the the maximum likelihood estimate of \\(\\lambda\\). # Plot the posterior for lambda ggplot(as.data.frame(lambda), aes(x = lambda))+ geom_density() + geom_vline(xintercept = posterior.mode(lambda), colour = &quot;red&quot;) + geom_vline(xintercept = HPDinterval(lambda)[[1]], linetype = &quot;dotted&quot;, colour = &quot;red&quot;) + geom_vline(xintercept = HPDinterval(lambda)[[2]], linetype = &quot;dotted&quot;, colour = &quot;red&quot;) + theme_bw() ## Don&#39;t know how to automatically pick scale for object of type &lt;mcmc&gt;. Defaulting to ## continuous. Is there a relationship between log gestation length and log body size? What is the slope of this relationship? ## Results # Look at summary of fixed effect results summary(model_mcmcglmm)$solutions ## post.mean l-95% CI u-95% CI eff.samp pMCMC ## (Intercept) 4.2876174 3.97118491 4.6374322 1998 0.0005005005 ## log(AdultBodyMass_g) 0.1050013 0.06455035 0.1460903 1998 0.0005005005 # Look at G-structure and R-structure posterior modes posterior.mode(model_mcmcglmm$VCV) ## Binomial units ## 0.040772793 0.005794703 # Look at G-structure and R-structure 95% credible intervals HPDinterval(model_mcmcglmm$VCV) ## lower upper ## Binomial 0.021550421 0.06927166 ## units 0.002813069 0.01043645 ## attr(,&quot;Probability&quot;) ## [1] 0.9499499 Yes! The slope is 0.105 (0.065-0.146). This is close to what we got using PGLS. 12.8 Models of evolution with continuous traits In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit Brownian and OU models to log adult body mass for Primates (AdultBodyMass_g). Then answer the following questions. # Load the packages library(ape) library(geiger) library(caper) library(tidyverse) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### # Reorder the data so the tree and data are in the same order mydata &lt;- mydata[match(mytree$tip.label, mydata$Binomial), ] # Create logBodyMass containing just log body mass values logBodyMass &lt;- log(pull(mydata, AdultBodyMass_g)) # Give log body mass names = species names at the tips of the phylogeny names(logBodyMass) &lt;- mydata$Binomial # Look at the first few rows head(logBodyMass) ## Cercopithecus_ascanius Cercopithecus_cephus Cercopithecus_mitis ## 8.171950 8.144644 8.525417 ## Cercopithecus_neglectus Cercopithecus_nictitans Erythrocebus_patas ## 8.580078 8.567299 8.982975 # Fit the Brownian model BM &lt;- fitContinuous(mytree, logBodyMass, model = c(&quot;BM&quot;)) # Fit the OU model OU &lt;- fitContinuous(mytree, logBodyMass, model = c(&quot;OU&quot;)) Which model fits best? # Could look at AIC weights... aic.scores &lt;- setNames(c(BM$opt$aic, OU$opt$aic), c(&quot;BM&quot;,&quot;OU&quot;)) aicw(aic.scores) ## fit delta w ## BM 160.1921 0 0.7310586 ## OU 162.1921 2 0.2689414 # Or just the raw AIC values BM$opt$aic ## [1] 160.1921 OU$opt$aic ## [1] 162.1921 BM but only by a small amount What is the rate of evolution for the Brownian model? # Look at the whole output BM ## GEIGER-fitted comparative model of continuous data ## fitted &#39;BM&#39; model parameters: ## sigsq = 0.028655 ## z0 = 6.773956 ## ## model summary: ## log-likelihood = -78.096042 ## AIC = 160.192084 ## AICc = 160.354246 ## free parameters = 2 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 100 ## frequency of best fit = 1.00 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates # Or just the one parameter BM$opt$sigsq ## [1] 0.0286548 0.028655 What is the strength of pull towards the long-term mean in the OU model? What does this value suggest? # Look at the whole output OU ## GEIGER-fitted comparative model of continuous data ## fitted &#39;OU&#39; model parameters: ## alpha = 0.000000 ## sigsq = 0.028655 ## z0 = 6.773956 ## ## model summary: ## log-likelihood = -78.096042 ## AIC = 162.192084 ## AICc = 162.520851 ## free parameters = 3 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 50 ## frequency of best fit = 0.50 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates # Or just the one parameter OU$opt$alpha ## [1] 2.571618e-42 &lt;0.0001, i.e. very close to zero which makes it very close to a Brownian model 12.9 Models of evolution with discrete traits In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Fit equal rates, symmetric rates and all rates different models to the social status variable for Primates (SocialStatus). Note that social status has two states: non-social (1) or social (2). # Load the packages library(ape) library(geiger) library(caper) library(tidyverse) library(phytools) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### # Reorder the data so the tree and data are in the same order mydata &lt;- mydata[match(mytree$tip.label, mydata$Binomial), ] # Create Social containing just social status values Social &lt;- pull(mydata, SocialStatus) # Give social status names = species names at the tips of the phylogeny names(Social) &lt;- mydata$Binomial # Look at the first few rows head(Social) ## Cercopithecus_ascanius Cercopithecus_cephus Cercopithecus_mitis ## 2 2 2 ## Cercopithecus_neglectus Cercopithecus_nictitans Erythrocebus_patas ## 2 2 2 # Fit the ER model equal &lt;- fitDiscrete(mytree, Social, model = &quot;ER&quot;) # Fit the ARD model ard &lt;- fitDiscrete(mytree, Social, model = &quot;ARD&quot;) Then answer the following questions. Which model fits best? # Using AIC weights aic.scores &lt;- setNames(c(equal$opt$aic, ard$opt$aic), c(&quot;equal&quot;, &quot;different&quot;)) aicw(aic.scores) ## fit delta w ## equal 38.98307 5.313651 0.06556956 ## different 33.66942 0.000000 0.93443044 # Or just the raw AIC values equal$opt$aic ## [1] 38.98307 ard$opt$aic ## [1] 33.66942 All rates different What is the transition rate from non-social (1) to social (2), and vice versa, in the all rates different model? What does this mean biologically? # Could look at the model output ard ## GEIGER-fitted comparative model of discrete data ## fitted Q matrix: ## 1 2 ## 1 -9.264914e-03 9.264914e-03 ## 2 1.476682e-17 -1.476682e-17 ## ## model summary: ## log-likelihood = -14.834711 ## AIC = 33.669423 ## AICc = 33.831585 ## free parameters = 2 ## ## Convergence diagnostics: ## optimization iterations = 100 ## failed iterations = 0 ## number of iterations with same best fit = 46 ## frequency of best fit = 0.46 ## ## object summary: ## &#39;lik&#39; -- likelihood function ## &#39;bnd&#39; -- bounds for likelihood search ## &#39;res&#39; -- optimization iteration summary ## &#39;opt&#39; -- maximum likelihood parameter estimates # Or plot the Q matrix as network plot.gfit(ard) 1 to 2 is ~0.009, 2 to 1 is very close to zero. Transitions from social (2) to non-social (1) behaviour are extremely rare. Plot ancestral state estimates of social status (from the ARD model) on the phylogeny. Is the root node estimated as being non-social or social? # Ancestral state estimation (ignore the warnings) ancestral_social &lt;- ace(Social, mytree, type = &quot;discrete&quot;, model = &quot;ARD&quot;) ## Warning in sqrt(diag(solve(h))): NaNs produced # Choose colours social_colours &lt;- c(&quot;deeppink&quot;, &quot;goldenrod&quot;) # Plot the tree with colours at the tips and nodes to represent socail status plot(mytree, cex = 0.5, adj = c(0.2), type = &quot;fan&quot;, no.margin = TRUE, show.tip.label = TRUE) tiplabels(pch = 16, col = social_colours[mydata$SocialStatus]) nodelabels(pie = ancestral_social$lik.anc, piecol = social_colours, cex = 0.5) legend(&quot;bottomleft&quot;, pch = 15, bty = &quot;n&quot;, legend = c(&quot;Non Social&quot;, &quot;Social&quot;), col = social_colours) Root is non-social Why didn’t I ask you to fit the symmetric model? Because with only two states the symmetric model is equivalent to the equal rates model 12.10 Beyond simple macroevolutionary models of trait evolution In the data folder there is another tree (primate-tree.nex) and dataset (primate-data.csv) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold, Matthews, and Nunn 2010). Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in a previous exercise which should save you some time). Using log body size (AdultBodyMass_g) as your continuous trait, and social status (SocialStatus) to define the selective regimes, fit (A) a multi-rate Brownian motion model and (B) an OU model with trait optima or long-term mean values for different evolutionary regimes but the same \\(\\sigma^2\\) and \\(\\alpha\\). Note that social status has two states: non-social (1) or social (2). Assume it is evolving according to an all rates different model. # Load the packages library(ape) library(geiger) library(caper) library(tidyverse) library(OUwie) ### Prepare the tree and the data as shown in the Preparation answer above ### ### This should mean you now have mydata and mytree ready to work with ### # Reorder the data so the tree and data are in the same order mydata &lt;- mydata[match(mytree$tip.label, mydata$Binomial), ] # Create Social containing just social status values Social &lt;- pull(mydata, SocialStatus) # Give social status names = species names at the tips of the phylogeny names(Social) &lt;- mydata$Binomial # Simulate node and tip values for 500 trees using the ARD model trees.ARD &lt;- make.simmap(mytree, Social, model = &quot;ARD&quot;, nsim = 500) ## make.simmap is sampling character histories conditioned on ## the transition matrix ## ## Q = ## 1 2 ## 1 -0.009264911 0.009264911 ## 2 0.000000000 0.000000000 ## (estimated using likelihood); ## and (mean) root node prior probabilities ## pi = ## 1 2 ## 0.5 0.5 # Store the results of the summary of the 500 trees summary.ARD &lt;- summary(trees.ARD) # Get the max likelihood state at each node best &lt;- apply(summary.ARD$ace[1:76, ], 1, which.max) # Assign regimes to the tree node labels mytree$node.label &lt;- levels(as.factor(mydata$SocialStatus))[best] # Make new dataset with just three columns for OUwie bodymass &lt;- data.frame(species = mydata$Binomial, regime = mydata$SocialStatus, trait = log(mydata$AdultBodyMass_g)) # Fit BMS model BMS &lt;- OUwie(mytree, bodymass, model = &quot;BMS&quot;, root.station = FALSE) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. # Fit OUM model OUM &lt;- OUwie(mytree, bodymass, model = &quot;OUM&quot;) ## Warning: An algorithm was not specified. Defaulting to computing the determinant and ## inversion of the vcv. ## Initializing... ## Finished. Begin thorough search... ## Finished. Summarizing results. Then answer the following questions: Which is the best fitting model? # Extract AICc scores from the models aic.scores &lt;- setNames(c(BMS$AICc, OUM$AICc), c(&quot;BMS&quot;, &quot;OUM&quot;)) # Get aic weights aicw(aic.scores) OUM If you were running these analyses for a publication, what additional models would you compare these models to? BM and single peak OU for sure. Possibly one or more of the more complex models if you had a good biological reason to In the multi rate Brownian model, which social status state has the higher rate of log body mass evolution? # Look at the model output BMS Non-social (1) has the higher rate of body mass evolution 0.04031313 Look at the parameter estimates of the multi peak OU model. Do you see anything worrying there? It might help to look at a histogram showing the body sizes of species in the non-social and the social categories. # Look at the output OUM # Plot the body sizes for the different groups ggplot(mydata, aes(x = log(AdultBodyMass_g), fill = as.factor(SocialStatus))) + geom_histogram(bins = 20, alpha = 0.5) + scale_fill_manual(values = social_colours) + facet_wrap(~SocialStatus, ncol = 1) + theme(legend.position = &quot;none&quot;) + theme_bw() The optima estimates are way off. Non-social species have a long-term mean log body size estimate of 5.918899, which makes sense looking at the histograms of the data. But social species have a long-term mean log body size estimate of 18607801, which if you exponentiate it is infinity. Even King Kong was not infinitely large! Something has clearly gone wrong here, but if we had not looked at the model parameters we would have said this was the best model…It’s likely we just don’t have enough data to fit a model that is as complex as this, so the parameter optimisations are not reliable. 12.11 Diversification BAMMtools has a several inbuilt example datasets. For this practical exercise we will use the cetacean (whales; from (steeman2009radiation?)) and the ray-finned fishes (fishes; from (rabosky2013rates?)) datasets. Load the whales and fishes trees and BAMM outputs data into R (there is no mcmc.fishes file_). # Load the packages library(ape) library(BAMMtools) library(coda) library(phytools) library(viridis) # Load whales data from BAMMtools data(whales) data(mcmc.whales) data(events.whales) # Load fishes data from BAMMtools data(fishes) data(mcmc.fishes) ## Warning in data(mcmc.fishes): data set &#39;mcmc.fishes&#39; not found data(events.fishes) # Read in the tree, mcmc, and edata for whales whales_tree &lt;- whales whales_mcmc &lt;- mcmc.whales whales_edata &lt;- getEventData(whales, eventdata = events.whales, burnin = 0.1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 995000 ## Analyzing 1801 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence # Read in the tree, and edata for fishes fishes_tree &lt;- fishes fishes_edata &lt;- getEventData(fishes, eventdata = events.fishes, burnin = 0.1) ## Processing event data from data.frame ## ## Discarded as burnin: GENERATIONS &lt; 5 ## Analyzing 46 samples from posterior ## ## Setting recursive sequence on tree... ## ## Done with recursive sequence Then answer the following questions: How can we tell that the BAMM model for whales has converged? What is the effective sample size for number of shifts? # Take a look at the plot plot(whales_mcmc$logLik ~ whales_mcmc$generation) # What is 10% of rows? burnstart &lt;- floor(0.1 * nrow(whales_mcmc)) # Remove the first 10% from the runs postburn &lt;- whales_mcmc[burnstart:nrow(whales_mcmc), ] # Extract ESS for the number of rate shifts parameter effectiveSize(postburn$N_shifts) ## var1 ## 1587.998 # Extract ESS for the log likelihood effectiveSize(postburn$logLik) ## var1 ## 1091.479 The plot looks like a furry caterpillar (!), and effective sample sizes are well over 200. What is the most common number of rate shifts in the posterior for the whales data? # Look at the posterior for number of shifts summary(whales_edata) ## ## Analyzed 1801 posterior samples ## Shift posterior distribution: ## ## 0 0.0770 ## 1 0.6600 ## 2 0.2100 ## 3 0.0430 ## 4 0.0110 ## 5 0.0022 ## ## Compute credible set of shift configurations for more information: ## See ?credibleShiftSet and ?getBestShiftConfiguration 1 Plot the 95% credible set of rate shift configurations for whales. # Extract 95% credible set of rate shift configurations whales_css &lt;- credibleShiftSet(whales_edata, expectedNumberOfShifts = 1, threshold = 5, set.limit = 0.95) # Look at the summary summary(whales_css) ## ## 95 % credible set of rate shift configurations sampled with BAMM ## ## Distinct shift configurations in credible set: 4 ## ## Frequency of 4 shift configurations with highest posterior probability: ## ## ## rank probability cumulative Core_shifts ## 1 0.46418656 0.4641866 1 ## 2 0.28928373 0.7534703 1 ## 3 0.14158801 0.8950583 1 ## 4 0.09272626 0.9877846 0 # Plot 95 % credible set of rate shift configurations plot.credibleshiftset(whales_css) ## Omitted 0 plots Plot the mean phylorate plot for fishes. # Plot mean phylorate plot with legend and slighting larger line width (lwd) plot.bammdata(fishes_edata, legend = TRUE, lwd = 2) What are the mean speciation rate and the 90% posterior density for mean speciation rate in fishes? # Extract speciation and extinction rates from the whole posterior allrates &lt;- getCladeRates(fishes_edata) # Calculate overall mean speciation rate mean(allrates$lambda) ## [1] 0.09470252 # Calculate 90% highest posterior density for speciation rate quantile(allrates$lambda, c(0.05, 0.95)) ## 5% 95% ## 0.09020489 0.09960825 Mean = 0.09470252, 5% = 0.09020489, 95% = 0.09960825 References "],["common-mistakes-using-pcms-in-r.html", "Chapter 13 Common mistakes using PCMs in R 13.1 Good practice to prevent errors 13.2 Common errors 13.3 What to do if you get an Error message 13.4 What to do if you get a Warning message", " Chapter 13 Common mistakes using PCMs in R Throughout these exercises I’ve tried to mention common mistakes you might come across when working with your own data. I’ve collated some of them here for easy reference. Note that all of these issues are really common; I do most of them on a daily basis! 13.1 Good practice to prevent errors There are a couple of ways you can help yourself avoid errors. Look at your data (and tree) before beginning any analysis to check it read in correctly. Check the exact spelling (and capitalisation) of your variable names. For example, in the datasets we have used the tip names have been called tiplabel, Species and Binomial. It’s important to check what things are called in your data before you start the analyses. 3. Check (using glimpse or str or class) what kind of data R thinks each of your variables is. If a function expects a factor, it will not work if R thinks your variable is a character. Finally, make sure to run through your code slowly and carefully, making copious notes and comments to yourself (preceded by # so R ignores them) to remind yourself what you are doing and why. Always check the output at every stage of the analysis. Every time you modify the data or tree, check that this happened as you expected. This can save you from lots of downstream issues. 13.2 Common errors 13.2.1 Standard R issues Typos. Incorrectly spelled variable names. Missing brackets, parentheses, commas, or quotation marks. The dreaded + If you see the + rather than the prompt &gt; at the start of the line of code you’re trying to run, it suggests something didn’t get completed in the code above. Maybe a missing parenthesis or comma or quotation mark? You should fix this before moving forwards. To quickly get rid of the + just put your cursor into the Console tab and then press Esc (escape). R cannot find name of function. Could this be a typo? Check the exact spelling of the function. Have you loaded the package that contains the function? Remember you need to tell R to load the packages every time you start a new R session and want to use functions from these packages using the function library. Did you install the package that contains the function? Install the package using install.packages(\"package name\"). See Chapter 1 for more details of common problems installing packages. R cannot find your data. Is there a typo in the name? Did you unzip the data? R cannot work with stuff in zipped files. Is the data in the place R is looking for it? Check the Files tab in the bottom right hand panel in a standard R Studio set up. Can you see your data there? Is it in the correct folder? Using the wrong data Are you working with the correct data? If you use generic names like mydata and mytree (like I’ve done throughout this book) it’s easy to accidentally use the wrong mydata. You can avoid this by giving your variables more descriptive names. 13.2.2 Issues with the tree or data Tree is not ultrametric. Use is.ultrametric to check. Fix using force.ultrametric in the phytools package. Tree is not rooted. Use is.rooted to check. Fix using root. Tree is not fully bifurcating, i.e. it has polytomies. Use is.binary to check. Fix using multi2di. Species names in the tree and the data do not match. Use name.check in the geiger package to check. If they do not match, but they should do, check for spaces rather than underscores in species names, differences in capitalisation, or any words (like family names or numbers) added to tip label names. Also ensure you use the variable name from the data set that contains the species names. Species names have not been added to the data. Check you have the species names attached to any dataset/variable you are working with. Some functions require that the species names are rownames. Others require a vector for the variable with names added using the names function. Species in the tree and the data are not in the same order. Some functions require the data and the tree to be ordered so that species are in the same order in both. Fix using `` Data is a tibble not a data frame. Most functions for pcms require a data frame as input. Check using class or str. Convert to a data fram using as.data.frame Variable is character not a factor. Check using glimpse or str. Fix using as.factor. If you need to convert something to numeric use as.numeric, or if you need to convert something to character use as.character and so on. Optimisation errors. This generally happens when the likelihood profile for one of your parameters is really flat, and the model is getting stuck near one of the bounds (i.e. limits) of the parameter. To fix this error you need to change the bounds (i.e. upper and lower values) on the parameter being optimized. First establish which bound is the proble, then change it to something a little bigger/smaller than the default upper/lower bound until it works. See the appropriate chapters for more details on specific function. Unrealistic parameter estimates. As mentioned in the relevant chapters, you must check your parameter estimates make sense. If these are wildly unrealistic it suggests you don’t have enough data to fit a model of the complexity you’re trying to fit. There’s no solution to this, aside from gathering more data. 13.3 What to do if you get an Error message Don’t panic! Error messages are common and there might be an easy fix. Read the message carefully s some will indicate the problem and you’ll be able to fix it quickly. If you don’t know what issue the message is referring to, first make sure the basics are correct. Check your code carefully for typos, missing parentheses etc. Ensure that you are using the right data and tree, and that you have used the correct variable names and function names etc. Run through all your code again slowly to check you didn’t miss an important step. Look at the data (and the tree) at every stage to make sure they are changing as you expect them to. Restart R Studio, and clear the Global Environment by clicking the little broom button on the top right hand panel in a standard R Studio set up. Then try to run the code again. If none of these basic fixes work move onto the Error message itself. Read the message again and see if you can work out what the issue is. If you can’t work out what the error means, try Googling it (remove any words specific to your data from it first). Google may be able to tell you what the issue is and help you find solutions on websites like Stack Overflow. Finally if none of this helps, ask for help. I would first advise asking local colleagues/supervisors etc. Then expanding to either emailing the package maintainer or raising an issue on GitHub. To get help you will need to provide a reproducible example so the person helping you can run the code on their computer. So you need to provide the code, the data (and the tree) and the error message you are getting. 13.4 What to do if you get a Warning message Don’t panic! Warning messages are common and there might be an easy fix. Read the warning carefully. Try to understand what it means. You may need to Google it. In many cases it is nothing to worry about, but it may be alerting you to a serious issue with your analysis. Always check warning messages, do not ignore them. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
