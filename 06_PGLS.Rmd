# Phylogenetic Generalised Least Squares (PGLS) in R
The aims of this exercise are to learn how to use R to perform Phylogenetic Generalised Least Squares (PGLS) analyses.

We will be using the evolution of eye size in frogs as an example. The data and modified tree come from Thomas et al 2020 (CITE PROPERLY), and the original tree comes from Feng et al (2019; CITE PROPERLY). I've removed a few species and a few variables to make things a bit more straightforward. If you want to see the full results check out Thomas et al 2020 (CITE PROPERLY)!

You will also need to install the following packages: 

* `ape`
* `geiger`
* `treeplyr`
* `caper`
* `tidyverse`

***
## Preparation

To begin we need to load the packages for this practical.

```{r, message = FALSE}
# Load the packages
library(ape)
library(geiger)
library(treeplyr)
library(caper)
library(tidyverse)
```

Next we need to prepare the tree and data for the analyses. In the `04-Preparation.Rmd` exercise we read in our tree and data, checked them, and matched them so only species in both were retained. Please refer to that exercise for more details on how and why we do these things, or run through it now if you haven't previously. 

It is important to do these things before beginning a phylogenetic comparative analysis, so let's run through that code again here.

```{r}
# Read in the data
frogdata <- read_csv("data/frog-eyes.csv")
# Check everything loaded corrected
glimpse(frogdata)
```

To load the tree we will use `read.nexus`.
```{r}
# Read in the tree
frogtree <- read.nexus("data/frog-tree.nex")
# Check it loaded correctly
str(frogtree)
```

Remember to check the tree is dichotomous, i.e. has no polytomies, and rooted. 

```{r}
# Check whether the tree is binary
# We want this to be TRUE
is.binary.tree(frogtree)
# Check whether the tree is rooted 
# We want this to be TRUE 
is.rooted(frogtree)
```

Next check that the species names match up in the tree and the data. This should reveal any typos and/or taxonomic differences that need to be fixed before going any further.

```{r}
# Check whether the names match in the data and the tree
check <- name.check(phy = frogtree, data = frogdata, 
                    data.names = frogdata$tiplabel)
# Look at check
check
```
Here all the excluded species are excluded because they are genuinely missing, not because of any typos, so we can move on.

Next we combine the tree and data to exclude species that are not in both, using the `treeplyr` function `make.treedata`.

```{r}
# Combine and match the tree and data
frogstuff <- make.treedata(tree = frogtree,  data = frogdata, 
                              name_column = "tiplabel")

# Look at the tree
frogstuff$phy
# Look at the data
glimpse(frogstuff$dat)
```

Then we replace the removed species names column, and save the data as a dataframe for later analyses.

```{r}
# Make a new column called Binomial with the tip labels in it
frogstuff$dat$Species <- frogstuff$phy$tip.label
# Force mydata to be a data frame
mydata <- as.data.frame(frogstuff$dat)
```

Finally we save the tree:

```{r}
# Save tree as mytree
mytree <- frogstuff$phy
```

Note that is is possible to use the `make.treedata` object directly to run some analyses, but we have saved these separately here as many PCMs cannot work with this.

Now we're ready to run our analyses!

## Phylogenetic generalized least squares models (PGLS)

Let's investigate the relationship between eye size in frogs and their body size. Theory leads us to believe that bigger animals will have bigger eyes, but is this true in frogs?

We can first quickly look at the phylogenetic pseudoreplication on the graph by colouring the points by family.

```{r}
# Plot eyesize against body mass, coloured by family
ggplot(mydata, aes(x = log(mass), 
                        y = log(eyesize), 
                        colour = Family)) +
  geom_point() +
  theme_bw()
```

This is a bit messy because there are a lot of families, but note how certain families are clustered on the graph. It's clear that close relatives are more similar than distant relatives. So we need to account for phylogenetic non-independence, both because of the statistical issues caused by this *and* because it's a better way to model the biological reality of our question. We know frog species evolve from other frog species, and that close relatives will therefore be similar, so we should add this into our models.
 
There are several ways of accounting for phylogenetic non-independence in your analyses. Here we will use phylogenetic generalized least squares (PGLS). Another popular earlier method is independent contrasts (PIC). This method is really similar to PGLS, in fact it is just a special kind of PGLS where $\lambda$ is equal to 1. 

PGLS offers some important advantages over independent contrasts. The model of trait evolution can be more flexible i.e., it can depart from a strict Brownian motion process ($\lambda$ or *K* = 1). Different scaling parameters ($\lambda$, $\kappa$, and $\delta$) can be incorporated in the analysis, which can significantly improve the fit of the data to the model and thus also improve the estimation of the trait correlation. Another advantage of PGLS is that the intercept of the regression is not forced to be zero. See the *Primer* for more details on the theory underlying PICs and PGLS.

### Fitting PGLS models in R

To perform PGLS models in R, `caper` requires you to first combine the phylogeny and data into one object using the function `comparative.data`. This is similar to what we did with `make.treedata`, but it does some stuff that is particular to how `caper` works so we still need to do this here.

Note that `vcv = TRUE` stores a variance covariance matrix of your tree (you will need this for the `pgls` function). `na.omit = FALSE` stops the function from removing species without data for all variables. `warn.dropped = TRUE` will tell you if any species are not in both the tree and the data and are therefore dropped from the comparative data object. Here we won't drop any species because we already did this using `make.treedata`.

```{r}
frog <- comparative.data(phy = mytree, data = mydata, 
                            names.col = Species, vcv = TRUE, 
                            na.omit = FALSE, warn.dropped = TRUE)
```

If you do need to drop species, this function will give a warning telling you that some species have been dropped.
You can view the dropped species using:

```{r}
frog$dropped$tips
frog$dropped$unmatched.rows
```

**Always** make sure you check the list of dropped species is what you expected, it often reveals typos in your species names, or mismatches in taxonomies used etc. Here we already fixed this problem, so nothing is listed.

The function for PGLS analyses in `caper` is `pgls`. To fit a model which uses the Maximum Likelihood (ML) estimate of $\lambda$ we use the following code:

```{r}
# Fit a PGLS model
model.pgls <- pgls(log(eyesize) ~ log(mass), 
                   data = frog, lambda = "ML")
```

To look at the output we use `anova`:

```{r}
# Look at the model outputs
anova(model.pgls)
```

It's always good to look at the output using `anova` first. This uses sequential sum of squares to tell you whether a model including your predictor variable(s) is a better fit than a model without your predictor variable(s). For a complex model with lots of predictors this is the easiest way to find out the answer to the question you were asking. Here we asked "is there a significant effect of log(mass) on log(eyesize)?". The answer is yes, there is a significant effect of log(mass) on log(eyesize). If we were reporting this result in a report/thesis or paper we would do it as follows:

> There was a significant effect of log mass on log eyesize (PGLS: F = 906.82, df = 1,208, p < 0.001, $\lambda$ = 0.98).

This is exactly how you would report the output of any non-phylogenetic linear model, except with the $\lambda$ value included.

We might also be interested in the model coefficients, i.e. the intercept and slope. To do this, just like we do for normal `lm`, we use `summary`: 

```{r}
# Look at the model coefficients
summary(model.pgls)
```

We'd report this in a paper/report/thesis as:

> There was a significant positive relationship between log mass and log eyesize (PGLS: slope $\pm$ SE = 0.277 $\pm$ 0.009, t = 30.113, df = 208, p < 0.001, $\lambda$ = 0.976).

Again this is exactly the same as we would do for `lm` without the phylogenetic component, except we include $\lambda$.

Note that as well as the standard regression outputs, the summary output includes the estimated ML value of $\lambda$ (0.976) and p values from likelihood ratio tests showing whether the ML $\lambda$ is significantly different from 0 or 1. 

$\kappa$ and $\delta$ are also tree transformations which can improve the fit of the data to the tree. It is also possible to use `pgls` to optimise $\kappa$ or $\delta$  (using kappa = "ML" or delta = "ML" instead of lambda = "ML" in the code above). We will not cover this here. 

```{block, type = "info"}
Note that optimizing more than one of these parameters at the same time is not advisable because it would be impossible to interpret the results!
```

We can also plot the results as follows:

```{r}
ggplot(mydata, aes(x = log(mass), 
                        y = log(eyesize))) +
  geom_point() +
  geom_abline(slope = coefficients(model.pgls)[2], 
              intercept = coefficients(model.pgls)[1]) +
  theme_bw()
```

Note that `coefficients(model.pgls)` gives us the intercept `coefficients(model.pgls)[2]`, and slope `coefficients(model.pgls)[2]` of the line, allowing use to use `geom_abline` to fit the line.

```{r}
# Check out the model coefficients (intercept and slope)
coefficients(model.pgls)
```

### Model diagnostics for PGLS models
You must always check model diagnostic plots whenever you fit a model in R to check that your data meet the assumptions of the model. Ideally you should do this BEFORE looking at `anova` or `summary` as if your assumptions are not met, then the model is useless and needs to be changed before you can use it to extract p values etc.

The method for getting model diagnostics for PGLS is the same for OLS, independent contrasts and PGLS models (though the graphs are slightly different) - we just use the function `plot`. 

```{block, type="info"}
You might recall we also use `plot` to plot phylogenies and other things. `plot` is one of a set of clever functions in R that uses an _ifelse_ statement to decide what kind of plot it should do. When you ask R to `plot` something, it first determines what _class_ of object it is. It then chooses the correct version of `plot` for that class. In this case the function it is actually using to plot the model diagnostics for PGLS is `plot.pgls`.
```

To get model diagnostic plots for PGLS:

```{r}
# First make a plotting window with four panes as there are four plots
par(mfrow = c(2, 2))
# Now plot the model diagnostics
plot(model.pgls)
# Return the plot window to one pane for later plotting
par(mfrow = c(1, 1))
```

If you've no idea what these diagnostic plots are for I suggest reading up on this. Getting Started with R is a good place to start (CITE), but plots 2 and 3 at least should have been covered in whatever standard statistics course you've taken previously. In brief:

1. In plot 1 (upper left-hand plot) you should not see any data with a studentized residual > $\pm$ 3. Any species with such large residuals may overly influence the results of the regression (see Jones and Purvis 1997). Often these are the result of measurement error associated with species pairs joined by very short branches. You should report results with and without these outliers included, to see how much of an impact they have on your results.

2. In plot 2 (upper right-hand plot), the Normal Q-Q plot, the points should approximately fall on the line. This tests for normality of residuals, one of the assumptions of linear models. Note that Q-Q plots often look a bit messy, but unless you plan to use your PGLS model to predict values for your response variable *outside of the range of the predictors used in your model* (i.e. if you fitted a model of mass vs eyesize with mass rangining from 1g to 100g and then you wanted to use the model to predict eysize when  mass was 1000g) it isn't too much of a problem. The other diagnostic plots are much more important.

3. In plot 3 (lower left-hand plot), the Fitted versus Residuals plot, we hope to see a fairly random scattering of points, often referred to as a sky at night distribution. This diagnostic plot is related to the systematic component of the model - any pattern here (e.g. strong positive or negative slopes, or humped or U-shaped patterns) suggests that the model has not been correctly specified. This might reflect a missing variable or interaction term, or that you need to transform your variables. 

4. In plot 4 (lower right-hand plot), the Fitted versus Observed plot, we should see a correlation among the observed values and fitted values in the model. This will vary depending on how good the model fit is. 

It takes practice to know what is "good", "bad" and "acceptable" with these plots. Here I would say the plots above are fine.

### Likelihood profiles for $\lambda$ in PGLS models
You should also look at the __likelihood profiles__ for branch length transformations in PGLS models using `pgls.profile`:

```{r}
# Create a likelihood profile of the lambda estimate
lambda.profile <- pgls.profile(model.pgls, "lambda")
# Plot the likelihood profile
plot(lambda.profile)
```

This graph shows the likelihood profile of $\lambda$ in our model. 
Ideally you want a line with an obvious peak/optimum, rather than a flat line which would suggest $\lambda$ could be anything. You can see that the optimum (the peak of the curve) is at 0.976 as estimated in our PGLS model. The dotted red lines are the 95\% confidence intervals on $\lambda$ for our model. `pgls.confint` prints out these numbers in `$ci.val` if you want to know the exact numbers.

```{r}
# Extract the confidence intervals on lambda
pgls.confint(model.pgls, "lambda")$ci.val
```

Note that because our $\lambda$ value is so close to 1, and this is the upper bound for $\lambda$ in a PGLS model, the upper confidence interval is NA. If you needed to report the upper and lower confidence intervals (and this is good practice if they cover a large range of numbers), you could report the upper confidence interval here as 1. If the opposite situation occurred for a $\lambda$ close to 0, you would use the lower confidence interval of 0.

***

### A PGLS example with more than one variable

Let's fit a more complex model now. We might be interested in whether log(eyesize) is correlated with both mass and habitat, so let's fit that model...

```{r}
# Fit a PGLS model
model.pgls2 <- pgls(log(eyesize) ~ log(mass) * as.factor(Adult_habitat), 
                   data = frog, lambda = "ML")
```

Two things to note. 

First, as with normal `lm` in R, `*` means fit each predictor as a main effect AND include the interaction between them too. `log(mass) * as.factor(Adult_habitat)` is actually shorthand for typing `log(mass) + as.factor(Adult_habitat) + log(mass):as.factor(Adult_habitat)`. `log(mass):as.factor(Adult_habitat)` is the interaction between mass and habitat, shown with the `:`.

Second, I've added `as.factor` in front of Adult_habitat. This is to get R to treat this variable as a factor with levels, rather than as either a numeric variable, or as character data. Here it is not strictly needed as R already thinks Adult_habitat is a factor, but it's a good idea to make sure.

Now we've fitted the model, we need to check the model diagnostic plots. If these are unsuitable then we need to rethink how we fit the model.

```{r}
# First make a plotting window with four panes as there are four plots
par(mfrow = c(2, 2))
# Now plot the model diagnostics
plot(model.pgls2)
# Return the plot window to one pane for later plotting
par(mfrow = c(1, 1))
```

And let's check out the lambda profile too.
```{r}
# Create a likelihood profile of the lambda estimate
lambda.profile <- pgls.profile(model.pgls2, "lambda")
# Plot the likelihood profile
plot(lambda.profile)
```
These all look fine to me so we can move on...

Let's look at the anova and summary outputs
```{r}
anova(model.pgls2)
```

OK great, this output is fairly easy to read. We can see that the main effect of log(mass) is significant, as is the main effect of Adult_habitat. We also see that the interaction between them `log(mass):as.factor(Adult_habitat)` is significant. 

What does this mean? Put simply, changes in log(mass) result in changes in log(eyesize) and changes in Adult_habitat also result in changes in log(eyesize). We can confirm that using a couple of plots...

```{r}
ggplot(mydata, aes(x = log(mass), y = log(eyesize))) +
  geom_point() +
  theme_bw()
```

```{r}
ggplot(mydata, aes(x = Adult_habitat, y = log(eyesize))) +
  geom_boxplot() +
  theme_bw()
```

As body size increases, so does eye size. Eye size is smallest, on average, in fossorial (burrowing) frogs. That fits with what we know about burowing animals - they tend to have reduced eyes (think of moles!).

What about the interaction term? This means that the *relationship* (i.e. the slope) between log(mass) and log(eyesize) varies in relation to Adult_habitat. We can look at this with another quick plot. 

```{r}
ggplot(mydata, aes(x = log(mass), y = log(eyesize), colour = Adult_habitat)) +
  geom_point() +
  geom_smooth(method = 'lm', se = FALSE) +
  theme_bw()
```
Note that I used `geom_smooth(method = 'lm', se = FALSE)` to get a quick idea of what the slopes look like using an `lm`. These slopes won't be exactly the same in the PGLS model, but it gives us an idea of what is going on (do not use plots like this in your reports/papers/thesis - these are for understanding only and are not accurate!). We can see that the slope for fossorial species is shallower than for other species, suggesting that eye size increases more slowly with increasing mass in that group.

We can get the intercepts and slopes for each of these lines using the `summary` function. I showed you the plots and `anova` output first because as you'll see belwo, summary outputs get complicated fast!

```{r}
summary(model.pgls2)
```

Again, if you're finding this confusing it might be worth brushing up on standard linear models with `lm`. But to briefly explain this output..

The row labelled `(Intercept)` give the intercept for the Adult_habitat that is first *alphabetically*. The row labelled `log(mass)` is the slope for the Adult_habitat that is first *alphabetically*. In this case that's the Aquatic habitat. All of the other intercepts and slopes are what is known as "treatment contrasts". Rather than the intercepts and slopes themselves, R reports the *difference* between the Adult_habitat in question and Aquatic (the first *alphabetically*). 

So the intercept for the fossorial frogs (`as.factor(Adult_habitat)Fossorial`) is... 
```{r}
1.063339 + 0.108237
```

And the slope for the fossorial frogs (`log(mass):as.factor(Adult_habitat)Fossorial`) is... 

```{r}
0.237742 + -0.114428
```

In some cases the exact numbers in the summary table will be important, but in most cases I'd report the results from a model like this using just the anova output, plus a nice figure that shows the information in the summary output much more clearly than copying out all these numbers.

***
## Common issues when running PGLS models in R

Our data are designed to work easily, but when you use your own data you may come across a couple of common errors. I therefore list these below.

### Optim errors
Sometimes you will find that `pgls` will not work and you get an `optim error`. This generally happens when the lambda profile is really flat, and the model is getting stuck near one of the bounds.

To fix this error you need to _change the bounds_ (i.e. upper and lower values) on the parameter being optimized, in this case $\lambda$. It usually seems to be the lower bound which is the issue. Just change the lower bound of $\lambda$ to something a little bigger than 1e-6 (the default lower bound) until it works. For example:

```{r, eval = FALSE}
# Fit PGLS model with a higher lower bound on lambda
model.pgls2 <- pgls(log(eyesize) ~ log(mass), 
                    data = frog, lambda = "ML", 
                    bounds = list(lambda = c(1e-05, 1)))
```

### Big problems with small datasets
You will often find strange $\lambda$ profiles when you don't have a lot of species in your data, because $\lambda$ has very low power to detect phylogenetic signal for less than 20-30 data points (see Freckleton et al. 2002). This means that using PGLS on small datasets is tricky - you almost always get ML $\lambda$ of zero but the $\lambda$ profile will show a pretty flat likelihood surface. Unfortunately people often forget to look at the $\lambda$ profile so erroneously conclude that there is no phylogenetic autocorrelation in their data.

Generally I'd say don't use small datasets, however, this seems unavoidable in some fields. Therefore my advice is to (only in this situation!) ignore one of Freckleton's deadly sins (2009, JEB) and report the results from an OLS model (equivalent of PGLS with $\lambda$ = 0) and *also* report the results from a PGLS model with $\lambda$ set to 1 (equivalent to independent contrasts). 
This problem comes up regularly, and current consensus among the PCM community is that this is best solution at present, if collecting more data is not an option.

To set $\lambda$ to 1 you just replace "ML" with 1

```{r}
# Fit PGLS model with lambda set to 1
model.pgls3 <- pgls(log(eyesize) ~ log(mass),
                    data = frog, lambda = 1)
```

## Practical exercises

In the data folder there is another tree (`consensusTree_10kTrees_Version2.nex`) and dataset (`primate-life-history-data.csv`) for investigating the evolution of primate life-history variables. These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold et al. 2010). 

Let's investigate the relationship between gestation length in Primates and their body size. Theory leads us to believe that bigger mammals have longer gestation lengths (compare mice to elephants), but is this true in Primates?

Read in the tree and data, then prepare them for a PCM analysis (you may have already done this in the previous exercise which should save you some time). Then fit a PGLS model to investigate the relationship between log gestation length (y = log(GestationLen_d)) and log body size (x = log(AdultBodyMass_g)) in primates. 
                        

## References
* Arnold, C., L. J. Matthews, and C. L. Nunn. 2010. The 10ktrees website: a new online resource for primate phylogeny. Evolutionary Anthropology: Issues, News, and Reviews 19:114–118.
* Blomberg, S. P., T. Garland, and A. R. Ives. 2003. Testing for phylogenetic signal in comparative data: behavioral traits are more labile. Evolution 57:717–745.
* Freckleton, R. P., P. H. Harvey, and M. Pagel. 2002. Phylogenetic analysis and comparative data: a test and review of evidence. The American Naturalist 160:712-726.
* Freckleton, R. P. (2009) The seven deadly sins of comparative analysis. Journal of Evolutionary Biology, 22, 1367–1375.
* Jones, K. E., J. Bielby, M. Cardillo, S. A. Fritz, J. O'Dell, C. D. L. Orme, K. Safi, W. Sechrest, E. H. Boakes, C. Carbone, et al. 2009. Pantheria: a species-level database of life history, ecology, and geography of extant and recently extinct mammals: Ecological archives e090-184. Ecology 90:2648–2648.
* Kamilar, J. M., & Cooper, N. 2013. Phylogenetic signal in primate behaviour, ecology and life history. Phil. Trans. R. Soc. B, 368(1618), 20120341.
* Pagel, M. 1999. Inferring the historical patterns of biological evolution. Nature, 401(6756), 877-884.
* Revell, L. J. 2010. Phylogenetic signal and linear regression on species data. Methods in Ecology and Evolution, 1, 319-329.

### Extra Reading
* Losos, J.B. (2011) Seeing the forest for the trees: the limitations of phylogenies in comparative biology. The American Naturalist, 177, 709–727.