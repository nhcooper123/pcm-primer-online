---
title: "Preparing your tree and data for PCMs in R"
author: "Natalie Cooper (natalie.cooper@nhm.ac.uk)"
date: "`r Sys.Date()`"
output:
  pdf_document: default
  html_document: default
---


# Preparing your tree and data for PCMs in R

Before we do any analysis in R we will always need to clean and tidy our data. For example, we might need to check XXXX.

In this exercise we will take an existing tree and some data and prepare them for a PCM analysis. Note that prior to this step, it is important that your data is in a tidy format, and has been thoroughly checked for errors. The exercise below only shows you how to deal with additional issues caused by using trees and then matching species data to those trees. We assume the tree and data themselves are fit for purpose.

We will be using the evolution of primate life-history variables as an example. 
These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold et al. 2010). 

```{block, type="info"}
- Download all of the data for the practical into a folder somewhere on your computer.
- Set your working directory to this folder. *actually let's change to projects*
- Start a new script for this practical.
```

You will also need to install the following packages: 

* `ape`
* `geiger`
* `tidyverse`

***
## Preparation
### Load the required packages
To begin we need to load the packages for this practical.

```{r, message = FALSE}
# Load packages
library(ape)
library(geiger)
library(tidyverse)
```

## Reading and checking your phylogeny in R
To load a tree you need either the function `read.tree` or `read.nexus`. `read.tree` can deal with a number of different types of data (including DNA) whereas `read.nexus` reads NEXUS files. We will use a NEXUS file of the consensus tree from 10kTrees.

```{r}
# Read in the tree
primatetree <- read.nexus("consensusTree_10kTrees_Version2.nex")
```

Let's examine the tree by typing:

```{r}
# Look at the tree summary
primatetree
```

```{r}
# Another way to look at the tree summary
str(primatetree)
```

It's usually a good idea to quickly plot the tree too...

```{r}
# Plot the tree as a circular/fan phylogeny with small labels
plot(primatetree, cex = 0.2, typ = "fan", no.margin = TRUE)
```

If you want to look at the options available for plotting phylogenies use
```{r}
# Access the helpfile for phylogeny plotting
?plot.phylo
```

```{block, type="info"}
The function we use to plot phylogenies is called `plot`. `plot` is one of a set of clever functions in R that uses an _ifelse_ statement to decide what kind of plot it should do. When you ask R to `plot` something, it first determines what _class_ of object it is. It then chooses the correct version of `plot` for that class. In this case the function it is actually using to plot the phylogeny is `plot.phylo`. This is important if you want to look at the help file for plotting phylogenies, you need to use `?plot.phylo` *not* `?plot`.
```

`primatetree` is a fully resolved tree with branch lengths. 
There are 226 species and 221 internal nodes. 

Most R functions require your tree to be dichotomous, i.e. to have no polytomies. To check whether your tree is dichotomous use `is.binary.tree`. 

```{r}
# Check whether the tree is binary
# We want this to be TRUE
is.binary.tree(primatetree) 
```

If this is FALSE, use `multi2di` to make the tree dichotomous. This function works by randomly resolving polytomies with zero-length branches. This doesn't change the tree overall, it's just a clever trick to get the functions to work.

```{r}
# Make the tree into a binary tree
primatetree <- multi2di(primatetree)

# Check whether the tree is now binary
# We want this to be TRUE
is.binary.tree(primatetree)
```

Most functions also require the tree to be rooted, i.e., to have one taxon designated as the outgroup. We can check whether the tree is rooted as follows.

```{r}
# Check whether the tree is rooted
# We want this to be TRUE
is.rooted(primatetree)
```

Our tree is rooted but if you wanted to change the root, or root an unrooted tree use `root`. 

```{block, type="info"}
There are many many ways we can plot beautiful phylogenies, and these are evolving all the time. We don't aim to cover these in this book but I recommend looking here....
```


## Reading the data into R
The data are in a comma-delimited text file called `Primatedata.csv`. Load these data as follows. 
*I am assuming you have set your working directory.*

```{r}
# Read in the data
primatedata <- read_csv("Primatedata.csv")
```

Check everything loaded correctly:

```{r}
# Look at the data
glimpse(primatedata)
```

As you can see, the data contains the following variables: `Order`, `Family`, `Binomial`, `AdultBodyMass_g`, `GestationLen_d`, `HomeRange_km2`, `MaxLongevity_m`, and `SocialGroupSize`.

## Matching your data to your phylogeny
Now we have the tree and the data in R, we need to match the two up if we want to perform any kind of PCM analyses. Below are some common issues you might encounter, and how to fix them.

### Species names with spaces
Species names in phylogenies are generally written as *Genus_species* (the gap between the genus name and species name is replaced by an underscore `_`). If the species names in the data are written as *Genus species* with a space, then you will have to replace the spaces with `_` so that they match up with the species names in the tree. You can do this as follows:

```{r}
# Replace spaces with underscores in species names
# Change to tidyverse version??
primatedata$Binomial <- gsub(" ", "_", primatedata$Binomial)
```

`gsub` means general substitution. 
It replaces any instance of the first item (here it's a space) with the second item (_) but only in the variable you tell it to (`primatedata$Binomial`).

### Mismatches between species in your data and phylogeny
Often you will have data for species which are not in your phylogeny and/or species in your phylogeny which are not in your data. Many functions in R can deal with this and will match the species for you, others will produce an error telling you the tree and data do not match (e.g. most `ape` functions). 

Even in functions that can cope with this, it's useful to match up the species *before* your analyses. This can help you identify things like spelling mistakes or variations in the taxonomy of the tree and the data. 

```{block, type = "info"}
If you have even slightly misspelled a species name in the tree or the data it will automatically be dropped from the analyses. It is therefore **very important** to check this before running an analysis, especially one with lots of taxa.
```

First we can use the function `name.check` to find out which names do not match.

```{r, message = FALSE}
# Check whether the names match in the data and the tree
check <- name.check(phy = primatetree, data = primatedata, 
                    data.names = primatedata$Binomial)
```

You can look at `check` by printing it, I won't do this here as it produces a lot of output but take a look on your computer.

```{r, eval = FALSE}
check
```

`check` has two parts, `tree_not_data` for species in the tree but not in the dataset, and `data_not_tree` for species in the dataset but not in the tree.

We can remove species missing from the tree easily using `drop.tip`. You need to list the species which you do **not** want to select and then drop them from the tree instead of selecting the species you do want.

```{r}
# Drop species tips from the tree that are not in the dataset
primatetree <- drop.tip(primatetree, check$tree_not_data)
```

##### hcnage this to tidy verse and also make sure there is a species
In this case we don't have any species in the tree missing from the data, `data_not_tree` contains no species. 
However, if you do, to remove species from the data which are not in the tree you can use `match` and `subset` as follows:

```{r}
matches <- match(primatedata$Binomial, check$data_not_tree, nomatch = 0)
primatedata <- subset(primatedata, matches == 0)
```

`==` means *equals*. 
So this line of code selects species which do appear in the `data_not_tree` list of species, i.e. their value from `matches` is 0. 

Always check this has worked as expected by checking the data and the phylogeny. In the first instance you can just use `str` to make sure you have the expected number of species in each:

```{r}
str(primatedata)
```

```{r}
str(primatetree)
```

Finally, we might want to output these cleaned and tidied data and tree to our folder so rather than doing this everytime we start an analysis, we can just use these tidy versions. To do this we can use:

```{r, eval = FALSE}
# Write the cleaned data to a new file
write_csv(primatedata, path = "clean-primate-data.csv")

# Write the cleaned tree to a new file
write.nexus(primatetree, file = "clean-primate-tree.nex")
```

Note, however, that you will have to repeat this preparation process if you add species to your tree or dataset.