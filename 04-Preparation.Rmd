# Preparing your tree and data for PCMs in R

Before we do any analysis in R we will generally need to clean and tidy our data. Data cleaning involves looking for errors, for example we might need to remove duplicate columns, or correct typos in species names, or make sure column headers are all unique and easy enough for us to type in R. We also often need to tidy our data. For data to be *tidy*:

* Each variable must have its own column.
* Each observation must have its own row.
* Each value must have its own cell.

The R packages `dplyr`, `tidyr` are great for data cleaning and tidying. See [https://r4ds.had.co.nz/tidy-data.html](https://r4ds.had.co.nz/tidy-data.html) for more details on what tidy data is and how to do this in R. Of course you are welcome to do this in Excel or another package if you're more comfortable with that. The important thing is that when you begin your analyses, your data are in a suitable format. Note that a detailed introduction to data manipulation in R is beyond the scope of this *Primer*, but if in doubt about your data, try and make it look as much like our example datasets as possible. If you can do that, these R analyses should work for you! :)

In this exercise we will take an existing tree and some data and prepare them for a PCM analysis. Note that prior to this step, it is important that your data is in a tidy format, and has been thoroughly checked for errors. The exercise below only shows you how to deal with additional issues caused by using trees and then matching species data to those trees. We assume the tree and data themselves are fit for purpose.

We will be using the evolution of primate life-history variables as an example. 
These data come from the PanTHERIA database (Jones et al. 2009) and 10kTrees (Arnold et al. 2010). 

## Before you start
- Open the `04_Preparation.RProj` file in the `04_Preparation` folder to open your R Project for this exercise.
- Make yourself a new R script for your code.

You will also need to install the following packages: 

* `ape`
* `geiger`
* `tidyverse`
* `treeplyr`

***
## Preparation 
### Load the required packages
To begin we need to load the packages for this practical.

```{r, message = FALSE}
# Load packages
library(ape)
library(geiger)
library(tidyverse)
library(treeplyr)
```

## Reading and checking your phylogeny in R

We already learned how to do these things in `03-Phylogenies.Rmd`. If you haven't looked at that exercise I suggest you check it out before doing the steps below.

First let's read in the tree and look at its structure:
```{r}
# Read in the tree
primatetree <- read.nexus("data/consensusTree_10kTrees_Version2.nex")
# Look at the tree summary
str(primatetree)
```

It's usually a good idea to quickly plot the tree too...
```{r}
# Plot the tree as a circular/fan phylogeny with small labels
plot(primatetree, cex = 0.2, typ = "fan", no.margin = TRUE)
```

`primatetree` is a fully resolved tree with branch lengths. 
There are 226 species and 221 internal nodes. 

Most R functions require your tree to be dichotomous, i.e. to have no polytomies. To check whether your tree is dichotomous use `is.binary.tree`. 

```{r}
# Check whether the tree is binary
# We want this to be TRUE
is.binary.tree(primatetree) 
```

This is FALSE, so we use `multi2di` to make the tree dichotomous.

```{r}
# Make the tree into a binary tree
primatetree <- multi2di(primatetree)

# Check whether the tree is now binary
# We want this to be TRUE
is.binary.tree(primatetree)
```

Most functions also require the tree to be rooted, i.e., to have one taxon designated as the outgroup. We can check whether the tree is rooted as follows.

```{r}
# Check whether the tree is rooted
# We want this to be TRUE
is.rooted(primatetree)
```

Our tree is rooted so it's ready to go.

## Reading the data into R
The data are in a comma-delimited text file called `Primatedata.csv`. Load these data as follows.

```{r}
# Read in the data
primatedata <- read_csv("data/Primatedata.csv")
```

Check everything loaded correctly:

```{r}
# Look at the data
glimpse(primatedata)
```

As you can see, the data contains the following variables: `Order`, `Family`, `Binomial`, `AdultBodyMass_g`, `GestationLen_d`, `HomeRange_km2`, `MaxLongevity_m`, and `SocialGroupSize`.

## Matching your data to your phylogeny
Now we have the tree and the data in R, we need to match the two up if we want to perform any kind of PCM analyses. Below are some common issues you might encounter, and how to fix them.

### Species names with spaces
Species names in phylogenies are generally written as *Genus_species* (the gap between the genus name and species name is replaced by an underscore `_`). If the species names in the data are written as *Genus species* with a space, then you will have to replace the spaces with `_` so that they match up with the species names in the tree. You can do this as follows using `str_replace`.

```{r}
# Replace spaces with underscores in species names
primatedata <- 
  primatedata %>%
  mutate(Binomial = str_replace(string = Binomial, pattern = " ", replacement = "_"))

# Check it worked
glimpse(primatedata)
```

### Mismatches between species in your data and phylogeny
Often you will have data for species which are not in your phylogeny and/or species in your phylogeny which are not in your data. Many functions in R can deal with this and will match the species for you, others will produce an error telling you the tree and data do not match (e.g. most `ape` functions). 

Even in functions that can cope with this, it's useful to match up the species *before* your analyses. This can help you identify things like spelling mistakes or variations in the taxonomy of the tree and the data. 

```{block, type = "info"}
If you have even slightly misspelled a species name in the tree or the data it will automatically be dropped from the analyses. It is therefore **very important** to check this before running an analysis, especially one with lots of taxa.
```

We can use the `geiger` function `name.check` to find out which names do not match. 

```{r, message = FALSE}
# Check whether the names match in the data and the tree
check <- name.check(phy = primatetree, data = primatedata, 
                    data.names = primatedata$Binomial)
```

The output of `check` has two parts, `tree_not_data` for species in the tree but not in the dataset, and `data_not_tree` for species in the dataset but not in the tree. You need to look at both of these in turn.

```{r, eval = FALSE}
# Look at species in the tree but not the data
check$tree_not_data
```

I have deliberately not printed this as it's very long, but for your analyses you should *always* check this list carefully. Here are the first 6 entries...

```{r}
# Look at species in the tree but not the data - first 6
head(check$tree_not_data)
```
If I were running this analysis for the first time I'd want to check that these species really weren't in my dataset. Maybe they are misspelled in the data? If so correct this now. Maybe the species name has changed? If so change this now. It doesn't really matter whether you make the change in the tree or the data, but make sure anything that *should* match up, does. I'd usually fix issues in the dataset, unless it's a blatant typo.

Next check the species in the data but not the tree.

```{r}
# Look at species in the data but not the tree
check$data_not_tree
```
This gives us `character(0)` here because all species in the dataset are found in the tree. Often this will not be the case, so as above make sure to correct any errors before moving to the next step.

### Matching the tree and the data 
finally, once we know which species do not match up, we need to remove species missing from the data from the tree, and remove species missing from the tree from the data. This used to be a bit of a pain, but `treeplyr` makes it easy. `treeplyr` has a lot of really cool functions, see the [wiki](https://github.com/uyedaj/treeplyr/wiki) for more details. However, here we are just going to use it just to match up the tree and the data.

We'll use the function `make.treedata` to combine the tree and the dataset into one object. We need to provide the name of the tree, the name of the data, and specify which column our species names are in. 

```{r}
# Combine and match the tree and data
primatestuff <- make.treedata(tree = primatetree,  data = primatedata, 
                              name_column = "Binomial")
```

Note that we could leave out the `name_column = Binomial` argument, in which case the function `make.treedata` will search the data for the column with the contents that have most matches to the tree, and automatically use this column for matching up species names. It will also search the rownames.

To look at the tree and data combined we can use `summary`:

```{r}
summary(primatestuff)
```

You may notice that `make.treedata` has two objects within it, the tree and the data. You can access the tree using `primatestuff$phy` and the data using `primatestuff$dat`. 

Let's look at the phylogeny first...

```{r}
# Look at the tree summary
primatestuff$phy
```

The matched phylogeny has 77 species in it (instead of the original 226 species in `primatetree`).

Now let's look at the data. What is missing?
```{r}
# Look at the data
glimpse(primatestuff$dat)
```

We now have 77 species in the dataset too, great! But hopefully you noticed that the column with the species names in it (`Binomial`) has disappeared! `treeplyr` is designed to work with R functions that assume species names will be in the rownames of your data. However, not all PCMs in R work this way, and I personally like to be able to see species names when I quickly look at a dataset. We can make a new species names column using the tip labels from the phylogeny, as `make.treedata` orders the data so it's the same as the tip labels.

```{r}
# Make a new column called Binomial with the tip labels in it
primatestuff$dat$Binomial <- primatestuff$phy$tip.label
```

Finally we might want to rename the tree and data to make them a bit less clunky when typing in your code.

```{r}
# Save tree as mytree
mytree <- primatestuff$phy
# Save data as mydata
mydata <- primatestuff$dat
```

For the data, I'm also going to add one last trick to make our lives easier. `treeplyr` relies on the `tidyverse` set of packages, which create special dataframes called tibbles. Tibbles are great, *but* some older PCM functions cannot work with them, and need the data to be in an ordinary dataframe instead. We can fix this using `as.data.frame`.

```{r}
# Look at the structure of mydata
str(mydata)
```

```{r}
# Force mydata to be a data frame
mydata <- as.data.frame(mydata)
# Check mydata is now a dataframe
str(mydata)
```

Finally, we might want to output these cleaned and tidied data and tree to our folder so rather than doing this everytime we start an analysis, we can just use these tidy versions. To do this we can use:

```{r, eval = FALSE}
# Write the cleaned data to a new file
write_csv(mydata, path = "data/clean-primate-data.csv")

# Write the cleaned tree to a new file
write.nexus(mytree, file = "data/clean-primate-tree.nex")
```

Note, however, that you will have to repeat this preparation process if you add species or data to your tree or dataset.

### Subsetting your tree and data 
Another thing that `treeplyr` makes a lot easier is subsetting your tree and data. It's fairly common, especially with large phylogenies, that we might want to run our analyses on subsets of the data. Generally these are taxonomic divisions, but you might also want to divide your analyses into large and small body size species, for example.

One solution would be to make a new dataset, and then run through the same procedure as we've used above. However, we can instead just subset the tree data object itself using `filter`. This works the same as `filter` normally does in `dplyr`. As an example, let's select only species in the family Cebidae.

```{r}
# Subset only the species in the Cebidae family 
cebidae <- filter(primatestuff, Family == "Cebidae")

# Plot tree to check it worked
plot(cebidae$phy)
```

You might still want to save these as separate data and phylogeny objects, and don't forget to make the data into a dataframe. 

## Quick template code
To help you do this with your own data, I've condensed the above into one script below so you don't forget any of the steps.

```{r, eval = FALSE}
# Load packages
library(ape)
library(geiger)
library(tidyverse)
library(treeplyr)

# Read in the tree
primatetree <- read.nexus("data/consensusTree_10kTrees_Version2.nex")
# Look at the tree summary
str(primatetree)

# Plot the tree as a circular/fan phylogeny with small labels
plot(primatetree, cex = 0.2, typ = "fan", no.margin = TRUE)

# Check whether the tree is binary
# We want this to be TRUE
is.binary.tree(primatetree) 

# Make the tree into a binary tree
primatetree <- multi2di(primatetree)

# Check whether the tree is now binary
# We want this to be TRUE
is.binary.tree(primatetree)

# Check whether the tree is rooted
# We want this to be TRUE
is.rooted(primatetree)

# Read in the data
primatedata <- read_csv("data/Primatedata.csv")

# Look at the data
glimpse(primatedata)

# Replace spaces with underscores in species names
primatedata <- 
  primatedata %>%
  mutate(Binomial = str_replace(string = Binomial, pattern = " ", replacement = "_"))

# Check it worked
glimpse(primatedata)

# Check whether the names match in the data and the tree
check <- name.check(phy = primatetree, data = primatedata, 
                    data.names = primatedata$Binomial)
# Look at check
check

### Correct any typos/taxonomic errors in the tree or data ###
  
# Combine and match the tree and data
primatestuff <- make.treedata(tree = primatetree,  data = primatedata, 
                              name_column = "Binomial")

# Look at the tree summary
primatestuff$phy

# Look at the data
glimpse(primatestuff$dat)

# Make a new column called Binomial with the tip labels in it
primatestuff$dat$Binomial <- primatestuff$phy$tip.label

# Save tree as mytree
mytree <- primatestuff$phy
# Save data as mydata
mydata <- primatestuff$dat

# Force mydata to be a data frame
mydata <- as.data.frame(mydata)
# Check mydata is now a dataframe
str(mydata)

## OPTIONAL
# Make any required subsets of the tree/data

## OPTIONAL
# Write the cleaned data to a new file
write_csv(mydata, path = "data/clean-primate-data.csv")

# Write the cleaned tree to a new file
write.nexus(mytree, file = "data/clean-primate-tree.nex")
```

